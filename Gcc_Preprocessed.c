# 1 "gcc.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "gcc.c"
# 33 "gcc.c"
# 1 "config.h" 1





# 1 "auto-host.h" 1
# 7 "config.h" 2
# 34 "gcc.c" 2
# 1 "system.h" 1
# 28 "system.h"
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 29 "system.h" 2
# 39 "system.h"
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 3 4
typedef unsigned int size_t;
# 323 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 3 4
typedef int wchar_t;
# 40 "system.h" 2


# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 313 "/usr/include/features.h" 3 4
# 1 "/usr/include/bits/predefs.h" 1 3 4
# 314 "/usr/include/features.h" 2 3 4
# 346 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 353 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 354 "/usr/include/sys/cdefs.h" 2 3 4
# 347 "/usr/include/features.h" 2 3 4
# 378 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4


# 1 "/usr/include/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/gnu/stubs.h" 2 3 4
# 379 "/usr/include/features.h" 2 3 4
# 29 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 170 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 460 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__));
# 490 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__));
# 76 "/usr/include/stdio.h" 2 3 4
# 89 "/usr/include/stdio.h" 3 4




typedef _G_fpos64_t fpos_t;



typedef _G_fpos64_t fpos64_t;
# 141 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 142 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) __attribute__ ((__nothrow__));

extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__));




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) __attribute__ ((__nothrow__));



# 175 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64") ;






extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__)) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 229 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);




# 260 "/usr/include/stdio.h" 3 4
extern FILE *fopen (__const char *__restrict __filename, __const char *__restrict __modes) __asm__ ("" "fopen64")

  ;
extern FILE *freopen (__const char *__restrict __filename, __const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


  ;







extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__)) ;




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  __attribute__ ((__nothrow__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__));








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
# 394 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));
# 445 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 504 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 532 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 543 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 576 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 622 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 638 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 699 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 710 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 754 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64");


extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");








# 779 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64");

extern int fsetpos (FILE *__stream, __const fpos_t *__pos) __asm__ ("" "fsetpos64");









extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 827 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
# 846 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__));
# 916 "/usr/include/stdio.h" 3 4

# 43 "system.h" 2
# 193 "system.h"
# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;





typedef __ino64_t ino_t;




typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;







typedef __off64_t off_t;




typedef __off64_t off64_t;




typedef __pid_t pid_t;




typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 217 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 218 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 23 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/select.h" 2 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 45 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4

# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);



# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__));
# 224 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;
# 248 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;





typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;
# 67 "/usr/include/bits/pthreadtypes.h" 3 4
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;





typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;





    int __kind;





    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };

  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
# 170 "/usr/include/bits/pthreadtypes.h" 3 4
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;

  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/sys/types.h" 2 3 4



# 194 "system.h" 2

# 1 "/usr/include/errno.h" 1 3 4
# 32 "/usr/include/errno.h" 3 4




# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/asm/errno.h" 2 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4
# 43 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 37 "/usr/include/errno.h" 2 3 4
# 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;




# 69 "/usr/include/errno.h" 3 4
typedef int error_t;
# 196 "system.h" 2
# 210 "system.h"
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 94 "/usr/include/string.h" 3 4
extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 108 "/usr/include/string.h" 3 4
extern void *rawmemchr (__const void *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 119 "/usr/include/string.h" 3 4
extern void *memrchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));






# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 162 "/usr/include/string.h" 2 3 4


extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 208 "/usr/include/string.h" 3 4

# 233 "/usr/include/string.h" 3 4
extern char *strchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/string.h" 3 4
extern char *strrchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 274 "/usr/include/string.h" 3 4
extern char *strchrnul (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 312 "/usr/include/string.h" 3 4
extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/string.h" 3 4
extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
# 371 "/usr/include/string.h" 3 4
extern char *strcasestr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__));

# 436 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 487 "/usr/include/string.h" 3 4
extern char *index (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 515 "/usr/include/string.h" 3 4
extern char *rindex (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__));


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 604 "/usr/include/string.h" 3 4
extern char *basename (__const char *__filename) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 644 "/usr/include/string.h" 3 4

# 211 "system.h" 2
# 1 "/usr/include/strings.h" 1 3 4
# 212 "system.h" 2
# 223 "system.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 68 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__)) ;




extern double atof (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

# 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;
# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__)) ;


extern long int a64l (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 327 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__));







extern double drand48 (void) __attribute__ ((__nothrow__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__));



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__));






# 498 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 527 "/usr/include/stdlib.h" 3 4
extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void quick_exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__));






extern int clearenv (void) __attribute__ ((__nothrow__));
# 604 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 618 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 640 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64") __attribute__ ((__nonnull__ (1))) ;






extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 658 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 672 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 693 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")

     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 729 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__)) ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;

# 802 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__)) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__));

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__));








extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 890 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 958 "/usr/include/stdlib.h" 3 4

# 224 "system.h" 2
# 248 "system.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4

# 203 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 204 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/environments.h" 2 3 4
# 208 "/usr/include/unistd.h" 2 3 4
# 227 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 228 "/usr/include/unistd.h" 2 3 4
# 268 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 288 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) __asm__ ("" "lseek64") __attribute__ ((__nothrow__));







extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 385 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64") ;


extern ssize_t pwrite (int __fd, __const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64") ;
# 401 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__)) ;
# 429 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__));
# 441 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__));






extern int usleep (__useconds_t __useconds);
# 465 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__)) ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__)) ;
# 507 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__));






extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__));



extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     __attribute__ ((__nothrow__));




extern int execv (__const char *__path, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int execvpe (__const char *__file, char *__const __argv[],
      char *__const __envp[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int nice (int __inc) __attribute__ ((__nothrow__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS

  };
# 605 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__));




extern __pid_t getpgrp (void) __attribute__ ((__nothrow__));
# 641 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__));
# 667 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__));
# 684 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) __attribute__ ((__nothrow__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__));




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__));






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__));




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__));




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__));





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__));



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__));






extern __pid_t fork (void) __attribute__ ((__nothrow__));






extern __pid_t vfork (void) __attribute__ ((__nothrow__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__));





extern int ttyslot (void) __attribute__ ((__nothrow__));




extern int link (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 887 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__));
# 888 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__));


extern int revoke (__const char *__file) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) __attribute__ ((__nothrow__));



extern char *getusershell (void) __attribute__ ((__nothrow__));
extern void endusershell (void) __attribute__ ((__nothrow__));
extern void setusershell (void) __attribute__ ((__nothrow__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__)) ;






extern int chroot (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 973 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__));




extern int getpagesize (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__));
# 1002 "/usr/include/unistd.h" 3 4
extern int truncate (__const char *__file, __off64_t __length) __asm__ ("" "truncate64") __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;







extern int truncate64 (__const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 1023 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off64_t __length) __asm__ ("" "ftruncate64") __attribute__ ((__nothrow__)) ;






extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__)) ;
# 1040 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__));
# 1061 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__));
# 1087 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64") ;






extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1115 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) __attribute__ ((__nothrow__));
# 1153 "/usr/include/unistd.h" 3 4

# 249 "system.h" 2



# 1 "/usr/include/sys/param.h" 1 3 4
# 26 "/usr/include/sys/param.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include-fixed/limits.h" 1 3 4
# 11 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include-fixed/limits.h" 1 3 4
# 122 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 157 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/bits/local_lim.h" 2 3 4
# 158 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include-fixed/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include-fixed/limits.h" 2 3 4
# 27 "/usr/include/sys/param.h" 2 3 4

# 1 "/usr/include/linux/param.h" 1 3 4



# 1 "/usr/include/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 1 "/usr/include/asm/param.h" 2 3 4
# 5 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/sys/param.h" 2 3 4
# 253 "system.h" 2





# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include-fixed/limits.h" 1 3 4
# 259 "system.h" 2



# 1 "hwint.h" 1
# 166 "hwint.h"
extern int clz_hwi (unsigned long long x);
extern int ctz_hwi (unsigned long long x);
extern int ffs_hwi (unsigned long long x);


extern int exact_log2 (unsigned long long);


extern int floor_log2 (unsigned long long);
# 237 "hwint.h"
extern long long abs_hwi (long long);
extern unsigned long long absu_hwi (long long);
extern long long gcd (long long, long long);
extern long long pos_mul_hwi (long long, long long);
extern long long mul_hwi (long long, long long);
extern long long least_common_multiple (long long, long long);
# 263 "system.h" 2
# 292 "system.h"
# 1 "/usr/include/sys/time.h" 1 3 4
# 27 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 28 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 30 "/usr/include/sys/time.h" 2 3 4
# 39 "/usr/include/sys/time.h" 3 4

# 57 "/usr/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 73 "/usr/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int settimeofday (__const struct timeval *__tv,
    __const struct timezone *__tz)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int adjtime (__const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;






extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__));




extern int setitimer (__itimer_which_t __which,
        __const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__));




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, __const struct timeval __tvp[2]) __attribute__ ((__nothrow__));






extern int futimesat (int __fd, __const char *__file,
        __const struct timeval __tvp[2]) __attribute__ ((__nothrow__));
# 191 "/usr/include/sys/time.h" 3 4

# 293 "system.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 43 "/usr/include/time.h" 2 3 4
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 180 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__));







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__));



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__));






extern struct tm *gmtime (__const time_t *__timer) __attribute__ ((__nothrow__));



extern struct tm *localtime (__const time_t *__timer) __attribute__ ((__nothrow__));





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__));



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__));





extern char *asctime (__const struct tm *__tp) __attribute__ ((__nothrow__));


extern char *ctime (__const time_t *__timer) __attribute__ ((__nothrow__));







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__));


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__));



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) __attribute__ ((__nothrow__));
# 313 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__));


extern int dysize (int __year) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 328 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__));


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     __attribute__ ((__nothrow__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__));


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__));
# 390 "/usr/include/time.h" 3 4
extern int getdate_err;
# 399 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 413 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 294 "system.h" 2
# 305 "system.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 30 "/usr/include/fcntl.h" 3 4




# 1 "/usr/include/bits/fcntl.h" 1 3 4
# 25 "/usr/include/bits/fcntl.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/fcntl.h" 2 3 4

# 1 "/usr/include/bits/uio.h" 1 3 4
# 44 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 28 "/usr/include/bits/fcntl.h" 2 3 4
# 160 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;




    __off64_t l_start;
    __off64_t l_len;

    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };




enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_GID
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 257 "/usr/include/bits/fcntl.h" 3 4





extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__));



extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
       unsigned int __flags);



extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
    size_t __count, unsigned int __flags);


extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
         __off64_t *__offout, size_t __len,
         unsigned int __flags);


extern ssize_t tee (int __fdin, int __fdout, size_t __len,
      unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off64_t __offset, __off64_t __len) __asm__ ("" "fallocate64");







extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




# 35 "/usr/include/fcntl.h" 2 3 4



# 1 "/usr/include/sys/stat.h" 1 3 4
# 105 "/usr/include/sys/stat.h" 3 4


# 1 "/usr/include/bits/stat.h" 1 3 4
# 43 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;

    unsigned short int __pad1;




    __ino_t __st_ino;


    __mode_t st_mode;
    __nlink_t st_nlink;




    __uid_t st_uid;
    __gid_t st_gid;



    __dev_t st_rdev;

    unsigned short int __pad2;




    __off64_t st_size;

    __blksize_t st_blksize;



    __blkcnt64_t st_blocks;
# 88 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 109 "/usr/include/bits/stat.h" 3 4
    __ino64_t st_ino;


  };



struct stat64
  {
    __dev_t st_dev;





    unsigned int __pad1;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;

    __uid_t st_uid;
    __gid_t st_gid;





    __dev_t st_rdev;
    unsigned int __pad2;
    __off64_t st_size;

    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 166 "/usr/include/bits/stat.h" 3 4
    __ino64_t st_ino;

  };
# 108 "/usr/include/sys/stat.h" 2 3 4
# 217 "/usr/include/sys/stat.h" 3 4
extern int stat (__const char *__restrict __file, struct stat *__restrict __buf) __asm__ ("" "stat64") __attribute__ ((__nothrow__))

     __attribute__ ((__nonnull__ (1, 2)));
extern int fstat (int __fd, struct stat *__buf) __asm__ ("" "fstat64") __attribute__ ((__nothrow__))
     __attribute__ ((__nonnull__ (2)));






extern int stat64 (__const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
# 243 "/usr/include/sys/stat.h" 3 4
extern int fstatat (int __fd, __const char *__restrict __file, struct stat *__restrict __buf, int __flag) __asm__ ("" "fstatat64") __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
# 253 "/usr/include/sys/stat.h" 3 4
extern int fstatat64 (int __fd, __const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
# 267 "/usr/include/sys/stat.h" 3 4
extern int lstat (__const char *__restrict __file, struct stat *__restrict __buf) __asm__ ("" "lstat64") __attribute__ ((__nothrow__))


     __attribute__ ((__nonnull__ (1, 2)));





extern int lstat64 (__const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (__const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (__const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__));





extern int fchmodat (int __fd, __const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__));



extern int mkdir (__const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (__const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, __const char *__path,
        __const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, __const struct timespec __times[2]) __attribute__ ((__nothrow__));
# 410 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf) __asm__ ("" "__fxstat64") __attribute__ ((__nothrow__))

     __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, __const char *__filename, struct stat *__stat_buf) __asm__ ("" "__xstat64") __attribute__ ((__nothrow__))

     __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, __const char *__filename, struct stat *__stat_buf) __asm__ ("" "__lxstat64") __attribute__ ((__nothrow__))

     __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, __const char *__filename, struct stat *__stat_buf, int __flag) __asm__ ("" "__fxstatat64") __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4)));
# 432 "/usr/include/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, __const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, __const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, __const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, __const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, __const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 5)));
# 534 "/usr/include/sys/stat.h" 3 4

# 39 "/usr/include/fcntl.h" 2 3 4
# 64 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 76 "/usr/include/fcntl.h" 3 4
extern int open (__const char *__file, int __oflag, ...) __asm__ ("" "open64")
     __attribute__ ((__nonnull__ (1)));





extern int open64 (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 101 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, __const char *__file, int __oflag, ...) __asm__ ("" "openat64") __attribute__ ((__nonnull__ (2)));






extern int openat64 (int __fd, __const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 121 "/usr/include/fcntl.h" 3 4
extern int creat (__const char *__file, __mode_t __mode) __asm__ ("" "creat64") __attribute__ ((__nonnull__ (1)));






extern int creat64 (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 168 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off64_t __offset, __off64_t __len, int __advise) __asm__ ("" "posix_fadvise64") __attribute__ ((__nothrow__));







extern int posix_fadvise64 (int __fd, __off64_t __offset, __off64_t __len,
       int __advise) __attribute__ ((__nothrow__));
# 189 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off64_t __offset, __off64_t __len) __asm__ ("" "posix_fallocate64");







extern int posix_fallocate64 (int __fd, __off64_t __offset, __off64_t __len);
# 208 "/usr/include/fcntl.h" 3 4

# 306 "system.h" 2
# 346 "system.h"
# 1 "/usr/include/sys/wait.h" 1 3 4
# 29 "/usr/include/sys/wait.h" 3 4


# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 104 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 34 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

# 58 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/signum.h" 1 3 4
# 59 "/usr/include/signal.h" 2 3 4
# 79 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 51 "/usr/include/bits/siginfo.h" 3 4
typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 3)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;
      } _sifields;
  } siginfo_t;
# 129 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 273 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 3)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     void *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 80 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
# 113 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));






extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__));




extern int raise (int __sig) __attribute__ ((__nothrow__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__));




extern void psignal (int __sig, __const char *__s);




extern void psiginfo (__const siginfo_t *__pinfo, __const char *__s);
# 168 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 177 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 196 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));
# 211 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (__const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (__const sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, __const sigset_t *__left,
        __const sigset_t *__right) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, __const sigset_t *__left,
       __const sigset_t *__right) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 25 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 253 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__));






extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (__const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (__const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     __attribute__ ((__nothrow__));
# 310 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[65];
extern __const char *__const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 334 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, __const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__));



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 26 "/usr/include/bits/sigcontext.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/sigcontext.h" 2 3 4

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};





struct _fpstate
{

  __uint32_t cw;
  __uint32_t sw;
  __uint32_t tag;
  __uint32_t ipoff;
  __uint32_t cssel;
  __uint32_t dataoff;
  __uint32_t datasel;
  struct _fpreg _st[8];
  unsigned short status;
  unsigned short magic;


  __uint32_t _fxsr_env[6];
  __uint32_t mxcsr;
  __uint32_t reserved;
  struct _fpxreg _fxsr_st[8];
  struct _xmmreg _xmm[8];
  __uint32_t padding[56];
};
# 81 "/usr/include/bits/sigcontext.h" 3 4
struct sigcontext
{
  unsigned short gs, __gsh;
  unsigned short fs, __fsh;
  unsigned short es, __esh;
  unsigned short ds, __dsh;
  unsigned long edi;
  unsigned long esi;
  unsigned long ebp;
  unsigned long esp;
  unsigned long ebx;
  unsigned long edx;
  unsigned long ecx;
  unsigned long eax;
  unsigned long trapno;
  unsigned long err;
  unsigned long eip;
  unsigned short cs, __csh;
  unsigned long eflags;
  unsigned long esp_at_signal;
  unsigned short ss, __ssh;
  struct _fpstate * fpstate;
  unsigned long oldmask;
  unsigned long cr2;
};
# 340 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__));






# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 350 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__));

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 26 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 50 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 357 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/sys/ucontext.h" 1 3 4
# 23 "/usr/include/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 24 "/usr/include/sys/ucontext.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 25 "/usr/include/sys/ucontext.h" 2 3 4
# 148 "/usr/include/sys/ucontext.h" 3 4
typedef int greg_t;





typedef greg_t gregset_t[19];



enum
{
  REG_GS = 0,

  REG_FS,

  REG_ES,

  REG_DS,

  REG_EDI,

  REG_ESI,

  REG_EBP,

  REG_ESP,

  REG_EBX,

  REG_EDX,

  REG_ECX,

  REG_EAX,

  REG_TRAPNO,

  REG_ERR,

  REG_EIP,

  REG_CS,

  REG_EFL,

  REG_UESP,

  REG_SS

};



struct _libc_fpreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
};

struct _libc_fpstate
{
  unsigned long int cw;
  unsigned long int sw;
  unsigned long int tag;
  unsigned long int ipoff;
  unsigned long int cssel;
  unsigned long int dataoff;
  unsigned long int datasel;
  struct _libc_fpreg _st[8];
  unsigned long int status;
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;


    fpregset_t fpregs;
    unsigned long int oldmask;
    unsigned long int cr2;
  } mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 360 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__));







extern int sighold (int __sig) __attribute__ ((__nothrow__));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__));


extern int sigignore (int __sig) __attribute__ ((__nothrow__));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__));






# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       __const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__));
# 396 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__));




# 32 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 25 "/usr/include/sys/resource.h" 3 4
# 1 "/usr/include/bits/resource.h" 1 3 4
# 33 "/usr/include/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,


  __RLIMIT_NLIMITS = 15,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
# 129 "/usr/include/bits/resource.h" 3 4
typedef __rlim64_t rlim_t;


typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1



  ,

  RUSAGE_THREAD = 1




};


# 1 "/usr/include/bits/time.h" 1 3 4
# 176 "/usr/include/bits/resource.h" 2 3 4


struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    long int ru_maxrss;


    long int ru_ixrss;

    long int ru_idrss;

    long int ru_isrss;


    long int ru_minflt;

    long int ru_majflt;

    long int ru_nswap;


    long int ru_inblock;

    long int ru_oublock;

    long int ru_msgsnd;

    long int ru_msgrcv;

    long int ru_nsignals;



    long int ru_nvcsw;


    long int ru_nivcsw;
  };







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};
# 26 "/usr/include/sys/resource.h" 2 3 4













typedef enum __rlimit_resource __rlimit_resource_t;
typedef enum __rusage_who __rusage_who_t;
typedef enum __priority_which __priority_which_t;
# 55 "/usr/include/sys/resource.h" 3 4
extern int getrlimit (__rlimit_resource_t __resource, struct rlimit *__rlimits) __asm__ ("" "getrlimit64") __attribute__ ((__nothrow__));






extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) __attribute__ ((__nothrow__));
# 74 "/usr/include/sys/resource.h" 3 4
extern int setrlimit (__rlimit_resource_t __resource, __const struct rlimit *__rlimits) __asm__ ("" "setrlimit64") __attribute__ ((__nothrow__));







extern int setrlimit64 (__rlimit_resource_t __resource,
   __const struct rlimit64 *__rlimits) __attribute__ ((__nothrow__));




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __attribute__ ((__nothrow__));





extern int getpriority (__priority_which_t __which, id_t __who) __attribute__ ((__nothrow__));



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     __attribute__ ((__nothrow__));


# 33 "/usr/include/sys/wait.h" 2 3 4
# 102 "/usr/include/sys/wait.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 116 "/usr/include/sys/wait.h" 3 4
extern __pid_t wait (__WAIT_STATUS __stat_loc);
# 139 "/usr/include/sys/wait.h" 3 4
extern __pid_t waitpid (__pid_t __pid, int *__stat_loc, int __options);



# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4
# 144 "/usr/include/sys/wait.h" 2 3 4
# 155 "/usr/include/sys/wait.h" 3 4
extern int waitid (idtype_t __idtype, __id_t __id, siginfo_t *__infop,
     int __options);





struct rusage;






extern __pid_t wait3 (__WAIT_STATUS __stat_loc, int __options,
        struct rusage * __usage) __attribute__ ((__nothrow__));




extern __pid_t wait4 (__pid_t __pid, __WAIT_STATUS __stat_loc, int __options,
        struct rusage *__usage) __attribute__ ((__nothrow__));




# 347 "system.h" 2
# 377 "system.h"
# 1 "/usr/include/sys/mman.h" 1 3 4
# 26 "/usr/include/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 27 "/usr/include/sys/mman.h" 2 3 4
# 42 "/usr/include/sys/mman.h" 3 4
# 1 "/usr/include/bits/mman.h" 1 3 4
# 43 "/usr/include/sys/mman.h" 2 3 4





# 62 "/usr/include/sys/mman.h" 3 4
extern void * mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off64_t __offset) __asm__ ("" "mmap64") __attribute__ ((__nothrow__));
# 71 "/usr/include/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) __attribute__ ((__nothrow__));




extern int munmap (void *__addr, size_t __len) __attribute__ ((__nothrow__));




extern int mprotect (void *__addr, size_t __len, int __prot) __attribute__ ((__nothrow__));







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__));



extern int posix_madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__));




extern int mlock (__const void *__addr, size_t __len) __attribute__ ((__nothrow__));


extern int munlock (__const void *__addr, size_t __len) __attribute__ ((__nothrow__));




extern int mlockall (int __flags) __attribute__ ((__nothrow__));



extern int munlockall (void) __attribute__ ((__nothrow__));







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     __attribute__ ((__nothrow__));
# 134 "/usr/include/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) __attribute__ ((__nothrow__));



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) __attribute__ ((__nothrow__));




extern int shm_open (__const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (__const char *__name);


# 378 "system.h" 2
# 393 "system.h"
# 1 "/usr/include/sys/times.h" 1 3 4
# 32 "/usr/include/sys/times.h" 3 4



struct tms
  {
    clock_t tms_utime;
    clock_t tms_stime;

    clock_t tms_cutime;
    clock_t tms_cstime;
  };






extern clock_t times (struct tms *__buffer) __attribute__ ((__nothrow__));


# 394 "system.h" 2
# 426 "system.h"
extern int getopt (int, char * const *, const char *);
# 450 "system.h"
# 1 "/usr/include/malloc.h" 1 3 4
# 25 "/usr/include/malloc.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 26 "/usr/include/malloc.h" 2 3 4
# 48 "/usr/include/malloc.h" 3 4



extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;


extern void *calloc (size_t __nmemb, size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__warn_unused_result__));


extern void free (void *__ptr) __attribute__ ((__nothrow__));


extern void cfree (void *__ptr) __attribute__ ((__nothrow__));


extern void *memalign (size_t __alignment, size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__)) ;


extern void *valloc (size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__)) ;



extern void * pvalloc (size_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__)) ;



extern void *(*__morecore) (ptrdiff_t __size);


extern void *__default_morecore (ptrdiff_t __size) __attribute__ ((__nothrow__))
       __attribute__ ((__malloc__));



struct mallinfo {
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
};


extern struct mallinfo mallinfo (void) __attribute__ ((__nothrow__));
# 135 "/usr/include/malloc.h" 3 4
extern int mallopt (int __param, int __val) __attribute__ ((__nothrow__));



extern int malloc_trim (size_t __pad) __attribute__ ((__nothrow__));



extern size_t malloc_usable_size (void *__ptr) __attribute__ ((__nothrow__));


extern void malloc_stats (void) __attribute__ ((__nothrow__));


extern int malloc_info (int __options, FILE *__fp);


extern void *malloc_get_state (void) __attribute__ ((__nothrow__));



extern int malloc_set_state (void *__ptr) __attribute__ ((__nothrow__));




extern void (*__malloc_initialize_hook) (void);

extern void (*__free_hook) (void *__ptr, __const void *);

extern void *(*__malloc_hook) (size_t __size, __const void *);

extern void *(*__realloc_hook) (void *__ptr, size_t __size, __const void *);

extern void *(*__memalign_hook) (size_t __alignment, size_t __size, __const void *);


extern void (*__after_morecore_hook) (void);


extern void __malloc_check_init (void) __attribute__ ((__nothrow__));



# 451 "system.h" 2
# 474 "system.h"
# 1 "/usr/include/stdint.h" 1 3 4
# 27 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 49 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 129 "/usr/include/stdint.h" 3 4
typedef unsigned int uintptr_t;
# 138 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 475 "system.h" 2



# 1 "/usr/include/inttypes.h" 1 3 4
# 35 "/usr/include/inttypes.h" 3 4
typedef int __gwchar_t;
# 274 "/usr/include/inttypes.h" 3 4

# 288 "/usr/include/inttypes.h" 3 4
typedef struct
  {
    long long int quot;
    long long int rem;
  } imaxdiv_t;





extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern intmax_t strtoimax (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__));


extern uintmax_t strtoumax (__const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__));


extern intmax_t wcstoimax (__const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__));


extern uintmax_t wcstoumax (__const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__));
# 442 "/usr/include/inttypes.h" 3 4

# 479 "system.h" 2
# 626 "system.h"
# 1 "/usr/include/dlfcn.h" 1 3 4
# 25 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 26 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/bits/dlfcn.h" 1 3 4
# 58 "/usr/include/bits/dlfcn.h" 3 4



extern void _dl_mcount_wrapper_check (void *__selfpc) __attribute__ ((__nothrow__));


# 29 "/usr/include/dlfcn.h" 2 3 4
# 45 "/usr/include/dlfcn.h" 3 4
typedef long int Lmid_t;











extern void *dlopen (__const char *__file, int __mode) __attribute__ ((__nothrow__));



extern int dlclose (void *__handle) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      __const char *__restrict __name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern void *dlmopen (Lmid_t __nsid, __const char *__file, int __mode) __attribute__ ((__nothrow__));



extern void *dlvsym (void *__restrict __handle,
       __const char *__restrict __name,
       __const char *__restrict __version)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));





extern char *dlerror (void) __attribute__ ((__nothrow__));





typedef struct
{
  __const char *dli_fname;
  void *dli_fbase;
  __const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (__const void *__address, Dl_info *__info)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int dladdr1 (__const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




enum
  {

    RTLD_DL_SYMENT = 1,


    RTLD_DL_LINKMAP = 2
  };







extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));


enum
  {

    RTLD_DI_LMID = 1,



    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,






    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,



    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,




    RTLD_DI_TLS_MODID = 9,





    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10
  };




typedef struct
{
  char *dls_name;
  unsigned int dls_flags;
} Dl_serpath;



typedef struct
{
  size_t dls_size;
  unsigned int dls_cnt;
  Dl_serpath dls_serpath[1];
} Dl_serinfo;




# 627 "system.h" 2
# 659 "system.h"
extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;
# 944 "system.h"
static inline char *
helper_const_non_const_cast (const char *p)
{
  union {
    const char *const_c;
    char *c;
  } val;
  val.const_c = p;
  return val.c;
}
# 35 "gcc.c" 2
# 1 "coretypes.h" 1
# 47 "coretypes.h"
struct bitmap_head_def;
typedef struct bitmap_head_def *bitmap;
typedef const struct bitmap_head_def *const_bitmap;
struct simple_bitmap_def;
typedef struct simple_bitmap_def *sbitmap;
typedef const struct simple_bitmap_def *const_sbitmap;
struct rtx_def;
typedef struct rtx_def *rtx;
typedef const struct rtx_def *const_rtx;
struct rtvec_def;
typedef struct rtvec_def *rtvec;
typedef const struct rtvec_def *const_rtvec;
union tree_node;
typedef union tree_node *tree;
union gimple_statement_d;
typedef union gimple_statement_d *gimple;
typedef const union tree_node *const_tree;
typedef const union gimple_statement_d *const_gimple;
union section;
typedef union section section;
struct gcc_options;
struct cl_target_option;
struct cl_optimization;
struct cl_option;
struct cl_decoded_option;
struct cl_option_handlers;
struct diagnostic_context;
typedef struct diagnostic_context diagnostic_context;
struct gimple_seq_d;
typedef struct gimple_seq_d *gimple_seq;
typedef const struct gimple_seq_d *const_gimple_seq;


typedef unsigned char addr_space_t;






enum ir_type {
  IR_GIMPLE,
  IR_RTL_CFGRTL,
  IR_RTL_CFGLAYOUT
};






struct cpp_reader;
struct cpp_token;




enum tls_model {
  TLS_MODEL_NONE,
  TLS_MODEL_EMULATED,
  TLS_MODEL_REAL,
  TLS_MODEL_GLOBAL_DYNAMIC = TLS_MODEL_REAL,
  TLS_MODEL_LOCAL_DYNAMIC,
  TLS_MODEL_INITIAL_EXEC,
  TLS_MODEL_LOCAL_EXEC
};



enum unwind_info_type
{
  UI_NONE,
  UI_SJLJ,
  UI_DWARF2,
  UI_TARGET
};


enum node_frequency {


  NODE_FREQUENCY_UNLIKELY_EXECUTED,


  NODE_FREQUENCY_EXECUTED_ONCE,

  NODE_FREQUENCY_NORMAL,


  NODE_FREQUENCY_HOT
};




enum var_init_status
{
  VAR_INIT_STATUS_UNKNOWN,
  VAR_INIT_STATUS_UNINITIALIZED,
  VAR_INIT_STATUS_INITIALIZED
};


struct edge_def;
typedef struct edge_def *edge;
typedef const struct edge_def *const_edge;
struct basic_block_def;
typedef struct basic_block_def *basic_block;
typedef const struct basic_block_def *const_basic_block;
# 168 "coretypes.h"
typedef int reg_class_t;
# 36 "gcc.c" 2

# 1 "tm.h" 1
# 40 "tm.h"
# 1 "defaults.h" 1
# 41 "tm.h" 2
# 38 "gcc.c" 2

# 1 "/usr/include/obstack.h" 1 3 4
# 144 "/usr/include/obstack.h" 3 4
struct _obstack_chunk
{
  char *limit;
  struct _obstack_chunk *prev;
  char contents[4];
};

struct obstack
{
  long chunk_size;
  struct _obstack_chunk *chunk;
  char *object_base;
  char *next_free;
  char *chunk_limit;
  union
  {
    int tempint;
    void *tempptr;
  } temp;
  int alignment_mask;



  struct _obstack_chunk *(*chunkfun) (void *, long);
  void (*freefun) (void *, struct _obstack_chunk *);
  void *extra_arg;
  unsigned use_extra_arg:1;
  unsigned maybe_empty_object:1;



  unsigned alloc_failed:1;


};



extern void _obstack_newchunk (struct obstack *, int);
extern int _obstack_begin (struct obstack *, int, int,
       void *(*) (long), void (*) (void *));
extern int _obstack_begin_1 (struct obstack *, int, int,
        void *(*) (void *, long),
        void (*) (void *, void *), void *);
extern int _obstack_memory_used (struct obstack *);

void obstack_free (struct obstack *__obstack, void *__block);






extern void (*obstack_alloc_failed_handler) (void);


extern int obstack_exit_failure;
# 40 "gcc.c" 2
# 1 "intl.h" 1
# 23 "intl.h"
# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4


# 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, __const char *__locale) __attribute__ ((__nothrow__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__));


# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) __attribute__ ((__nothrow__));
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) __attribute__ ((__nothrow__));



extern void freelocale (__locale_t __dataset) __attribute__ ((__nothrow__));






extern __locale_t uselocale (__locale_t __dataset) __attribute__ ((__nothrow__));








# 24 "intl.h" 2
# 46 "intl.h"
extern const char *fake_ngettext(const char *singular,const char *plural,
                                 unsigned long int n);
# 63 "intl.h"
extern char *get_spaces (const char *);

extern const char *open_quote;
extern const char *close_quote;
extern const char *locale_encoding;
extern unsigned char locale_utf8;
# 41 "gcc.c" 2
# 1 "prefix.h" 1
# 33 "prefix.h"
extern char *update_path (const char *path, const char *key);
extern void set_std_prefix (const char *, int);
# 42 "gcc.c" 2
# 1 "gcc.h" 1
# 24 "gcc.h"
# 1 "version.h" 1


extern const char version_string[];
extern const char pkgversion_string[];
extern const char bug_report_url[];
# 25 "gcc.h" 2
# 1 "diagnostic-core.h" 1
# 27 "diagnostic-core.h"
# 1 "input.h" 1
# 27 "input.h"
extern struct line_maps *line_table;
# 37 "input.h"
extern char builtins_location_check[(((source_location) 1)
         < RESERVED_LOCATION_COUNT) ? 1 : -1];

typedef struct
{

  const char *file;


  int line;

  int column;


  unsigned char sysp;
} expanded_location;

extern expanded_location expand_location (source_location);



typedef source_location location_t;

extern location_t input_location;
# 28 "diagnostic-core.h" 2



typedef enum
{

# 1 "diagnostic.def" 1
# 25 "diagnostic.def"
DK_UNSPECIFIED,




DK_IGNORED,


DK_FATAL,
DK_ICE,
DK_ERROR,
DK_SORRY,
DK_WARNING,
DK_ANACHRONISM,
DK_NOTE,
DK_DEBUG,


DK_PEDWARN,
DK_PERMERROR,
# 35 "diagnostic-core.h" 2

  DK_LAST_DIAGNOSTIC_KIND,


  DK_POP
} diagnostic_t;

extern const char *progname;

extern const char *trim_filename (const char *);
# 59 "diagnostic-core.h"
extern void internal_error (const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 1, 2))) ATTRIBUTE_NONNULL(1)
     ATTRIBUTE_NORETURN;

extern unsigned char warning (int, const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 2, 3))) ATTRIBUTE_NONNULL(2);
extern unsigned char warning_at (location_t, int, const char *, ...)
    __attribute__ ((__format__ (__gcc_tdiag__, 3, 4))) ATTRIBUTE_NONNULL(3);
extern void error (const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 1, 2))) ATTRIBUTE_NONNULL(1);
extern void error_n (location_t, int, const char *, const char *, ...)
    __attribute__ ((__format__ (__gcc_tdiag__, 3, 5))) ATTRIBUTE_NONNULL(3) __attribute__ ((__format__ (__gcc_tdiag__, 4, 5))) ATTRIBUTE_NONNULL(4);
extern void error_at (location_t, const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 2, 3))) ATTRIBUTE_NONNULL(2);
extern void fatal_error (const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 1, 2))) ATTRIBUTE_NONNULL(1)
     ATTRIBUTE_NORETURN;

extern unsigned char pedwarn (location_t, int, const char *, ...)
     __attribute__ ((__format__ (__gcc_tdiag__, 3, 4))) ATTRIBUTE_NONNULL(3);
extern unsigned char permerror (location_t, const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 2, 3))) ATTRIBUTE_NONNULL(2);
extern void sorry (const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 1, 2))) ATTRIBUTE_NONNULL(1);
extern void inform (location_t, const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 2, 3))) ATTRIBUTE_NONNULL(2);
extern void inform_n (location_t, int, const char *, const char *, ...)
    __attribute__ ((__format__ (__gcc_tdiag__, 3, 5))) ATTRIBUTE_NONNULL(3) __attribute__ ((__format__ (__gcc_tdiag__, 4, 5))) ATTRIBUTE_NONNULL(4);
extern void verbatim (const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 1, 2))) ATTRIBUTE_NONNULL(1);
extern unsigned char emit_diagnostic (diagnostic_t, location_t, int,
        const char *, ...) __attribute__ ((__format__ (__gcc_tdiag__, 4, 5))) ATTRIBUTE_NONNULL(4);
extern unsigned char seen_error (void);




extern void fnotice (FILE *, const char *, ...)
     ATTRIBUTE_PRINTF_2;
# 26 "gcc.h" 2



struct spec_function
{
  const char *name;
  const char *(*func) (int, const char **);
};


extern int do_spec (const char *);
extern void record_temp_file (const char *, int, int);
extern void pfatal_with_name (const char *) ATTRIBUTE_NORETURN;
extern void set_input (const char *);




extern void lang_specific_driver (struct cl_decoded_option **,
      unsigned int *, int *);


extern int lang_specific_pre_link (void);

extern int n_infiles;


extern int lang_specific_extra_outfiles;



extern const char **outfiles;
# 43 "gcc.c" 2
# 1 "diagnostic.h" 1
# 25 "diagnostic.h"
# 1 "pretty-print.h" 1
# 33 "pretty-print.h"
typedef struct
{
  const char *format_spec;
  va_list *args_ptr;
  int err_no;
  location_t *locus;
  void **x_data;
} text_info;






typedef enum
{
  DIAGNOSTICS_SHOW_PREFIX_ONCE = 0x0,
  DIAGNOSTICS_SHOW_PREFIX_NEVER = 0x1,
  DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE = 0x2
} diagnostic_prefixing_rule_t;






struct chunk_info
{

  struct chunk_info *prev;







  const char *args[30 * 2];
};



typedef struct
{

  struct obstack formatted_obstack;



  struct obstack chunk_obstack;



  struct obstack *obstack;


  struct chunk_info *cur_chunk_array;


  FILE *stream;


  int line_length;



  char digit_buffer[128];
} output_buffer;


typedef unsigned int pp_flags;

typedef enum
{
  pp_none, pp_before, pp_after
} pp_padding;



typedef struct
{

  diagnostic_prefixing_rule_t rule;



  int line_cutoff;
} pp_wrapping_mode_t;
# 135 "pretty-print.h"
typedef struct pretty_print_info pretty_printer;
typedef unsigned char (*printer_fn) (pretty_printer *, text_info *, const char *,
       int, unsigned char, unsigned char, unsigned char);
# 159 "pretty-print.h"
struct pretty_print_info
{

  output_buffer *buffer;


  const char *prefix;


  pp_padding padding;



  int maximum_length;


  int indent_skip;


  pp_wrapping_mode_t wrapping;
# 188 "pretty-print.h"
  printer_fn format_decoder;


  unsigned char emitted_prefix;


  unsigned char need_newline;



  unsigned char translate_identifiers;
};
# 297 "pretty-print.h"
extern void pp_construct (pretty_printer *, const char *, int);
extern void pp_base_set_line_maximum_length (pretty_printer *, int);
extern void pp_base_set_prefix (pretty_printer *, const char *);
extern void pp_base_destroy_prefix (pretty_printer *);
extern int pp_base_remaining_character_count_for_line (pretty_printer *);
extern void pp_base_clear_output_area (pretty_printer *);
extern const char *pp_base_formatted_text (pretty_printer *);
extern const char *pp_base_last_position_in_text (const pretty_printer *);
extern void pp_base_emit_prefix (pretty_printer *);
extern void pp_base_append_text (pretty_printer *, const char *, const char *);
# 323 "pretty-print.h"
extern void pp_printf (pretty_printer *, const char *, ...)
     ATTRIBUTE_NONNULL(2);

extern void pp_verbatim (pretty_printer *, const char *, ...)
     ATTRIBUTE_NONNULL(2);
extern void pp_base_flush (pretty_printer *);
extern void pp_base_format (pretty_printer *, text_info *);
extern void pp_base_output_formatted_text (pretty_printer *);
extern void pp_base_format_verbatim (pretty_printer *, text_info *);

extern void pp_base_indent (pretty_printer *);
extern void pp_base_newline (pretty_printer *);
extern void pp_base_character (pretty_printer *, int);
extern void pp_base_string (pretty_printer *, const char *);
extern void pp_write_text_to_stream (pretty_printer *pp);
extern void pp_base_maybe_space (pretty_printer *);


static inline pp_wrapping_mode_t
pp_set_verbatim_wrapping_ (pretty_printer *pp)
{
  pp_wrapping_mode_t oldmode = (pp)->wrapping;
  (pp)->wrapping.line_cutoff = 0;
  (pp)->wrapping.rule = DIAGNOSTICS_SHOW_PREFIX_NEVER;
  return oldmode;
}


extern const char *identifier_to_locale (const char *);
extern void *(*identifier_to_locale_alloc) (size_t);
extern void (*identifier_to_locale_free) (void *);
# 26 "diagnostic.h" 2





typedef struct diagnostic_info
{
  text_info message;
  location_t location;
  unsigned int override_column;

  void *x_data;

  diagnostic_t kind;

  int option_index;
} diagnostic_info;




typedef struct diagnostic_classification_change_t
{
  location_t location;
  int option;
  diagnostic_t kind;
} diagnostic_classification_change_t;


typedef void (*diagnostic_starter_fn) (diagnostic_context *,
           diagnostic_info *);
typedef diagnostic_starter_fn diagnostic_finalizer_fn;



struct diagnostic_context
{

  pretty_printer *printer;


  int diagnostic_count[DK_LAST_DIAGNOSTIC_KIND];



  unsigned char some_warnings_are_errors;


  unsigned char warning_as_error_requested;



  int n_opts;







  diagnostic_t *classify_diagnostic;






  diagnostic_classification_change_t *classification_history;


  int n_classification_history;


  int *push_list;
  int n_push;



  unsigned char show_option_requested;


  unsigned char abort_on_error;


  unsigned char show_column;


  unsigned char pedantic_errors;


  unsigned char permissive;



  int opt_permissive;


  unsigned char fatal_errors;


  unsigned char dc_inhibit_warnings;


  unsigned char dc_warn_system_headers;


  unsigned int max_errors;
# 141 "diagnostic.h"
  diagnostic_starter_fn begin_diagnostic;


  diagnostic_finalizer_fn end_diagnostic;


  void (*internal_error) (diagnostic_context *, const char *, va_list *);



  int (*option_enabled) (int, void *);



  void *option_state;







  char *(*option_name) (diagnostic_context *, int, diagnostic_t, diagnostic_t);


  void *x_data;



  const struct line_map *last_module;

  int lock;

  unsigned char inhibit_notes_p;
};

static inline void
diagnostic_inhibit_notes (diagnostic_context * context)
{
  context->inhibit_notes_p = 1;
}
# 224 "diagnostic.h"
extern diagnostic_context *global_dc;
# 254 "diagnostic.h"
extern void diagnostic_initialize (diagnostic_context *, int);
extern void diagnostic_finish (diagnostic_context *);
extern void diagnostic_report_current_module (diagnostic_context *);


extern diagnostic_t diagnostic_classify_diagnostic (diagnostic_context *,
          int ,
          diagnostic_t ,
          location_t);
extern void diagnostic_push_diagnostics (diagnostic_context *, location_t);
extern void diagnostic_pop_diagnostics (diagnostic_context *, location_t);
extern unsigned char diagnostic_report_diagnostic (diagnostic_context *,
       diagnostic_info *);

extern void diagnostic_set_info (diagnostic_info *, const char *, va_list *,
     location_t, diagnostic_t) __attribute__ ((__format__ (__gcc_tdiag__, 2, 0))) ATTRIBUTE_NONNULL(2);
extern void diagnostic_set_info_translated (diagnostic_info *, const char *,
         va_list *, location_t,
         diagnostic_t)
     __attribute__ ((__format__ (__gcc_tdiag__, 2, 0))) ATTRIBUTE_NONNULL(2);

extern char *diagnostic_build_prefix (diagnostic_context *, diagnostic_info *);
void default_diagnostic_starter (diagnostic_context *, diagnostic_info *);
void default_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);


extern char *file_name_as_prefix (const char *);
# 44 "gcc.c" 2
# 1 "flags.h" 1
# 26 "flags.h"
# 1 "flag-types.h" 1
# 25 "flag-types.h"
enum debug_info_type
{
  NO_DEBUG,
  DBX_DEBUG,
  SDB_DEBUG,
  DWARF2_DEBUG,
  XCOFF_DEBUG,
  VMS_DEBUG,
  VMS_AND_DWARF2_DEBUG

};

enum debug_info_levels
{
  DINFO_LEVEL_NONE,
  DINFO_LEVEL_TERSE,
  DINFO_LEVEL_NORMAL,
  DINFO_LEVEL_VERBOSE
};
# 53 "flag-types.h"
enum debug_info_usage
{
  DINFO_USAGE_DFN,
  DINFO_USAGE_DIR_USE,
  DINFO_USAGE_IND_USE,
  DINFO_USAGE_NUM_ENUMS
};
# 86 "flag-types.h"
enum debug_struct_file
{
  DINFO_STRUCT_FILE_NONE,
  DINFO_STRUCT_FILE_BASE,

  DINFO_STRUCT_FILE_SYS,

  DINFO_STRUCT_FILE_ANY
};





enum symbol_visibility
{
  VISIBILITY_DEFAULT,
  VISIBILITY_PROTECTED,
  VISIBILITY_HIDDEN,
  VISIBILITY_INTERNAL
};



enum ira_algorithm
{
  IRA_ALGORITHM_CB,
  IRA_ALGORITHM_PRIORITY
};


enum ira_region
{
  IRA_REGION_ONE,
  IRA_REGION_ALL,
  IRA_REGION_MIXED
};


enum excess_precision
{
  EXCESS_PRECISION_DEFAULT,
  EXCESS_PRECISION_FAST,
  EXCESS_PRECISION_STANDARD
};


enum graph_dump_types
{
  no_graph = 0,
  vcg
};


enum stack_check_type
{

  NO_STACK_CHECK = 0,



  GENERIC_STACK_CHECK,




  STATIC_BUILTIN_STACK_CHECK,



  FULL_BUILTIN_STACK_CHECK
};




enum warn_strict_overflow_code
{



  WARN_STRICT_OVERFLOW_ALL = 1,




  WARN_STRICT_OVERFLOW_CONDITIONAL = 2,


  WARN_STRICT_OVERFLOW_COMPARISON = 3,


  WARN_STRICT_OVERFLOW_MISC = 4,


  WARN_STRICT_OVERFLOW_MAGNITUDE = 5
};


enum fp_contract_mode {
  FP_CONTRACT_OFF = 0,
  FP_CONTRACT_ON = 1,
  FP_CONTRACT_FAST = 2
};


enum vect_verbosity_levels {
  REPORT_NONE,
  REPORT_VECTORIZED_LOCATIONS,
  REPORT_UNVECTORIZED_LOCATIONS,
  REPORT_COST,
  REPORT_ALIGNMENT,
  REPORT_DR_DETAILS,
  REPORT_BAD_FORM_LOOPS,
  REPORT_OUTER_LOOPS,
  REPORT_SLP,
  REPORT_DETAILS,

  MAX_VERBOSITY_LEVEL
};
# 27 "flags.h" 2
# 1 "options.h" 1







# 1 "config/i386/i386-opts.h" 1
# 31 "config/i386/i386-opts.h"
enum stringop_alg
{
   no_stringop,
   libcall,
   rep_prefix_1_byte,
   rep_prefix_4_byte,
   rep_prefix_8_byte,
   loop_1_byte,
   loop,
   unrolled_loop
};


enum calling_abi
{
  SYSV_ABI = 0,
  MS_ABI = 1
};

enum fpmath_unit
{
  FPMATH_387 = 1,
  FPMATH_SSE = 2
};

enum tls_dialect
{
  TLS_DIALECT_GNU,
  TLS_DIALECT_GNU2,
  TLS_DIALECT_SUN
};

enum cmodel {
  CM_32,
  CM_SMALL,
  CM_KERNEL,
  CM_MEDIUM,
  CM_LARGE,
  CM_SMALL_PIC,
  CM_MEDIUM_PIC,
  CM_LARGE_PIC
};

enum asm_dialect {
  ASM_ATT,
  ASM_INTEL
};

enum ix86_veclibabi {
  ix86_veclibabi_type_none,
  ix86_veclibabi_type_svml,
  ix86_veclibabi_type_acml
};
# 9 "options.h" 2




struct gcc_options



{




  long long x_frame_larger_than_size;





  long long x_ix86_isa_flags;





  long long x_ix86_isa_flags_explicit;





  long long x_larger_than_size;





  unsigned char x_exit_after_options;





  unsigned char x_flag_dump_all_passed;





  unsigned char x_flag_opts_finished;





  unsigned char x_flag_stack_usage_info;





  unsigned char x_flag_warn_unused_result;





  unsigned char x_in_lto_p;





  unsigned char x_use_gnu_debug_info_extensions;





  unsigned char x_warn_frame_larger_than;





  unsigned char x_warn_larger_than;





  char * x_help_enum_printed;





  char * x_help_printed;





  const char * x_main_input_basename;





  const char * x_main_input_filename;





  enum debug_info_levels x_debug_info_level;





  enum debug_info_type x_write_symbols;





  enum debug_struct_file x_debug_struct_generic[DINFO_USAGE_NUM_ENUMS];





  enum debug_struct_file x_debug_struct_ordinary[DINFO_USAGE_NUM_ENUMS];





  enum graph_dump_types x_graph_dump_format;





  enum stack_check_type x_flag_stack_check;





  enum vect_verbosity_levels x_user_vect_verbosity_level;





  int * x_param_values;





  int x_flag_complex_method;





  int x_flag_debug_asm;





  int x_flag_dump_rtl_in_asm;





  int x_flag_evaluation_order;





  int x_flag_gen_aux_info;





  int x_flag_generate_lto;





  int x_flag_print_asm_name;





  int x_flag_shlib;





  int x_main_input_baselength;





  int x_optimize;





  int x_optimize_fast;





  int x_optimize_size;





  int x_rtl_dump_and_exit;





  int x_target_flags;





  unsigned int x_help_columns;





  unsigned int x_initial_max_fld_align;





  void * x_flag_instrument_functions_exclude_files;





  void * x_flag_instrument_functions_exclude_functions;





  int x_help_flag;





  int x_flag_preprocess_only;





  int x_warn_abi;





  int x_warn_address;





  int x_warn_aggregate_return;





  int x_warn_array_bounds;





  int x_warn_assign_intercept;





  int x_warn_attributes;





  int x_warn_bad_function_cast;





  int x_warn_cxx_compat;





  int x_warn_cxx0x_compat;





  int x_warn_cast_align;





  int x_warn_cast_qual;





  int x_warn_char_subscripts;





  int x_warn_clobbered;





  int x_warn_conversion;





  int x_warn_conversion_null;





  int x_warn_coverage_mismatch;





  int x_warn_cpp;





  int x_warn_ctor_dtor_privacy;





  int x_warn_declaration_after_statement;





  int x_warn_delnonvdtor;





  int x_warn_deprecated;





  int x_warn_deprecated_decl;





  int x_warn_disabled_optimization;





  int x_warn_div_by_zero;





  int x_warn_double_promotion;





  int x_warn_ecpp;





  int x_warn_empty_body;





  int x_warn_enum_compare;





  int x_warnings_are_errors;





  int x_extra_warnings;





  int x_flag_extraneous_semicolon;





  int x_flag_fatal_errors;





  int x_warn_float_equal;





  int x_warn_format_contains_nul;





  int x_warn_format_extra_args;





  int x_warn_format_nonliteral;





  int x_warn_format_security;





  int x_warn_format_y2k;





  int x_warn_format_zero_length;





  int x_warn_free_nonheap_object;





  int x_warn_ignored_qualifiers;





  int x_warn_implicit;





  int x_warn_implicit_function_declaration;





  int x_warn_implicit_int;





  int x_warn_init_self;





  int x_warn_inline;





  int x_warn_int_to_pointer_cast;





  int x_warn_invalid_offsetof;





  int x_warn_jump_misses_init;





  int x_warn_logical_op;





  int x_warn_long_long;





  int x_warn_main;





  int x_warn_maybe_uninitialized;





  int x_warn_missing_braces;





  int x_warn_missing_declarations;





  int x_warn_missing_field_initializers;





  int x_warn_missing_format_attribute;





  int x_warn_missing_noreturn;





  int x_warn_missing_parameter_type;





  int x_warn_missing_prototypes;





  int x_warn_mudflap;





  int x_warn_narrowing;





  int x_warn_nested_externs;





  int x_warn_noexcept;





  int x_warn_nontemplate_friend;





  int x_warn_nonvdtor;





  int x_warn_nonnull;





  int x_warn_old_style_cast;





  int x_warn_old_style_declaration;





  int x_warn_old_style_definition;





  int x_flag_newer;





  int x_warn_overflow;





  int x_warn_overlength_strings;





  int x_warn_overloaded_virtual;





  int x_warn_override_init;





  int x_warn_packed;





  int x_warn_packed_bitfield_compat;





  int x_warn_padded;





  int x_warn_parentheses;





  int x_warn_pmf2ptr;





  int x_warn_pointer_arith;





  int x_warn_pointer_sign;





  int x_warn_pointer_to_int_cast;





  int x_warn_pragmas;





  int x_warn_property_assign_default;





  int x_warn_protocol;





  int x_warn_psabi;





  int x_warn_redundant_decls;





  int x_flag_redundant;





  int x_warn_reorder;





  int x_warn_return_type;





  int x_warn_selector;





  int x_warn_sequence_point;





  int x_warn_shadow;





  int x_warn_sign_compare;





  int x_warn_sign_conversion;





  int x_warn_sign_promo;





  int x_warn_stack_protect;





  int x_warn_stack_usage;





  int x_warn_strict_aliasing;





  int x_warn_strict_null_sentinel;





  int x_warn_strict_overflow;





  int x_warn_strict_prototypes;





  int x_warn_strict_selector_match;





  int x_warn_suggest_attribute_const;





  int x_warn_suggest_attribute_noreturn;





  int x_warn_suggest_attribute_pure;





  int x_warn_switch;





  int x_warn_switch_default;





  int x_warn_switch_enum;





  int x_warn_sync_nand;





  int x_warn_synth;





  int x_warn_system_headers;





  int x_warn_traditional;





  int x_warn_traditional_conversion;





  int x_warn_trampolines;





  int x_warn_type_limits;





  int x_warn_undeclared_selector;





  int x_warn_uninitialized;





  int x_warn_unsafe_loop_optimizations;





  int x_warn_unsuffixed_float_constants;





  int x_warn_unused;





  int x_warn_unused_but_set_parameter;





  int x_warn_unused_but_set_variable;





  int x_warn_unused_function;





  int x_warn_unused_label;





  int x_warn_unused_local_typedefs;





  int x_warn_unused_parameter;





  int x_warn_unused_result;





  int x_warn_unused_value;





  int x_warn_unused_variable;





  int x_warn_vla;





  int x_warn_volatile_register_var;





  int x_warn_write_strings;





  const char *x_aux_info_file_name;





  const char *x_aux_base_name;





  const char *x_dump_base_name;





  const char *x_dump_dir_name;





  int x_flag_pic;





  int x_flag_pie;





  int x_flag_abi_version;





  int x_flag_access_control;





  int x_align_functions;





  int x_align_jumps;





  int x_align_labels;





  int x_align_loops;





  int x_flag_no_asm;





  int x_flag_assert;





  int x_flag_associative_math;





  int x_flag_asynchronous_unwind_tables;





  int x_flag_auto_inc_dec;





  int x_flag_bootstrap_classes;





  int x_flag_bounds_check;





  int x_flag_branch_on_count_reg;





  int x_flag_branch_probabilities;





  int x_flag_branch_target_load_optimize;





  int x_flag_branch_target_load_optimize2;





  int x_flag_btr_bb_exclusive;





  int x_flag_building_libgcc;





  int x_flag_no_builtin;





  void *x_common_deferred_options;





  int x_flag_caller_saves;





  int x_flag_check_data_deps;





  int x_flag_check_new;





  int x_flag_check_references;





  int x_flag_combine_stack_adjustments;





  int x_flag_no_common;





  int x_flag_compare_debug;





  const char *x_flag_compare_debug_opt;





  int x_flag_compare_elim_after_reload;





  int x_flag_conserve_space;





  int x_flag_conserve_stack;





  int x_max_constexpr_depth;





  int x_flag_cprop_registers;





  int x_flag_crossjumping;





  int x_flag_cse_follow_jumps;





  int x_flag_cx_fortran_rules;





  int x_flag_cx_limited_range;





  int x_flag_data_sections;





  int x_flag_dce;





  int x_flag_debug_types_section;





  int x_flag_deduce_init_list;





  int x_flag_defer_pop;





  int x_flag_delayed_branch;





  int x_flag_delete_null_pointer_checks;





  int x_flag_devirtualize;





  int x_flag_diagnostics_show_option;





  int x_flag_dse;





  const char *x_flag_dump_final_insns;





  const char *x_flag_dump_go_spec;





  int x_flag_dump_noaddr;





  int x_flag_dump_passes;





  int x_flag_dump_unnumbered;





  int x_flag_dump_unnumbered_links;





  int x_flag_dwarf2_cfi_asm;





  int x_flag_early_inlining;





  int x_flag_elide_constructors;





  int x_flag_eliminate_dwarf2_dups;





  int x_flag_debug_only_used_symbols;





  int x_flag_eliminate_unused_debug_types;





  int x_flag_emit_class_debug_always;





  int x_flag_emit_class_files;





  int x_flag_enforce_eh_specs;





  int x_flag_exceptions;





  enum excess_precision x_flag_excess_precision_cmdline;





  int x_flag_expensive_optimizations;





  int x_flag_filelist_file;





  int x_flag_finite_math_only;





  int x_flag_float_store;





  int x_flag_new_for_scope;





  int x_flag_force_classes_archive_check;





  int x_flag_forward_propagate;





  enum fp_contract_mode x_flag_fp_contract_mode;





  int x_flag_friend_injection;





  int x_flag_no_function_cse;





  int x_flag_function_sections;





  int x_flag_gcse;





  int x_flag_gcse_after_reload;





  int x_flag_gcse_las;





  int x_flag_gcse_lm;





  int x_flag_gcse_sm;





  int x_flag_no_gnu_keywords;





  int x_flag_gnu89_inline;





  int x_flag_graphite;





  int x_flag_graphite_identity;





  int x_flag_guess_branch_prob;





  int x_flag_hash_synchronization;





  int x_flag_no_ident;





  int x_flag_if_conversion;





  int x_flag_if_conversion2;





  int x_flag_implement_inlines;





  int x_flag_implicit_inline_templates;





  int x_flag_implicit_templates;





  int x_flag_indirect_classes;





  int x_flag_indirect_dispatch;





  int x_flag_indirect_inlining;





  int x_flag_inhibit_size_directive;





  int x_flag_no_inline;





  int x_flag_inline_functions;





  int x_flag_inline_functions_called_once;





  int x_flag_inline_small_functions;





  int x_flag_instrument_function_entry_exit;





  int x_flag_ipa_cp;





  int x_flag_ipa_cp_clone;





  int x_flag_ipa_matrix_reorg;





  int x_flag_ipa_profile;





  int x_flag_ipa_pta;





  int x_flag_ipa_pure_const;





  int x_flag_ipa_reference;





  int x_flag_ipa_sra;





  enum ira_algorithm x_flag_ira_algorithm;





  int x_flag_ira_loop_pressure;





  enum ira_region x_flag_ira_region;





  int x_flag_ira_share_save_slots;





  int x_flag_ira_share_spill_slots;





  int x_flag_ira_verbose;





  int x_flag_ivopts;





  int x_flag_jni;





  int x_flag_jump_tables;





  int x_flag_keep_inline_dllexport;





  int x_flag_keep_inline_functions;





  int x_flag_keep_static_consts;





  int x_flag_lax_vector_conversions;





  int x_flag_leading_underscore;





  int x_flag_loop_block;





  int x_flag_loop_flatten;





  int x_flag_loop_interchange;





  int x_flag_loop_parallelize_all;





  int x_flag_loop_strip_mine;





  int x_flag_lto_compression_level;





  int x_flag_lto_partition_1to1;





  int x_flag_lto_partition_balanced;





  int x_flag_lto_partition_none;





  int x_flag_lto_report;





  const char *x_flag_lto;





  int x_flag_ltrans;





  const char *x_ltrans_output_list;





  int x_flag_errno_math;





  int x_flag_max_errors;





  int x_mem_report;





  int x_flag_merge_constants;





  int x_flag_merge_debug_strings;





  int x_flag_modulo_sched;





  int x_flag_modulo_sched_allow_regmoves;





  int x_flag_move_loop_invariants;





  int x_flag_ms_extensions;





  int x_flag_mudflap;





  int x_flag_mudflap_ignore_reads;





  int x_flag_nil_receivers;





  int x_flag_non_call_exceptions;





  int x_flag_no_nonansi_builtin;





  int x_flag_nothrow_opt;





  int x_flag_objc_abi;





  int x_flag_objc_call_cxx_cdtors;





  int x_flag_objc_direct_dispatch;





  int x_flag_objc_exceptions;





  int x_flag_objc_gc;





  int x_flag_objc_nilcheck;





  int x_flag_objc_sjlj_exceptions;





  int x_flag_objc1_only;





  int x_flag_omit_frame_pointer;





  int x_flag_openmp;





  int x_flag_regmove;





  int x_flag_optimize_sibling_calls;





  int x_flag_optimize_sci;





  int x_flag_pack_struct;





  int x_flag_partial_inlining;





  int x_flag_pcc_struct_return;





  int x_flag_peel_loops;





  int x_flag_no_peephole;





  int x_flag_peephole2;





  int x_flag_plan9_extensions;





  int x_post_ipa_mem_report;





  int x_pre_ipa_mem_report;





  int x_flag_predictive_commoning;





  int x_flag_prefetch_loop_arrays;





  int x_flag_pretty_templates;





  int x_profile_flag;





  int x_profile_arc_flag;





  int x_flag_profile_correction;





  const char *x_profile_data_prefix;





  int x_flag_profile_use;





  int x_flag_profile_values;





  int x_flag_reciprocal_math;





  int x_flag_record_gcc_switches;





  int x_flag_reduced_reflection;





  int x_flag_rename_registers;





  int x_flag_reorder_blocks;





  int x_flag_reorder_blocks_and_partition;





  int x_flag_reorder_functions;





  int x_flag_replace_objc_classes;





  int x_go_require_return_statement;





  int x_flag_rerun_cse_after_loop;





  int x_flag_resched_modulo_sched;





  int x_flag_rounding_math;





  int x_flag_rtti;





  int x_flag_sched_critical_path_heuristic;





  int x_flag_sched_dep_count_heuristic;





  int x_flag_sched_group_heuristic;





  int x_flag_schedule_interblock;





  int x_flag_sched_last_insn_heuristic;





  int x_flag_sched_pressure;





  int x_flag_sched_rank_heuristic;





  int x_flag_schedule_speculative;





  int x_flag_sched_spec_insn_heuristic;





  int x_flag_schedule_speculative_load;





  int x_flag_schedule_speculative_load_dangerous;





  int x_flag_sched_stalled_insns;





  int x_flag_sched_stalled_insns_dep;





  int x_sched_verbose_param;





  int x_flag_sched2_use_superblocks;





  int x_flag_schedule_insns;





  int x_flag_schedule_insns_after_reload;





  int x_flag_section_anchors;





  int x_flag_sel_sched_pipelining;





  int x_flag_sel_sched_pipelining_outer_loops;





  int x_flag_sel_sched_reschedule_pipelined;





  int x_flag_selective_scheduling;





  int x_flag_selective_scheduling2;





  int x_flag_short_double;





  int x_flag_short_enums;





  int x_flag_short_wchar;





  int x_flag_show_column;





  int x_flag_signaling_nans;





  int x_flag_signed_bitfields;





  int x_flag_signed_char;





  int x_flag_signed_zeros;





  int x_flag_single_precision_constant;





  int x_flag_split_ivs_in_unroller;





  int x_flag_split_stack;





  int x_flag_split_wide_types;





  int x_flag_stack_protect;





  int x_flag_stack_usage;





  int x_flag_detailed_statistics;





  int x_flag_store_check;





  int x_flag_strict_aliasing;





  int x_flag_strict_enums;





  int x_flag_strict_overflow;





  int x_flag_strict_volatile_bitfields;





  int x_flag_syntax_only;





  int x_flag_test_coverage;





  int x_flag_thread_jumps;





  int x_flag_threadsafe_statics;





  int x_time_report;





  enum tls_model x_flag_tls_default;





  int x_flag_toplevel_reorder;





  int x_flag_tracer;





  int x_flag_trapping_math;





  int x_flag_trapv;





  int x_flag_tree_bit_ccp;





  int x_flag_tree_builtin_call_dce;





  int x_flag_tree_ccp;





  int x_flag_tree_ch;





  int x_flag_tree_copy_prop;





  int x_flag_tree_copyrename;





  int x_flag_tree_cselim;





  int x_flag_tree_dce;





  int x_flag_tree_dom;





  int x_flag_tree_dse;





  int x_flag_tree_forwprop;





  int x_flag_tree_fre;





  int x_flag_tree_loop_distribute_patterns;





  int x_flag_tree_loop_distribution;





  int x_flag_tree_loop_if_convert;





  int x_flag_tree_loop_if_convert_stores;





  int x_flag_tree_loop_im;





  int x_flag_tree_loop_ivcanon;





  int x_flag_tree_loop_optimize;





  int x_flag_tree_live_range_split;





  int x_flag_tree_parallelize_loops;





  int x_flag_tree_phiprop;





  int x_flag_tree_pre;





  int x_flag_tree_pta;





  int x_flag_tree_reassoc;





  int x_flag_tree_scev_cprop;





  int x_flag_tree_sink;





  int x_flag_tree_slp_vectorize;





  int x_flag_tree_sra;





  int x_flag_tree_switch_conversion;





  int x_flag_tree_ter;





  int x_flag_tree_vect_loop_version;





  int x_flag_tree_vectorize;





  int x_flag_tree_vrp;





  int x_flag_unit_at_a_time;





  int x_flag_unroll_all_loops;





  int x_flag_unroll_loops;





  int x_flag_unsafe_loop_optimizations;





  int x_flag_unsafe_math_optimizations;





  int x_flag_unswitch_loops;





  int x_flag_unwind_tables;





  int x_flag_use_atomic_builtins;





  int x_flag_use_boehm_gc;





  int x_flag_use_cxa_atexit;





  int x_flag_use_cxa_get_exception_ptr;





  int x_flag_use_divide_subroutine;





  int x_flag_var_tracking;





  int x_flag_var_tracking_assignments;





  int x_flag_var_tracking_assignments_toggle;





  int x_flag_var_tracking_uninit;





  int x_flag_variable_expansion_in_unroller;





  int x_flag_vect_cost_model;





  int x_flag_verbose_asm;





  int x_flag_visibility_ms_compat;





  enum symbol_visibility x_default_visibility;





  int x_flag_value_profile_transformations;





  int x_flag_weak;





  int x_flag_web;





  int x_flag_whole_program;





  int x_flag_working_directory;





  int x_flag_wpa;





  int x_flag_wrapv;





  int x_flag_zee;





  int x_flag_zero_initialized_in_bss;





  int x_flag_zero_link;





  int x_dwarf_version;





  int x_flag_gen_declaration;





  int x_dwarf_record_gcc_switches;





  int x_dwarf_strict;





  int x_flag_gtoggle;





  const char *x_plugindir_string;





  enum calling_abi x_ix86_abi;





  int x_flag_android;





  const char *x_ix86_arch_string;





  enum asm_dialect x_ix86_asm_dialect;





  int x_linux_libc;





  int x_ix86_branch_cost;





  enum cmodel x_ix86_cmodel;





  int x_flag_dispatch_scheduler;





  int x_flag_fentry;





  int x_ix86_force_drap;





  enum fpmath_unit x_ix86_fpmath;





  int x_ix86_incoming_stack_boundary_arg;





  int x_ix86_section_threshold;





  int x_ix86_preferred_stack_boundary_arg;





  int x_ix86_regparm;





  int x_ix86_sse2avx;





  int x_ix86_force_align_arg_pointer;





  enum stringop_alg x_ix86_stringop_alg;





  enum tls_dialect x_ix86_tls_dialect;





  const char *x_ix86_tune_string;





  enum ix86_veclibabi x_ix86_veclibabi_type;





  const char *x_asm_file_name;





  int x_pass_exit_codes;





  int x_pedantic;





  int x_flag_pedantic_errors;





  int x_use_pipes;





  const char *x_print_file_name;





  int x_print_multi_directory;





  int x_print_multi_lib;





  int x_print_multi_os_directory;





  const char *x_print_prog_name;





  int x_print_search_dirs;





  int x_print_sysroot;





  int x_print_sysroot_headers_suffix;





  int x_quiet_flag;





  int x_report_times;





  int x_flag_undef;





  int x_verbose_flag;





  int x_version_flag;





  int x_inhibit_warnings;





  const char *x_wrapper_string;



  int x_VAR_malign_functions_;



  int x_VAR_malign_jumps_;



  int x_VAR_malign_loops_;



  int x_VAR_mpc32;



  int x_VAR_mpc64;



  int x_VAR_mpc80;



  unsigned char frontend_set_flag_associative_math;


  unsigned char frontend_set_flag_cx_limited_range;


  unsigned char frontend_set_flag_finite_math_only;


  unsigned char frontend_set_flag_errno_math;


  unsigned char frontend_set_flag_reciprocal_math;


  unsigned char frontend_set_flag_rounding_math;


  unsigned char frontend_set_flag_signaling_nans;


  unsigned char frontend_set_flag_signed_zeros;


  unsigned char frontend_set_flag_trapping_math;


  unsigned char frontend_set_flag_unsafe_math_optimizations;


};
extern struct gcc_options global_options;
extern const struct gcc_options global_options_init;
extern struct gcc_options global_options_set;







struct cl_optimization
{
  int x_align_functions;
  int x_align_jumps;
  int x_align_labels;
  int x_align_loops;
  int x_flag_sched_stalled_insns;
  int x_flag_sched_stalled_insns_dep;
  enum fp_contract_mode x_flag_fp_contract_mode;
  unsigned char x_optimize;
  unsigned char x_optimize_size;
  signed char x_flag_asynchronous_unwind_tables;
  signed char x_flag_branch_on_count_reg;
  signed char x_flag_branch_probabilities;
  signed char x_flag_branch_target_load_optimize;
  signed char x_flag_branch_target_load_optimize2;
  signed char x_flag_btr_bb_exclusive;
  signed char x_flag_caller_saves;
  signed char x_flag_combine_stack_adjustments;
  signed char x_flag_no_common;
  signed char x_flag_compare_elim_after_reload;
  signed char x_flag_conserve_stack;
  signed char x_flag_cprop_registers;
  signed char x_flag_crossjumping;
  signed char x_flag_cse_follow_jumps;
  signed char x_flag_cx_fortran_rules;
  signed char x_flag_cx_limited_range;
  signed char x_flag_data_sections;
  signed char x_flag_dce;
  signed char x_flag_defer_pop;
  signed char x_flag_delayed_branch;
  signed char x_flag_delete_null_pointer_checks;
  signed char x_flag_devirtualize;
  signed char x_flag_dse;
  signed char x_flag_early_inlining;
  signed char x_flag_exceptions;
  signed char x_flag_expensive_optimizations;
  signed char x_flag_finite_math_only;
  signed char x_flag_float_store;
  signed char x_flag_forward_propagate;
  signed char x_flag_gcse;
  signed char x_flag_gcse_after_reload;
  signed char x_flag_gcse_las;
  signed char x_flag_gcse_lm;
  signed char x_flag_gcse_sm;
  signed char x_flag_graphite_identity;
  signed char x_flag_guess_branch_prob;
  signed char x_flag_if_conversion;
  signed char x_flag_if_conversion2;
  signed char x_flag_inline_functions;
  signed char x_flag_inline_functions_called_once;
  signed char x_flag_inline_small_functions;
  signed char x_flag_ipa_cp;
  signed char x_flag_ipa_cp_clone;
  signed char x_flag_ipa_matrix_reorg;
  signed char x_flag_ipa_profile;
  signed char x_flag_ipa_pta;
  signed char x_flag_ipa_pure_const;
  signed char x_flag_ipa_reference;
  signed char x_flag_ipa_sra;
  signed char x_flag_ivopts;
  signed char x_flag_jump_tables;
  signed char x_flag_loop_block;
  signed char x_flag_loop_flatten;
  signed char x_flag_loop_interchange;
  signed char x_flag_loop_parallelize_all;
  signed char x_flag_loop_strip_mine;
  signed char x_flag_lto_report;
  signed char x_flag_ltrans;
  signed char x_flag_errno_math;
  signed char x_flag_merge_constants;
  signed char x_flag_modulo_sched;
  signed char x_flag_move_loop_invariants;
  signed char x_flag_non_call_exceptions;
  signed char x_flag_nothrow_opt;
  signed char x_flag_omit_frame_pointer;
  signed char x_flag_regmove;
  signed char x_flag_optimize_sibling_calls;
  signed char x_flag_pack_struct;
  signed char x_flag_peel_loops;
  signed char x_flag_no_peephole;
  signed char x_flag_peephole2;
  signed char x_flag_predictive_commoning;
  signed char x_flag_prefetch_loop_arrays;
  signed char x_flag_pcc_struct_return;
  signed char x_flag_rename_registers;
  signed char x_flag_reorder_blocks;
  signed char x_flag_reorder_blocks_and_partition;
  signed char x_flag_reorder_functions;
  signed char x_flag_rerun_cse_after_loop;
  signed char x_flag_resched_modulo_sched;
  signed char x_flag_rounding_math;
  signed char x_flag_rtti;
  signed char x_flag_sched_critical_path_heuristic;
  signed char x_flag_sched_dep_count_heuristic;
  signed char x_flag_sched_group_heuristic;
  signed char x_flag_schedule_interblock;
  signed char x_flag_sched_last_insn_heuristic;
  signed char x_flag_sched_pressure;
  signed char x_flag_sched_rank_heuristic;
  signed char x_flag_schedule_speculative;
  signed char x_flag_sched_spec_insn_heuristic;
  signed char x_flag_schedule_speculative_load;
  signed char x_flag_schedule_speculative_load_dangerous;
  signed char x_flag_sched2_use_superblocks;
  signed char x_flag_schedule_insns;
  signed char x_flag_schedule_insns_after_reload;
  signed char x_flag_section_anchors;
  signed char x_flag_sel_sched_pipelining;
  signed char x_flag_sel_sched_pipelining_outer_loops;
  signed char x_flag_sel_sched_reschedule_pipelined;
  signed char x_flag_selective_scheduling;
  signed char x_flag_selective_scheduling2;
  signed char x_flag_short_double;
  signed char x_flag_short_enums;
  signed char x_flag_short_wchar;
  signed char x_flag_signaling_nans;
  signed char x_flag_signed_zeros;
  signed char x_flag_single_precision_constant;
  signed char x_flag_split_ivs_in_unroller;
  signed char x_flag_split_wide_types;
  signed char x_flag_strict_aliasing;
  signed char x_flag_strict_enums;
  signed char x_flag_thread_jumps;
  signed char x_flag_threadsafe_statics;
  signed char x_flag_toplevel_reorder;
  signed char x_flag_trapping_math;
  signed char x_flag_trapv;
  signed char x_flag_tree_bit_ccp;
  signed char x_flag_tree_builtin_call_dce;
  signed char x_flag_tree_ccp;
  signed char x_flag_tree_ch;
  signed char x_flag_tree_copy_prop;
  signed char x_flag_tree_copyrename;
  signed char x_flag_tree_cselim;
  signed char x_flag_tree_dce;
  signed char x_flag_tree_dom;
  signed char x_flag_tree_dse;
  signed char x_flag_tree_forwprop;
  signed char x_flag_tree_fre;
  signed char x_flag_tree_loop_distribute_patterns;
  signed char x_flag_tree_loop_distribution;
  signed char x_flag_tree_loop_if_convert;
  signed char x_flag_tree_loop_if_convert_stores;
  signed char x_flag_tree_loop_im;
  signed char x_flag_tree_loop_ivcanon;
  signed char x_flag_tree_loop_optimize;
  signed char x_flag_tree_live_range_split;
  signed char x_flag_tree_phiprop;
  signed char x_flag_tree_pre;
  signed char x_flag_tree_pta;
  signed char x_flag_tree_reassoc;
  signed char x_flag_tree_scev_cprop;
  signed char x_flag_tree_sink;
  signed char x_flag_tree_slp_vectorize;
  signed char x_flag_tree_sra;
  signed char x_flag_tree_switch_conversion;
  signed char x_flag_tree_ter;
  signed char x_flag_tree_vect_loop_version;
  signed char x_flag_tree_vectorize;
  signed char x_flag_tree_vrp;
  signed char x_flag_unit_at_a_time;
  signed char x_flag_unroll_all_loops;
  signed char x_flag_unroll_loops;
  signed char x_flag_unsafe_loop_optimizations;
  signed char x_flag_unsafe_math_optimizations;
  signed char x_flag_unswitch_loops;
  signed char x_flag_unwind_tables;
  signed char x_flag_var_tracking;
  signed char x_flag_var_tracking_assignments;
  signed char x_flag_var_tracking_assignments_toggle;
  signed char x_flag_var_tracking_uninit;
  signed char x_flag_variable_expansion_in_unroller;
  signed char x_flag_vect_cost_model;
  signed char x_flag_value_profile_transformations;
  signed char x_flag_web;
  signed char x_flag_whole_program;
  signed char x_flag_wpa;
  signed char x_flag_wrapv;
};


struct cl_target_option
{
  long long x_ix86_isa_flags_explicit;
  long long x_ix86_isa_flags;
  enum fpmath_unit x_ix86_fpmath;
  int ix86_target_flags_explicit;
  int x_target_flags;
  unsigned char arch;
  unsigned char arch_specified;
  unsigned char branch_cost;
  unsigned char schedule;
  unsigned char tune;
  unsigned char tune_defaulted;
};



extern void cl_optimization_save (struct cl_optimization *, struct gcc_options *);


extern void cl_optimization_restore (struct gcc_options *, struct cl_optimization *);


extern void cl_optimization_print (FILE *, int, struct cl_optimization *);


extern void cl_target_option_save (struct cl_target_option *, struct gcc_options *);


extern void cl_target_option_restore (struct gcc_options *, struct cl_target_option *);


extern void cl_target_option_print (FILE *, int, struct cl_target_option *);
# 3720 "options.h"
enum opt_code
{
  OPT____ = 0,
# 3754 "options.h"
  OPT__help = 32,
  OPT__help_ = 33,
# 3787 "options.h"
  OPT__output_pch_ = 65,

  OPT__param = 67,
# 3821 "options.h"
  OPT__sysroot_ = 99,
  OPT__target_help = 100,
# 3832 "options.h"
  OPT__version = 110,


  OPT_A = 113,
  OPT_B = 114,
  OPT_C = 115,
  OPT_CC = 116,

  OPT_D = 118,
  OPT_E = 119,
  OPT_F = 120,
  OPT_H = 121,
  OPT_I = 122,
  OPT_J = 123,
  OPT_L = 124,
  OPT_M = 125,
  OPT_MD = 126,
  OPT_MD_ = 127,
  OPT_MF = 128,
  OPT_MG = 129,
  OPT_MM = 130,
  OPT_MMD = 131,
  OPT_MMD_ = 132,
  OPT_MP = 133,
  OPT_MQ = 134,
  OPT_MT = 135,
  OPT_N = 136,
  OPT_O = 137,
  OPT_Ofast = 138,
  OPT_Os = 139,
  OPT_P = 140,
  OPT_Q = 141,
  OPT_Qn = 142,
  OPT_Qy = 143,
  OPT_R = 144,
  OPT_S = 145,
  OPT_T = 146,
  OPT_Tbss = 147,
  OPT_Tbss_ = 148,
  OPT_Tdata = 149,
  OPT_Tdata_ = 150,
  OPT_Ttext = 151,
  OPT_Ttext_ = 152,
  OPT_U = 153,

  OPT_Wa_ = 155,
  OPT_Wabi = 156,
  OPT_Waddress = 157,
  OPT_Waggregate_return = 158,
  OPT_Waliasing = 159,
  OPT_Walign_commons = 160,
  OPT_Wall = 161,
  OPT_Wall_deprecation = 162,
  OPT_Wall_javadoc = 163,
  OPT_Wampersand = 164,
  OPT_Warray_bounds = 165,
  OPT_Warray_temporaries = 166,
  OPT_Wassert_identifier = 167,
  OPT_Wassign_intercept = 168,
  OPT_Wattributes = 169,
  OPT_Wbad_function_cast = 170,
  OPT_Wboxing = 171,
  OPT_Wbuiltin_macro_redefined = 172,
  OPT_Wc___compat = 173,
  OPT_Wc__0x_compat = 174,
  OPT_Wcast_align = 175,
  OPT_Wcast_qual = 176,
  OPT_Wchar_concat = 177,
  OPT_Wchar_subscripts = 178,
  OPT_Wcharacter_truncation = 179,
  OPT_Wclobbered = 180,
  OPT_Wcomment = 181,

  OPT_Wcondition_assign = 183,
  OPT_Wconstructor_name = 184,
  OPT_Wconversion = 185,
  OPT_Wconversion_extra = 186,
  OPT_Wconversion_null = 187,
  OPT_Wcoverage_mismatch = 188,
  OPT_Wcpp = 189,
  OPT_Wctor_dtor_privacy = 190,
  OPT_Wdeclaration_after_statement = 191,
  OPT_Wdelete_non_virtual_dtor = 192,
  OPT_Wdep_ann = 193,
  OPT_Wdeprecated = 194,
  OPT_Wdeprecated_declarations = 195,
  OPT_Wdisabled_optimization = 196,
  OPT_Wdiscouraged = 197,
  OPT_Wdiv_by_zero = 198,
  OPT_Wdouble_promotion = 199,
  OPT_Weffc__ = 200,
  OPT_Wempty_block = 201,
  OPT_Wempty_body = 202,
  OPT_Wendif_labels = 203,
  OPT_Wenum_compare = 204,
  OPT_Wenum_identifier = 205,
  OPT_Wenum_switch = 206,
  OPT_Werror = 207,

  OPT_Werror_ = 209,
  OPT_Wextra = 210,
  OPT_Wextraneous_semicolon = 211,
  OPT_Wfallthrough = 212,
  OPT_Wfatal_errors = 213,
  OPT_Wfield_hiding = 214,
  OPT_Wfinal_bound = 215,
  OPT_Wfinally = 216,
  OPT_Wfloat_equal = 217,
  OPT_Wforbidden = 218,
  OPT_Wformat = 219,
  OPT_Wformat_contains_nul = 220,
  OPT_Wformat_extra_args = 221,
  OPT_Wformat_nonliteral = 222,
  OPT_Wformat_security = 223,
  OPT_Wformat_y2k = 224,
  OPT_Wformat_zero_length = 225,
  OPT_Wformat_ = 226,
  OPT_Wframe_larger_than_ = 227,
  OPT_Wfree_nonheap_object = 228,
  OPT_Wfunction_elimination = 229,
  OPT_Whiding = 230,
  OPT_Wignored_qualifiers = 231,
  OPT_Wimplicit = 232,
  OPT_Wimplicit_function_declaration = 233,
  OPT_Wimplicit_int = 234,
  OPT_Wimplicit_interface = 235,
  OPT_Wimplicit_procedure = 236,

  OPT_Windirect_static = 238,
  OPT_Winit_self = 239,
  OPT_Winline = 240,
  OPT_Wint_to_pointer_cast = 241,
  OPT_Wintf_annotation = 242,
  OPT_Wintf_non_inherited = 243,
  OPT_Wintrinsic_shadow = 244,
  OPT_Wintrinsics_std = 245,
  OPT_Winvalid_offsetof = 246,
  OPT_Winvalid_pch = 247,
  OPT_Wjavadoc = 248,
  OPT_Wjump_misses_init = 249,
  OPT_Wl_ = 250,

  OPT_Wlarger_than_ = 252,
  OPT_Wline_truncation = 253,
  OPT_Wlocal_hiding = 254,
  OPT_Wlogical_op = 255,
  OPT_Wlong_long = 256,
  OPT_Wmain = 257,
  OPT_Wmasked_catch_block = 258,
  OPT_Wmaybe_uninitialized = 259,
  OPT_Wmissing_braces = 260,
  OPT_Wmissing_declarations = 261,
  OPT_Wmissing_field_initializers = 262,
  OPT_Wmissing_format_attribute = 263,
  OPT_Wmissing_include_dirs = 264,
  OPT_Wmissing_noreturn = 265,
  OPT_Wmissing_parameter_type = 266,
  OPT_Wmissing_prototypes = 267,
  OPT_Wmudflap = 268,
  OPT_Wmultichar = 269,
  OPT_Wnarrowing = 270,
  OPT_Wnested_externs = 271,
  OPT_Wnls = 272,
  OPT_Wno_effect_assign = 273,
  OPT_Wnoexcept = 274,
  OPT_Wnon_template_friend = 275,
  OPT_Wnon_virtual_dtor = 276,
  OPT_Wnonnull = 277,
  OPT_Wnormalized_ = 278,
  OPT_Wnull = 279,
  OPT_Wold_style_cast = 280,
  OPT_Wold_style_declaration = 281,
  OPT_Wold_style_definition = 282,
  OPT_Wout_of_date = 283,
  OPT_Wover_ann = 284,
  OPT_Woverflow = 285,
  OPT_Woverlength_strings = 286,
  OPT_Woverloaded_virtual = 287,
  OPT_Woverride_init = 288,
  OPT_Wp_ = 289,
  OPT_Wpacked = 290,
  OPT_Wpacked_bitfield_compat = 291,
  OPT_Wpadded = 292,
  OPT_Wparam_assign = 293,
  OPT_Wparentheses = 294,
  OPT_Wpkg_default_method = 295,
  OPT_Wpmf_conversions = 296,
  OPT_Wpointer_arith = 297,
  OPT_Wpointer_sign = 298,
  OPT_Wpointer_to_int_cast = 299,
  OPT_Wpragmas = 300,
  OPT_Wproperty_assign_default = 301,
  OPT_Wprotocol = 302,
  OPT_Wpsabi = 303,
  OPT_Wraw = 304,
  OPT_Wreal_q_constant = 305,
  OPT_Wredundant_decls = 306,
  OPT_Wredundant_modifiers = 307,
  OPT_Wreorder = 308,
  OPT_Wreturn_type = 309,
  OPT_Wselector = 310,
  OPT_Wsequence_point = 311,
  OPT_Wserial = 312,
  OPT_Wshadow = 313,
  OPT_Wsign_compare = 314,
  OPT_Wsign_conversion = 315,
  OPT_Wsign_promo = 316,
  OPT_Wspecial_param_hiding = 317,
  OPT_Wstack_protector = 318,
  OPT_Wstack_usage_ = 319,
  OPT_Wstatic_access = 320,
  OPT_Wstatic_receiver = 321,
  OPT_Wstrict_aliasing = 322,
  OPT_Wstrict_aliasing_ = 323,
  OPT_Wstrict_null_sentinel = 324,
  OPT_Wstrict_overflow = 325,
  OPT_Wstrict_overflow_ = 326,
  OPT_Wstrict_prototypes = 327,
  OPT_Wstrict_selector_match = 328,
  OPT_Wsuggest_attribute_const = 329,
  OPT_Wsuggest_attribute_noreturn = 330,
  OPT_Wsuggest_attribute_pure = 331,
  OPT_Wsuppress = 332,
  OPT_Wsurprising = 333,
  OPT_Wswitch = 334,
  OPT_Wswitch_default = 335,
  OPT_Wswitch_enum = 336,
  OPT_Wsync_nand = 337,
  OPT_Wsynth = 338,
  OPT_Wsynthetic_access = 339,
  OPT_Wsystem_headers = 340,
  OPT_Wtabs = 341,
  OPT_Wtasks = 342,
  OPT_Wtraditional = 343,
  OPT_Wtraditional_conversion = 344,
  OPT_Wtrampolines = 345,
  OPT_Wtrigraphs = 346,
  OPT_Wtype_hiding = 347,
  OPT_Wtype_limits = 348,
  OPT_Wuncheck = 349,
  OPT_Wundeclared_selector = 350,
  OPT_Wundef = 351,
  OPT_Wunderflow = 352,
  OPT_Wuninitialized = 353,
  OPT_Wunknown_pragmas = 354,
  OPT_Wunnecessary_else = 355,
  OPT_Wunqualified_field = 356,

  OPT_Wunsafe_loop_optimizations = 358,
  OPT_Wunsuffixed_float_constants = 359,
  OPT_Wunused = 360,
  OPT_Wunused_argument = 361,
  OPT_Wunused_but_set_parameter = 362,
  OPT_Wunused_but_set_variable = 363,
  OPT_Wunused_dummy_argument = 364,
  OPT_Wunused_function = 365,
  OPT_Wunused_import = 366,
  OPT_Wunused_label = 367,
  OPT_Wunused_local = 368,
  OPT_Wunused_local_typedefs = 369,
  OPT_Wunused_macros = 370,
  OPT_Wunused_parameter = 371,
  OPT_Wunused_private = 372,
  OPT_Wunused_result = 373,
  OPT_Wunused_thrown = 374,
  OPT_Wunused_value = 375,
  OPT_Wunused_variable = 376,
  OPT_Wuseless_type_check = 377,
  OPT_Wvarargs_cast = 378,
  OPT_Wvariadic_macros = 379,
  OPT_Wvla = 380,
  OPT_Wvolatile_register_var = 381,
  OPT_Wwarning_token = 382,
  OPT_Wwrite_strings = 383,
  OPT_Xassembler = 384,
  OPT_Xlinker = 385,
  OPT_Xpreprocessor = 386,
  OPT_Z = 387,
  OPT_ansi = 388,
  OPT_aux_info = 389,

  OPT_auxbase = 391,
  OPT_auxbase_strip = 392,

  OPT_c = 394,

  OPT_coverage = 396,
  OPT_cpp = 397,
  OPT_cpp_ = 398,
  OPT_d = 399,
  OPT_dumpbase = 400,
  OPT_dumpdir = 401,
  OPT_dumpmachine = 402,
  OPT_dumpspecs = 403,
  OPT_dumpversion = 404,
  OPT_e = 405,

  OPT_export_dynamic = 407,
  OPT_extdirs = 408,

  OPT_fPIC = 410,
  OPT_fPIE = 411,
  OPT_fRTS_ = 412,
  OPT_fabi_version_ = 413,
  OPT_faccess_control = 414,
  OPT_faggressive_function_elimination = 415,
  OPT_falign_commons = 416,
  OPT_falign_functions = 417,
  OPT_falign_functions_ = 418,
  OPT_falign_jumps = 419,
  OPT_falign_jumps_ = 420,
  OPT_falign_labels = 421,
  OPT_falign_labels_ = 422,
  OPT_falign_loops = 423,
  OPT_falign_loops_ = 424,
  OPT_fall_intrinsics = 425,

  OPT_fallow_leading_underscore = 427,





  OPT_fasm = 433,
  OPT_fassert = 434,
  OPT_fassociative_math = 435,
  OPT_fassume_compiled = 436,
  OPT_fassume_compiled_ = 437,
  OPT_fasynchronous_unwind_tables = 438,
  OPT_fauto_inc_dec = 439,
  OPT_fautomatic = 440,
  OPT_faux_classpath = 441,
  OPT_fbackslash = 442,
  OPT_fbacktrace = 443,
  OPT_fblas_matmul_limit_ = 444,
  OPT_fbootclasspath_ = 445,
  OPT_fbootstrap_classes = 446,
  OPT_fbounds_check = 447,
  OPT_fbranch_count_reg = 448,
  OPT_fbranch_probabilities = 449,
  OPT_fbranch_target_load_optimize = 450,
  OPT_fbranch_target_load_optimize2 = 451,
  OPT_fbtr_bb_exclusive = 452,
  OPT_fbuilding_libgcc = 453,
  OPT_fbuiltin = 454,
  OPT_fbuiltin_ = 455,
  OPT_fcall_saved_ = 456,
  OPT_fcall_used_ = 457,
  OPT_fcaller_saves = 458,
  OPT_fcheck_array_temporaries = 459,
  OPT_fcheck_data_deps = 460,
  OPT_fcheck_new = 461,
  OPT_fcheck_references = 462,
  OPT_fcheck_ = 463,
  OPT_fclasspath_ = 464,
  OPT_fcoarray_ = 465,
  OPT_fcombine_stack_adjustments = 466,
  OPT_fcommon = 467,
  OPT_fcompare_debug = 468,
  OPT_fcompare_debug_second = 469,
  OPT_fcompare_debug_ = 470,
  OPT_fcompare_elim = 471,
  OPT_fcompile_resource_ = 472,
  OPT_fcond_mismatch = 473,
  OPT_fconserve_space = 474,
  OPT_fconserve_stack = 475,
  OPT_fconstant_string_class_ = 476,
  OPT_fconstexpr_depth_ = 477,
  OPT_fconvert_big_endian = 478,
  OPT_fconvert_little_endian = 479,
  OPT_fconvert_native = 480,
  OPT_fconvert_swap = 481,
  OPT_fcprop_registers = 482,
  OPT_fcray_pointer = 483,
  OPT_fcrossjumping = 484,
  OPT_fcse_follow_jumps = 485,

  OPT_fcx_fortran_rules = 487,
  OPT_fcx_limited_range = 488,
  OPT_fd_lines_as_code = 489,
  OPT_fd_lines_as_comments = 490,
  OPT_fdata_sections = 491,
  OPT_fdbg_cnt_list = 492,
  OPT_fdbg_cnt_ = 493,
  OPT_fdce = 494,
  OPT_fdebug_prefix_map_ = 495,
  OPT_fdebug_types_section = 496,
  OPT_fdeduce_init_list = 497,
  OPT_fdefault_double_8 = 498,

  OPT_fdefault_integer_8 = 500,
  OPT_fdefault_real_8 = 501,
  OPT_fdefer_pop = 502,
  OPT_fdelayed_branch = 503,
  OPT_fdelete_null_pointer_checks = 504,
  OPT_fdevirtualize = 505,
  OPT_fdiagnostics_show_location_ = 506,
  OPT_fdiagnostics_show_option = 507,
  OPT_fdirectives_only = 508,
  OPT_fdisable_ = 509,
  OPT_fdisable_assertions = 510,
  OPT_fdisable_assertions_ = 511,
  OPT_fdollar_ok = 512,
  OPT_fdollars_in_identifiers = 513,
  OPT_fdse = 514,
  OPT_fdump_ = 515,

  OPT_fdump_final_insns = 517,
  OPT_fdump_final_insns_ = 518,
  OPT_fdump_fortran_optimized = 519,
  OPT_fdump_fortran_original = 520,
  OPT_fdump_go_spec_ = 521,
  OPT_fdump_noaddr = 522,
  OPT_fdump_parse_tree = 523,
  OPT_fdump_passes = 524,
  OPT_fdump_unnumbered = 525,
  OPT_fdump_unnumbered_links = 526,
  OPT_fdwarf2_cfi_asm = 527,
  OPT_fearly_inlining = 528,
  OPT_felide_constructors = 529,
  OPT_feliminate_dwarf2_dups = 530,
  OPT_feliminate_unused_debug_symbols = 531,
  OPT_feliminate_unused_debug_types = 532,
  OPT_femit_class_debug_always = 533,
  OPT_femit_class_file = 534,
  OPT_femit_class_files = 535,
  OPT_femit_struct_debug_baseonly = 536,
  OPT_femit_struct_debug_detailed_ = 537,
  OPT_femit_struct_debug_reduced = 538,
  OPT_fenable_ = 539,
  OPT_fenable_assertions = 540,
  OPT_fenable_assertions_ = 541,
  OPT_fencoding_ = 542,
  OPT_fenforce_eh_specs = 543,

  OPT_fexceptions = 545,
  OPT_fexcess_precision_ = 546,
  OPT_fexec_charset_ = 547,
  OPT_fexpensive_optimizations = 548,
  OPT_fextdirs_ = 549,
  OPT_fextended_identifiers = 550,
  OPT_fexternal_blas = 551,

  OPT_ff2c = 553,
  OPT_ffast_math = 554,
  OPT_ffilelist_file = 555,
  OPT_ffinite_math_only = 556,
  OPT_ffixed_ = 557,
  OPT_ffixed_form = 558,
  OPT_ffixed_line_length_ = 559,
  OPT_ffixed_line_length_none = 560,
  OPT_ffloat_store = 561,
  OPT_ffor_scope = 562,

  OPT_fforce_classes_archive_check = 564,
  OPT_fforward_propagate = 565,
  OPT_ffp_contract_ = 566,
  OPT_ffpe_trap_ = 567,
  OPT_ffree_form = 568,
  OPT_ffree_line_length_ = 569,
  OPT_ffree_line_length_none = 570,
  OPT_ffreestanding = 571,
  OPT_ffriend_injection = 572,
  OPT_ffrontend_optimize = 573,
  OPT_ffunction_cse = 574,
  OPT_ffunction_sections = 575,
  OPT_fgcse = 576,
  OPT_fgcse_after_reload = 577,
  OPT_fgcse_las = 578,
  OPT_fgcse_lm = 579,
  OPT_fgcse_sm = 580,
  OPT_fgnu_keywords = 581,
  OPT_fgnu_runtime = 582,
  OPT_fgnu89_inline = 583,
  OPT_fgo_dump_ = 584,
  OPT_fgo_optimize_ = 585,
  OPT_fgo_prefix_ = 586,
  OPT_fgraphite = 587,
  OPT_fgraphite_identity = 588,
  OPT_fguess_branch_probability = 589,


  OPT_fhash_synchronization = 592,



  OPT_fhosted = 596,

  OPT_fident = 598,
  OPT_fif_conversion = 599,
  OPT_fif_conversion2 = 600,
  OPT_fimplement_inlines = 601,
  OPT_fimplicit_inline_templates = 602,
  OPT_fimplicit_none = 603,
  OPT_fimplicit_templates = 604,
  OPT_findirect_classes = 605,
  OPT_findirect_dispatch = 606,
  OPT_findirect_inlining = 607,
  OPT_finhibit_size_directive = 608,
  OPT_finit_character_ = 609,
  OPT_finit_integer_ = 610,
  OPT_finit_local_zero = 611,
  OPT_finit_logical_ = 612,
  OPT_finit_real_ = 613,
  OPT_finline = 614,
  OPT_finline_functions = 615,
  OPT_finline_functions_called_once = 616,

  OPT_finline_limit_ = 618,
  OPT_finline_small_functions = 619,
  OPT_finput_charset_ = 620,
  OPT_finstrument_functions = 621,
  OPT_finstrument_functions_exclude_file_list_ = 622,
  OPT_finstrument_functions_exclude_function_list_ = 623,
  OPT_fintrinsic_modules_path = 624,
  OPT_fipa_cp = 625,
  OPT_fipa_cp_clone = 626,
  OPT_fipa_matrix_reorg = 627,
  OPT_fipa_profile = 628,
  OPT_fipa_pta = 629,
  OPT_fipa_pure_const = 630,
  OPT_fipa_reference = 631,
  OPT_fipa_sra = 632,

  OPT_fira_algorithm_ = 634,
  OPT_fira_loop_pressure = 635,
  OPT_fira_region_ = 636,
  OPT_fira_share_save_slots = 637,
  OPT_fira_share_spill_slots = 638,
  OPT_fira_verbose_ = 639,
  OPT_fivopts = 640,
  OPT_fjni = 641,
  OPT_fjump_tables = 642,
  OPT_fkeep_inline_dllexport = 643,
  OPT_fkeep_inline_functions = 644,
  OPT_fkeep_static_consts = 645,

  OPT_flax_vector_conversions = 647,
  OPT_fleading_underscore = 648,
  OPT_floop_block = 649,
  OPT_floop_flatten = 650,
  OPT_floop_interchange = 651,

  OPT_floop_parallelize_all = 653,
  OPT_floop_strip_mine = 654,
  OPT_flto = 655,
  OPT_flto_compression_level_ = 656,
  OPT_flto_partition_1to1 = 657,
  OPT_flto_partition_balanced = 658,
  OPT_flto_partition_none = 659,
  OPT_flto_report = 660,
  OPT_flto_ = 661,
  OPT_fltrans = 662,
  OPT_fltrans_output_list_ = 663,
  OPT_fmain_ = 664,
  OPT_fmath_errno = 665,
  OPT_fmax_array_constructor_ = 666,
  OPT_fmax_errors_ = 667,
  OPT_fmax_identifier_length_ = 668,
  OPT_fmax_stack_var_size_ = 669,
  OPT_fmax_subrecord_length_ = 670,
  OPT_fmem_report = 671,
  OPT_fmerge_all_constants = 672,
  OPT_fmerge_constants = 673,
  OPT_fmerge_debug_strings = 674,
  OPT_fmessage_length_ = 675,
  OPT_fmodule_private = 676,
  OPT_fmodulo_sched = 677,
  OPT_fmodulo_sched_allow_regmoves = 678,
  OPT_fmove_loop_invariants = 679,
  OPT_fms_extensions = 680,
  OPT_fmudflap = 681,
  OPT_fmudflapir = 682,
  OPT_fmudflapth = 683,


  OPT_fnext_runtime = 686,
  OPT_fnil_receivers = 687,
  OPT_fnon_call_exceptions = 688,
  OPT_fnonansi_builtins = 689,

  OPT_fnothrow_opt = 691,
  OPT_fobjc_abi_version_ = 692,
  OPT_fobjc_call_cxx_cdtors = 693,
  OPT_fobjc_direct_dispatch = 694,
  OPT_fobjc_exceptions = 695,
  OPT_fobjc_gc = 696,
  OPT_fobjc_nilcheck = 697,
  OPT_fobjc_sjlj_exceptions = 698,
  OPT_fobjc_std_objc1 = 699,
  OPT_fomit_frame_pointer = 700,
  OPT_fopenmp = 701,
  OPT_foperator_names = 702,
  OPT_foptimize_register_move = 703,
  OPT_foptimize_sibling_calls = 704,
  OPT_foptimize_static_class_initialization = 705,

  OPT_foutput_class_dir_ = 707,
  OPT_fpack_derived = 708,
  OPT_fpack_struct = 709,
  OPT_fpack_struct_ = 710,
  OPT_fpartial_inlining = 711,
  OPT_fpcc_struct_return = 712,
  OPT_fpch_deps = 713,
  OPT_fpch_preprocess = 714,
  OPT_fpeel_loops = 715,
  OPT_fpeephole = 716,
  OPT_fpeephole2 = 717,
  OPT_fpermissive = 718,
  OPT_fpic = 719,
  OPT_fpie = 720,
  OPT_fplan9_extensions = 721,
  OPT_fplugin_arg_ = 722,
  OPT_fplugin_ = 723,
  OPT_fpost_ipa_mem_report = 724,
  OPT_fpre_ipa_mem_report = 725,
  OPT_fpredictive_commoning = 726,
  OPT_fprefetch_loop_arrays = 727,
  OPT_fpreprocessed = 728,
  OPT_fpretty_templates = 729,
  OPT_fprofile = 730,
  OPT_fprofile_arcs = 731,
  OPT_fprofile_correction = 732,
  OPT_fprofile_dir_ = 733,
  OPT_fprofile_generate = 734,
  OPT_fprofile_generate_ = 735,
  OPT_fprofile_use = 736,
  OPT_fprofile_use_ = 737,
  OPT_fprofile_values = 738,
  OPT_fprotect_parens = 739,
  OPT_frandom_seed = 740,
  OPT_frandom_seed_ = 741,
  OPT_frange_check = 742,
  OPT_frealloc_lhs = 743,
  OPT_freciprocal_math = 744,
  OPT_frecord_gcc_switches = 745,
  OPT_frecord_marker_4 = 746,
  OPT_frecord_marker_8 = 747,
  OPT_frecursive = 748,
  OPT_freduced_reflection = 749,
  OPT_freg_struct_return = 750,
  OPT_fregmove = 751,
  OPT_frename_registers = 752,
  OPT_freorder_blocks = 753,
  OPT_freorder_blocks_and_partition = 754,
  OPT_freorder_functions = 755,
  OPT_frepack_arrays = 756,
  OPT_freplace_objc_classes = 757,
  OPT_frepo = 758,
  OPT_frequire_return_statement = 759,
  OPT_frerun_cse_after_loop = 760,

  OPT_freschedule_modulo_scheduled_loops = 762,
  OPT_fresolution_ = 763,
  OPT_frounding_math = 764,
  OPT_frtti = 765,
  OPT_fsaw_java_file = 766,
  OPT_fsched_critical_path_heuristic = 767,
  OPT_fsched_dep_count_heuristic = 768,
  OPT_fsched_group_heuristic = 769,
  OPT_fsched_interblock = 770,
  OPT_fsched_last_insn_heuristic = 771,
  OPT_fsched_pressure = 772,
  OPT_fsched_rank_heuristic = 773,
  OPT_fsched_spec = 774,
  OPT_fsched_spec_insn_heuristic = 775,
  OPT_fsched_spec_load = 776,
  OPT_fsched_spec_load_dangerous = 777,
  OPT_fsched_stalled_insns = 778,
  OPT_fsched_stalled_insns_dep = 779,
  OPT_fsched_stalled_insns_dep_ = 780,
  OPT_fsched_stalled_insns_ = 781,
  OPT_fsched_verbose_ = 782,
  OPT_fsched2_use_superblocks = 783,

  OPT_fschedule_insns = 785,
  OPT_fschedule_insns2 = 786,
  OPT_fsecond_underscore = 787,
  OPT_fsection_anchors = 788,

  OPT_fsel_sched_pipelining = 790,
  OPT_fsel_sched_pipelining_outer_loops = 791,
  OPT_fsel_sched_reschedule_pipelined = 792,
  OPT_fselective_scheduling = 793,
  OPT_fselective_scheduling2 = 794,
  OPT_fshort_double = 795,
  OPT_fshort_enums = 796,
  OPT_fshort_wchar = 797,
  OPT_fshow_column = 798,
  OPT_fsign_zero = 799,
  OPT_fsignaling_nans = 800,
  OPT_fsigned_bitfields = 801,
  OPT_fsigned_char = 802,
  OPT_fsigned_zeros = 803,
  OPT_fsingle_precision_constant = 804,
  OPT_fsource_filename_ = 805,
  OPT_fsource_ = 806,
  OPT_fsplit_ivs_in_unroller = 807,
  OPT_fsplit_stack = 808,
  OPT_fsplit_wide_types = 809,

  OPT_fstack_arrays = 811,

  OPT_fstack_check_ = 813,
  OPT_fstack_limit = 814,
  OPT_fstack_limit_register_ = 815,
  OPT_fstack_limit_symbol_ = 816,
  OPT_fstack_protector = 817,
  OPT_fstack_protector_all = 818,
  OPT_fstack_usage = 819,
  OPT_fstats = 820,
  OPT_fstore_check = 821,

  OPT_fstrict_aliasing = 823,
  OPT_fstrict_enums = 824,
  OPT_fstrict_overflow = 825,

  OPT_fstrict_volatile_bitfields = 827,
  OPT_fsyntax_only = 828,
  OPT_ftabstop_ = 829,

  OPT_ftarget_ = 831,

  OPT_ftemplate_depth_ = 833,
  OPT_ftest_coverage = 834,

  OPT_fthread_jumps = 836,
  OPT_fthreadsafe_statics = 837,
  OPT_ftime_report = 838,
  OPT_ftls_model_ = 839,
  OPT_ftoplevel_reorder = 840,
  OPT_ftracer = 841,
  OPT_ftrapping_math = 842,
  OPT_ftrapv = 843,
  OPT_ftree_bit_ccp = 844,
  OPT_ftree_builtin_call_dce = 845,
  OPT_ftree_ccp = 846,
  OPT_ftree_ch = 847,
  OPT_ftree_copy_prop = 848,
  OPT_ftree_copyrename = 849,
  OPT_ftree_cselim = 850,
  OPT_ftree_dce = 851,
  OPT_ftree_dominator_opts = 852,
  OPT_ftree_dse = 853,
  OPT_ftree_forwprop = 854,
  OPT_ftree_fre = 855,
  OPT_ftree_loop_distribute_patterns = 856,
  OPT_ftree_loop_distribution = 857,
  OPT_ftree_loop_if_convert = 858,
  OPT_ftree_loop_if_convert_stores = 859,
  OPT_ftree_loop_im = 860,
  OPT_ftree_loop_ivcanon = 861,

  OPT_ftree_loop_optimize = 863,
  OPT_ftree_lrs = 864,
  OPT_ftree_parallelize_loops_ = 865,
  OPT_ftree_phiprop = 866,
  OPT_ftree_pre = 867,
  OPT_ftree_pta = 868,
  OPT_ftree_reassoc = 869,

  OPT_ftree_scev_cprop = 871,
  OPT_ftree_sink = 872,
  OPT_ftree_slp_vectorize = 873,
  OPT_ftree_sra = 874,


  OPT_ftree_switch_conversion = 877,
  OPT_ftree_ter = 878,
  OPT_ftree_vect_loop_version = 879,
  OPT_ftree_vectorize = 880,
  OPT_ftree_vectorizer_verbose_ = 881,
  OPT_ftree_vrp = 882,
  OPT_funderscoring = 883,
  OPT_funit_at_a_time = 884,
  OPT_funroll_all_loops = 885,
  OPT_funroll_loops = 886,
  OPT_funsafe_loop_optimizations = 887,
  OPT_funsafe_math_optimizations = 888,
  OPT_funsigned_bitfields = 889,
  OPT_funsigned_char = 890,
  OPT_funswitch_loops = 891,
  OPT_funwind_tables = 892,
  OPT_fuse_atomic_builtins = 893,
  OPT_fuse_boehm_gc = 894,
  OPT_fuse_cxa_atexit = 895,
  OPT_fuse_cxa_get_exception_ptr = 896,
  OPT_fuse_divide_subroutine = 897,
  OPT_fuse_linker_plugin = 898,
  OPT_fvar_tracking = 899,
  OPT_fvar_tracking_assignments = 900,
  OPT_fvar_tracking_assignments_toggle = 901,
  OPT_fvar_tracking_uninit = 902,
  OPT_fvariable_expansion_in_unroller = 903,
  OPT_fvect_cost_model = 904,
  OPT_fverbose_asm = 905,

  OPT_fvisibility_inlines_hidden = 907,
  OPT_fvisibility_ms_compat = 908,
  OPT_fvisibility_ = 909,
  OPT_fvpt = 910,


  OPT_fweak = 913,
  OPT_fweb = 914,
  OPT_fwhole_file = 915,
  OPT_fwhole_program = 916,
  OPT_fwide_exec_charset_ = 917,
  OPT_fworking_directory = 918,
  OPT_fwpa = 919,
  OPT_fwrapv = 920,

  OPT_fzee = 922,
  OPT_fzero_initialized_in_bss = 923,
  OPT_fzero_link = 924,
  OPT_g = 925,
  OPT_gant = 926,
  OPT_gcoff = 927,
  OPT_gdwarf_ = 928,
  OPT_gen_decls = 929,
  OPT_ggdb = 930,
  OPT_gnat = 931,
  OPT_gnatO = 932,
  OPT_gno_record_gcc_switches = 933,
  OPT_gno_strict_dwarf = 934,
  OPT_grecord_gcc_switches = 935,
  OPT_gstabs = 936,
  OPT_gstabs_ = 937,
  OPT_gstrict_dwarf = 938,
  OPT_gtoggle = 939,
  OPT_gvms = 940,
  OPT_gxcoff = 941,
  OPT_gxcoff_ = 942,
  OPT_h = 943,
  OPT_idirafter = 944,
  OPT_imacros = 945,
  OPT_imultilib = 946,
  OPT_include = 947,
  OPT_iplugindir_ = 948,
  OPT_iprefix = 949,
  OPT_iquote = 950,
  OPT_isysroot = 951,
  OPT_isystem = 952,
  OPT_iwithprefix = 953,
  OPT_iwithprefixbefore = 954,
  OPT_k8 = 955,
  OPT_l = 956,
  OPT_lang_asm = 957,
  OPT_m128bit_long_double = 958,
  OPT_m32 = 959,
  OPT_m3dnow = 960,
  OPT_m3dnowa = 961,
  OPT_m64 = 962,
  OPT_m80387 = 963,
  OPT_m8bit_idiv = 964,
  OPT_m96bit_long_double = 965,
  OPT_mabi_ = 966,
  OPT_mabm = 967,
  OPT_maccumulate_outgoing_args = 968,
  OPT_maes = 969,
  OPT_malign_double = 970,
  OPT_malign_functions_ = 971,
  OPT_malign_jumps_ = 972,
  OPT_malign_loops_ = 973,
  OPT_malign_stringops = 974,
  OPT_mandroid = 975,
  OPT_march_ = 976,
  OPT_masm_ = 977,
  OPT_mavx = 978,
  OPT_mavx2 = 979,
  OPT_mavx256_split_unaligned_load = 980,
  OPT_mavx256_split_unaligned_store = 981,
  OPT_mbionic = 982,
  OPT_mbmi = 983,
  OPT_mbmi2 = 984,
  OPT_mbranch_cost_ = 985,
  OPT_mcld = 986,
  OPT_mcmodel_ = 987,

  OPT_mcrc32 = 989,
  OPT_mcx16 = 990,
  OPT_mdispatch_scheduler = 991,
  OPT_mf16c = 992,
  OPT_mfancy_math_387 = 993,
  OPT_mfentry = 994,
  OPT_mfma = 995,
  OPT_mfma4 = 996,
  OPT_mforce_drap = 997,
  OPT_mfp_ret_in_387 = 998,
  OPT_mfpmath_ = 999,
  OPT_mfsgsbase = 1000,

  OPT_mglibc = 1002,
  OPT_mhard_float = 1003,
  OPT_mieee_fp = 1004,
  OPT_mincoming_stack_boundary_ = 1005,
  OPT_minline_all_stringops = 1006,
  OPT_minline_stringops_dynamically = 1007,

  OPT_mlarge_data_threshold_ = 1009,
  OPT_mlwp = 1010,
  OPT_mlzcnt = 1011,
  OPT_mmmx = 1012,
  OPT_mmovbe = 1013,
  OPT_mms_bitfields = 1014,
  OPT_mno_align_stringops = 1015,
  OPT_mno_fancy_math_387 = 1016,
  OPT_mno_push_args = 1017,
  OPT_mno_red_zone = 1018,
  OPT_mno_sse4 = 1019,
  OPT_momit_leaf_frame_pointer = 1020,
  OPT_mpc32 = 1021,
  OPT_mpc64 = 1022,
  OPT_mpc80 = 1023,
  OPT_mpclmul = 1024,
  OPT_mpopcnt = 1025,
  OPT_mprefer_avx128 = 1026,
  OPT_mpreferred_stack_boundary_ = 1027,
  OPT_mpush_args = 1028,
  OPT_mrdrnd = 1029,
  OPT_mrecip = 1030,
  OPT_mred_zone = 1031,
  OPT_mregparm_ = 1032,
  OPT_mrtd = 1033,
  OPT_msahf = 1034,
  OPT_msoft_float = 1035,
  OPT_msse = 1036,
  OPT_msse2 = 1037,
  OPT_msse2avx = 1038,
  OPT_msse3 = 1039,
  OPT_msse4 = 1040,
  OPT_msse4_1 = 1041,
  OPT_msse4_2 = 1042,
  OPT_msse4a = 1043,

  OPT_msseregparm = 1045,
  OPT_mssse3 = 1046,
  OPT_mstack_arg_probe = 1047,
  OPT_mstackrealign = 1048,
  OPT_mstringop_strategy_ = 1049,
  OPT_mtbm = 1050,
  OPT_mtls_dialect_ = 1051,
  OPT_mtls_direct_seg_refs = 1052,
  OPT_mtune_ = 1053,
  OPT_muclibc = 1054,
  OPT_mveclibabi_ = 1055,
  OPT_mvect8_ret_in_mem = 1056,
  OPT_mvzeroupper = 1057,
  OPT_mx32 = 1058,
  OPT_mxop = 1059,
  OPT_n = 1060,
  OPT_no_canonical_prefixes = 1061,
  OPT_no_integrated_cpp = 1062,
  OPT_nocpp = 1063,
  OPT_nodefaultlibs = 1064,
  OPT_nostartfiles = 1065,
  OPT_nostdinc = 1066,
  OPT_nostdinc__ = 1067,
  OPT_nostdlib = 1068,
  OPT_o = 1069,
  OPT_p = 1070,
  OPT_pass_exit_codes = 1071,
  OPT_pedantic = 1072,
  OPT_pedantic_errors = 1073,
  OPT_pg = 1074,
  OPT_pie = 1075,
  OPT_pipe = 1076,
  OPT_posix = 1077,
  OPT_print_file_name_ = 1078,
  OPT_print_libgcc_file_name = 1079,
  OPT_print_multi_directory = 1080,
  OPT_print_multi_lib = 1081,
  OPT_print_multi_os_directory = 1082,
  OPT_print_objc_runtime_info = 1083,
  OPT_print_prog_name_ = 1084,
  OPT_print_search_dirs = 1085,
  OPT_print_sysroot = 1086,
  OPT_print_sysroot_headers_suffix = 1087,
  OPT_profile = 1088,
  OPT_pthread = 1089,
  OPT_quiet = 1090,
  OPT_r = 1091,
  OPT_rdynamic = 1092,
  OPT_remap = 1093,
  OPT_s = 1094,
  OPT_s_bc_abi = 1095,
  OPT_save_temps = 1096,
  OPT_save_temps_ = 1097,
  OPT_shared = 1098,
  OPT_shared_libgcc = 1099,

  OPT_specs_ = 1101,
  OPT_static = 1102,
  OPT_static_libgcc = 1103,
  OPT_static_libgcj = 1104,
  OPT_static_libgfortran = 1105,
  OPT_static_libgo = 1106,
  OPT_static_libstdc__ = 1107,

  OPT_std_c__0x = 1109,
  OPT_std_c__98 = 1110,
  OPT_std_c1x = 1111,

  OPT_std_c90 = 1113,
  OPT_std_c99 = 1114,

  OPT_std_f2003 = 1116,
  OPT_std_f2008 = 1117,
  OPT_std_f2008tr = 1118,
  OPT_std_f95 = 1119,
  OPT_std_gnu = 1120,
  OPT_std_gnu__0x = 1121,
  OPT_std_gnu__98 = 1122,
  OPT_std_gnu1x = 1123,

  OPT_std_gnu90 = 1125,
  OPT_std_gnu99 = 1126,


  OPT_std_iso9899_199409 = 1129,


  OPT_std_legacy = 1132,
  OPT_symbolic = 1133,
  OPT_t = 1134,
  OPT_time = 1135,
  OPT_time_ = 1136,
  OPT_tno_android_cc = 1137,
  OPT_tno_android_ld = 1138,
  OPT_traditional = 1139,
  OPT_traditional_cpp = 1140,
  OPT_trigraphs = 1141,
  OPT_u = 1142,
  OPT_undef = 1143,
  OPT_v = 1144,
  OPT_version = 1145,
  OPT_w = 1146,
  OPT_wrapper = 1147,
  OPT_x = 1148,
  OPT_z = 1149,
  N_OPTS,
  OPT_SPECIAL_unknown,
  OPT_SPECIAL_ignore,
  OPT_SPECIAL_program_name,
  OPT_SPECIAL_input_file
};
# 28 "flags.h" 2




extern const char *const debug_type_names[];

extern void strip_off_ending (char *, int);
extern int base_of_path (const char *path, const char **base_out);


extern unsigned char fast_math_flags_set_p (const struct gcc_options *);
extern unsigned char fast_math_flags_struct_set_p (struct cl_optimization *);
# 48 "flags.h"
extern void set_Wstrict_aliasing (struct gcc_options *opts, int onoff);





extern unsigned char final_insns_dump_p;



extern int flag_permissive;



extern int flag_next_runtime;




struct target_flag_state {




  int x_align_loops_log;
  int x_align_loops_max_skip;
  int x_align_jumps_log;
  int x_align_jumps_max_skip;
  int x_align_labels_log;
  int x_align_labels_max_skip;
  int x_align_functions_log;


  enum excess_precision x_flag_excess_precision;
};

extern struct target_flag_state default_target_flag_state;
# 109 "flags.h"
extern int dump_for_graph;
# 45 "gcc.c" 2
# 1 "opts.h" 1
# 25 "opts.h"
# 1 "vec.h" 1
# 25 "vec.h"
# 1 "statistics.h" 1
# 41 "statistics.h"
struct function;


extern void statistics_early_init (void);
extern void statistics_init (void);
extern void statistics_fini (void);
extern void statistics_fini_pass (void);
extern void statistics_counter_event (struct function *, const char *, int);
extern void statistics_histogram_event (struct function *, const char *, int);
# 26 "vec.h" 2
# 472 "vec.h"
extern void *vec_gc_p_reserve (void *, int );
extern void *vec_gc_p_reserve_exact (void *, int );
extern void *vec_gc_o_reserve (void *, int, size_t, size_t );
extern void *vec_gc_o_reserve_exact (void *, int, size_t, size_t
         );
extern void ggc_free (void *);

extern void *vec_heap_p_reserve (void *, int );
extern void *vec_heap_p_reserve_exact (void *, int );
extern void *vec_heap_o_reserve (void *, int, size_t, size_t );
extern void *vec_heap_o_reserve_exact (void *, int, size_t, size_t
           );
extern void dump_vec_loc_statistics (void);
# 500 "vec.h"
extern void vec_assert_fail (const char *, const char * ,const char *file_,unsigned line_,const char *function_)
     ATTRIBUTE_NORETURN;
# 514 "vec.h"
typedef struct vec_prefix
{
  unsigned num;
  unsigned alloc;
} vec_prefix;
# 1346 "vec.h"
extern void *vec_stack_p_reserve (void *, int );
extern void *vec_stack_p_reserve_exact (void *, int );
extern void *vec_stack_p_reserve_exact_1 (int, void *);
extern void *vec_stack_o_reserve (void *, int, size_t, size_t );
extern void *vec_stack_o_reserve_exact (void *, int, size_t, size_t
      );
extern void vec_stack_free (void *);
# 26 "opts.h" 2


enum cl_var_type {

  CLVC_BOOLEAN,


  CLVC_EQUAL,


  CLVC_BIT_CLEAR,


  CLVC_BIT_SET,



  CLVC_STRING,



  CLVC_ENUM,



  CLVC_DEFER
};

struct cl_option
{

  const char *opt_text;

  const char *help;

  const char *missing_argument_error;

  const char *warn_message;

  const char *alias_arg;

  const char *neg_alias_arg;

  unsigned short alias_target;


  unsigned short back_chain;

  unsigned char opt_len;

  int neg_index;

  unsigned int flags;

  unsigned int cl_disabled : 1;



  unsigned int cl_separate_nargs : 2;

  unsigned int cl_separate_alias : 1;

  unsigned int cl_negative_alias : 1;

  unsigned int cl_no_driver_arg : 1;

  unsigned int cl_reject_driver : 1;

  unsigned int cl_reject_negative : 1;

  unsigned int cl_missing_ok : 1;

  unsigned int cl_uinteger : 1;

  unsigned int cl_host_wide_int : 1;

  unsigned int cl_tolower : 1;

  unsigned int cl_report : 1;


  unsigned short flag_var_offset;


  unsigned short var_enum;

  enum cl_var_type var_type;

  long long var_value;
};



struct cl_option_state {
  const void *data;
  size_t size;
  char ch;
};

extern const struct cl_option cl_options[];
extern const unsigned int cl_options_count;
extern const char *const lang_names[];
extern const unsigned int cl_lang_count;
# 155 "opts.h"
struct cl_enum_arg
{

  const char *arg;


  int value;


  unsigned int flags;
};



struct cl_enum
{


  const char *help;



  const char *unknown_error;


  const struct cl_enum_arg *values;


  size_t var_size;


  void (*set) (void *var, int value);


  int (*get) (const void *var);
};

extern const struct cl_enum cl_enums[];
extern const unsigned int cl_enums_count;
# 210 "opts.h"
struct cl_decoded_option
{


  size_t opt_index;


  const char *warn_message;



  const char *arg;





  const char *orig_option_with_args_text;





  const char *canonical_option[4];



  size_t canonical_option_num_elements;




  int value;


  int errors;
};




typedef struct
{


  size_t opt_index;
  const char *arg;
  int value;
} cl_deferred_option;
typedef struct VEC_cl_deferred_option_base { struct vec_prefix prefix; cl_deferred_option vec[1]; } VEC_cl_deferred_option_base; typedef struct VEC_cl_deferred_option_none { VEC_cl_deferred_option_base base; } VEC_cl_deferred_option_none; static inline unsigned VEC_cl_deferred_option_base_length (const VEC_cl_deferred_option_base *vec_) { return vec_ ? vec_->prefix.num : 0; } static inline cl_deferred_option *VEC_cl_deferred_option_base_last (VEC_cl_deferred_option_base *vec_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_ && vec_->prefix.num) ? 0 : (vec_assert_fail ("last","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); return &vec_->vec[vec_->prefix.num - 1]; } static inline cl_deferred_option *VEC_cl_deferred_option_base_index (VEC_cl_deferred_option_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_ && ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("index","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); return &vec_->vec[ix_]; } static inline int VEC_cl_deferred_option_base_iterate (VEC_cl_deferred_option_base *vec_, unsigned ix_, cl_deferred_option **ptr) { if (vec_ && ix_ < vec_->prefix.num) { *ptr = &vec_->vec[ix_]; return 1; } else { *ptr = 0; return 0; } } static inline size_t VEC_cl_deferred_option_base_embedded_size (int alloc_) { return __builtin_offsetof (VEC_cl_deferred_option_base, vec) + alloc_ * sizeof(cl_deferred_option); } static inline void VEC_cl_deferred_option_base_embedded_init (VEC_cl_deferred_option_base *vec_, int alloc_) { vec_->prefix.num = 0; vec_->prefix.alloc = alloc_; } static inline int VEC_cl_deferred_option_base_space (VEC_cl_deferred_option_base *vec_, int alloc_ ,const char *file_,unsigned line_,const char *function_) { (void)((alloc_ >= 0) ? 0 : (vec_assert_fail ("space","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); return vec_ ? vec_->prefix.alloc - vec_->prefix.num >= (unsigned)alloc_ : !alloc_; } static inline void VEC_cl_deferred_option_base_splice (VEC_cl_deferred_option_base *dst_, VEC_cl_deferred_option_base *src_ ,const char *file_,unsigned line_,const char *function_) { if (src_) { unsigned len_ = src_->prefix.num; (void)((dst_->prefix.num + len_ <= dst_->prefix.alloc) ? 0 : (vec_assert_fail ("splice","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); memcpy (&dst_->vec[dst_->prefix.num], &src_->vec[0], len_ * sizeof (cl_deferred_option)); dst_->prefix.num += len_; } } static inline cl_deferred_option *VEC_cl_deferred_option_base_quick_push (VEC_cl_deferred_option_base *vec_, const cl_deferred_option *obj_ ,const char *file_,unsigned line_,const char *function_) { cl_deferred_option *slot_; (void)((vec_->prefix.num < vec_->prefix.alloc) ? 0 : (vec_assert_fail ("push","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[vec_->prefix.num++]; if (obj_) *slot_ = *obj_; return slot_; } static inline void VEC_cl_deferred_option_base_pop (VEC_cl_deferred_option_base *vec_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_->prefix.num) ? 0 : (vec_assert_fail ("pop","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); --vec_->prefix.num; } static inline void VEC_cl_deferred_option_base_truncate (VEC_cl_deferred_option_base *vec_, unsigned size_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_ ? vec_->prefix.num >= size_ : !size_) ? 0 : (vec_assert_fail ("truncate","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); if (vec_) vec_->prefix.num = size_; } static inline cl_deferred_option *VEC_cl_deferred_option_base_replace (VEC_cl_deferred_option_base *vec_, unsigned ix_, const cl_deferred_option *obj_ ,const char *file_,unsigned line_,const char *function_) { cl_deferred_option *slot_; (void)((ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("replace","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; if (obj_) *slot_ = *obj_; return slot_; } static inline cl_deferred_option *VEC_cl_deferred_option_base_quick_insert (VEC_cl_deferred_option_base *vec_, unsigned ix_, const cl_deferred_option *obj_ ,const char *file_,unsigned line_,const char *function_) { cl_deferred_option *slot_; (void)((vec_->prefix.num < vec_->prefix.alloc) ? 0 : (vec_assert_fail ("insert","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); (void)((ix_ <= vec_->prefix.num) ? 0 : (vec_assert_fail ("insert","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (cl_deferred_option)); if (obj_) *slot_ = *obj_; return slot_; } static inline void VEC_cl_deferred_option_base_ordered_remove (VEC_cl_deferred_option_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) { cl_deferred_option *slot_; (void)((ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("remove","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; memmove (slot_, slot_ + 1, (--vec_->prefix.num - ix_) * sizeof (cl_deferred_option)); } static inline void VEC_cl_deferred_option_base_unordered_remove (VEC_cl_deferred_option_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) { (void)((ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("remove","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); vec_->vec[ix_] = vec_->vec[--vec_->prefix.num]; } static inline void VEC_cl_deferred_option_base_block_remove (VEC_cl_deferred_option_base *vec_, unsigned ix_, unsigned len_ ,const char *file_,unsigned line_,const char *function_) { cl_deferred_option *slot_; (void)((ix_ + len_ <= vec_->prefix.num) ? 0 : (vec_assert_fail ("block_remove","VEC(cl_deferred_option,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; vec_->prefix.num -= len_; memmove (slot_, slot_ + len_, (vec_->prefix.num - ix_) * sizeof (cl_deferred_option)); } static inline cl_deferred_option *VEC_cl_deferred_option_base_address (VEC_cl_deferred_option_base *vec_) { return vec_ ? vec_->vec : 0; } static inline unsigned VEC_cl_deferred_option_base_lower_bound (VEC_cl_deferred_option_base *vec_, const cl_deferred_option *obj_, unsigned char (*lessthan_)(const cl_deferred_option *, const cl_deferred_option *) ,const char *file_,unsigned line_,const char *function_) { unsigned int len_ = VEC_cl_deferred_option_base_length (vec_); unsigned int half_, middle_; unsigned int first_ = 0; while (len_ > 0) { cl_deferred_option *middle_elem_; half_ = len_ >> 1; middle_ = first_; middle_ += half_; middle_elem_ = VEC_cl_deferred_option_base_index (vec_, middle_ ,file_,line_,function_); if (lessthan_ (middle_elem_, obj_)) { first_ = middle_; ++first_; len_ = len_ - half_ - 1; } else len_ = half_; } return first_; } struct vec_swallow_trailing_semi;
typedef struct VEC_cl_deferred_option_heap { VEC_cl_deferred_option_base base; } VEC_cl_deferred_option_heap; static inline VEC_cl_deferred_option_heap *VEC_cl_deferred_option_heap_alloc (int alloc_ ) { return (VEC_cl_deferred_option_heap *) vec_heap_o_reserve_exact (((void *)0), alloc_, __builtin_offsetof (VEC_cl_deferred_option_heap, base.vec), sizeof (cl_deferred_option) ); } static inline VEC_cl_deferred_option_heap *VEC_cl_deferred_option_heap_copy (VEC_cl_deferred_option_base *vec_ ) { size_t len_ = vec_ ? vec_->prefix.num : 0; VEC_cl_deferred_option_heap *new_vec_ = ((void *)0); if (len_) { new_vec_ = (VEC_cl_deferred_option_heap *)(vec_heap_o_reserve_exact (((void *)0), len_, __builtin_offsetof (VEC_cl_deferred_option_heap, base.vec), sizeof (cl_deferred_option) )); new_vec_->base.prefix.num = len_; memcpy (new_vec_->base.vec, vec_->vec, sizeof (cl_deferred_option) * len_); } return new_vec_; } static inline void VEC_cl_deferred_option_heap_free (VEC_cl_deferred_option_heap **vec_) { if (*vec_) (free) (*vec_); *vec_ = ((void *)0); } static inline int VEC_cl_deferred_option_heap_reserve (VEC_cl_deferred_option_heap **vec_, int alloc_ ,const char *file_,unsigned line_,const char *function_ ) { int extend = !VEC_cl_deferred_option_base_space (((*vec_) ? &(*vec_)->base : 0), alloc_ ,file_,line_,function_); if (extend) *vec_ = (VEC_cl_deferred_option_heap *) vec_heap_o_reserve (*vec_, alloc_, __builtin_offsetof (VEC_cl_deferred_option_heap, base.vec), sizeof (cl_deferred_option) ); return extend; } static inline int VEC_cl_deferred_option_heap_reserve_exact (VEC_cl_deferred_option_heap **vec_, int alloc_ ,const char *file_,unsigned line_,const char *function_ ) { int extend = !VEC_cl_deferred_option_base_space (((*vec_) ? &(*vec_)->base : 0), alloc_ ,file_,line_,function_); if (extend) *vec_ = (VEC_cl_deferred_option_heap *) vec_heap_o_reserve_exact (*vec_, alloc_, __builtin_offsetof (VEC_cl_deferred_option_heap, base.vec), sizeof (cl_deferred_option) ); return extend; } static inline void VEC_cl_deferred_option_heap_safe_grow (VEC_cl_deferred_option_heap **vec_, int size_ ,const char *file_,unsigned line_,const char *function_ ) { (void)((size_ >= 0 && VEC_cl_deferred_option_base_length ((*vec_) ? &(*vec_)->base : 0) <= (unsigned)size_) ? 0 : (vec_assert_fail ("grow","VEC(cl_deferred_option,heap)" ,file_,line_,function_), 0)); VEC_cl_deferred_option_heap_reserve_exact (vec_, size_ - (int)(*vec_ ? ((*vec_) ? &(*vec_)->base : 0)->prefix.num : 0) ,file_,line_,function_ ); ((*vec_) ? &(*vec_)->base : 0)->prefix.num = size_; } static inline void VEC_cl_deferred_option_heap_safe_grow_cleared (VEC_cl_deferred_option_heap **vec_, int size_ ,const char *file_,unsigned line_,const char *function_ ) { int oldsize = VEC_cl_deferred_option_base_length ((*vec_) ? &(*vec_)->base : 0); VEC_cl_deferred_option_heap_safe_grow (vec_, size_ ,file_,line_,function_ ); memset (&(VEC_cl_deferred_option_base_address ((*vec_) ? &(*vec_)->base : 0))[oldsize], 0, sizeof (cl_deferred_option) * (size_ - oldsize)); } static inline void VEC_cl_deferred_option_heap_safe_splice (VEC_cl_deferred_option_heap **dst_, VEC_cl_deferred_option_base *src_ ,const char *file_,unsigned line_,const char *function_ ) { if (src_) { VEC_cl_deferred_option_heap_reserve_exact (dst_, src_->prefix.num ,file_,line_,function_ ); VEC_cl_deferred_option_base_splice (((*dst_) ? &(*dst_)->base : 0), src_ ,file_,line_,function_); } } static inline cl_deferred_option *VEC_cl_deferred_option_heap_safe_push (VEC_cl_deferred_option_heap **vec_, const cl_deferred_option *obj_ ,const char *file_,unsigned line_,const char *function_ ) { VEC_cl_deferred_option_heap_reserve (vec_, 1 ,file_,line_,function_ ); return VEC_cl_deferred_option_base_quick_push (((*vec_) ? &(*vec_)->base : 0), obj_ ,file_,line_,function_); } static inline cl_deferred_option *VEC_cl_deferred_option_heap_safe_insert (VEC_cl_deferred_option_heap **vec_, unsigned ix_, const cl_deferred_option *obj_ ,const char *file_,unsigned line_,const char *function_ ) { VEC_cl_deferred_option_heap_reserve (vec_, 1 ,file_,line_,function_ ); return VEC_cl_deferred_option_base_quick_insert (((*vec_) ? &(*vec_)->base : 0), ix_, obj_ ,file_,line_,function_); } struct vec_swallow_trailing_semi;



struct cl_option_handler_func
{

  unsigned char (*handler) (struct gcc_options *opts,
     struct gcc_options *opts_set,
     const struct cl_decoded_option *decoded,
     unsigned int lang_mask, int kind, location_t loc,
     const struct cl_option_handlers *handlers,
     diagnostic_context *dc);



  unsigned int mask;
};



struct cl_option_handlers
{




  unsigned char (*unknown_option_callback) (const struct cl_decoded_option *decoded);



  void (*wrong_lang_callback) (const struct cl_decoded_option *decoded,
          unsigned int lang_mask);


  void (*post_handling_callback) (const struct cl_decoded_option *decoded,
      unsigned int mask);


  size_t num_handlers;


  struct cl_option_handler_func handlers[3];
};



extern const char **in_fnames;



extern unsigned num_in_fnames;

size_t find_opt (const char *input, unsigned int lang_mask);
extern int integral_argument (const char *arg);
extern unsigned char enum_value_to_arg (const struct cl_enum_arg *enum_args,
          const char **argp, int value,
          unsigned int lang_mask);
extern void decode_cmdline_options_to_array (unsigned int argc,
          const char **argv,
          unsigned int lang_mask,
          struct cl_decoded_option **decoded_options,
          unsigned int *decoded_options_count);
extern void init_options_once (void);
extern void init_options_struct (struct gcc_options *opts,
     struct gcc_options *opts_set);
extern void decode_cmdline_options_to_array_default_mask (unsigned int argc,
         const char **argv,
         struct cl_decoded_option **decoded_options,
         unsigned int *decoded_options_count);
extern void set_default_handlers (struct cl_option_handlers *handlers);
extern void decode_options (struct gcc_options *opts,
       struct gcc_options *opts_set,
       struct cl_decoded_option *decoded_options,
       unsigned int decoded_options_count,
       location_t loc,
       diagnostic_context *dc);
extern int option_enabled (int opt_idx, void *opts);
extern unsigned char get_option_state (struct gcc_options *, int,
         struct cl_option_state *);
extern void set_option (struct gcc_options *opts,
   struct gcc_options *opts_set,
   int opt_index, int value, const char *arg, int kind,
   location_t loc, diagnostic_context *dc);
extern void *option_flag_var (int opt_index, struct gcc_options *opts);
unsigned char handle_generated_option (struct gcc_options *opts,
         struct gcc_options *opts_set,
         size_t opt_index, const char *arg, int value,
         unsigned int lang_mask, int kind, location_t loc,
         const struct cl_option_handlers *handlers,
         diagnostic_context *dc);
void generate_option (size_t opt_index, const char *arg, int value,
        unsigned int lang_mask,
        struct cl_decoded_option *decoded);
void generate_option_input_file (const char *file,
     struct cl_decoded_option *decoded);
extern void read_cmdline_option (struct gcc_options *opts,
     struct gcc_options *opts_set,
     struct cl_decoded_option *decoded,
     location_t loc,
     unsigned int lang_mask,
     const struct cl_option_handlers *handlers,
     diagnostic_context *dc);
extern void control_warning_option (unsigned int opt_index, int kind,
        unsigned char imply, location_t loc,
        unsigned int lang_mask,
        const struct cl_option_handlers *handlers,
        struct gcc_options *opts,
        struct gcc_options *opts_set,
        diagnostic_context *dc);
extern void print_ignored_options (void);
extern void handle_common_deferred_options (void);
extern unsigned char common_handle_option (struct gcc_options *opts,
      struct gcc_options *opts_set,
      const struct cl_decoded_option *decoded,
      unsigned int lang_mask, int kind,
      location_t loc,
      const struct cl_option_handlers *handlers,
      diagnostic_context *dc);
extern unsigned char target_handle_option (struct gcc_options *opts,
      struct gcc_options *opts_set,
      const struct cl_decoded_option *decoded,
      unsigned int lang_mask, int kind,
      location_t loc,
      const struct cl_option_handlers *handlers,
      diagnostic_context *dc);
extern void finish_options (struct gcc_options *opts,
       struct gcc_options *opts_set,
       location_t loc);
extern void default_options_optimization (struct gcc_options *opts,
       struct gcc_options *opts_set,
       struct cl_decoded_option *decoded_options,
       unsigned int decoded_options_count,
       location_t loc,
       unsigned int lang_mask,
       const struct cl_option_handlers *handlers,
       diagnostic_context *dc);
extern void set_struct_debug_option (struct gcc_options *opts,
         location_t loc,
         const char *value);
extern unsigned char opt_enum_arg_to_value (size_t opt_index, const char *arg,
       int *value, unsigned int lang_mask);
# 46 "gcc.c" 2
# 1 "params.h" 1
# 42 "params.h"
typedef struct param_info
{


  const char *const option;


  int default_value;


  int min_value;


  int max_value;


  const char *const help;
} param_info;




extern param_info *compiler_params;


extern size_t get_num_compiler_params (void);



extern void add_params (const param_info params[], size_t n);





extern void set_param_value (const char *name, int value,
        int *params, int *params_set);




typedef enum compiler_param
{


# 1 "params.def" 1
# 44 "params.def"
PARAM_PREDICTABLE_BRANCH_OUTCOME,
# 61 "params.def"
PARAM_MAX_INLINE_INSNS_SINGLE,
# 73 "params.def"
PARAM_MAX_INLINE_INSNS_AUTO,




PARAM_MAX_INLINE_INSNS_RECURSIVE,




PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO,




PARAM_MAX_INLINE_RECURSIVE_DEPTH,




PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO,




PARAM_MIN_INLINE_RECURSIVE_PROBABILITY,







PARAM_EARLY_INLINER_MAX_ITERATIONS,





PARAM_COMDAT_SHARING_PROBABILITY,





PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY,






PARAM_MAX_VARIABLE_EXPANSIONS,





PARAM_MIN_VECT_LOOP_BOUND,
# 142 "params.def"
PARAM_MAX_DELAY_SLOT_INSN_SEARCH,
# 153 "params.def"
PARAM_MAX_DELAY_SLOT_LIVE_SEARCH,
# 163 "params.def"
PARAM_MAX_PENDING_LIST_LENGTH,




PARAM_LARGE_FUNCTION_INSNS,



PARAM_LARGE_FUNCTION_GROWTH,



PARAM_LARGE_UNIT_INSNS,



PARAM_INLINE_UNIT_GROWTH,



PARAM_IPCP_UNIT_GROWTH,



PARAM_EARLY_INLINING_INSNS,



PARAM_LARGE_STACK_FRAME,



PARAM_STACK_FRAME_GROWTH,






PARAM_MAX_GCSE_MEMORY,






PARAM_MAX_GCSE_INSERTION_RATIO,
# 221 "params.def"
PARAM_GCSE_AFTER_RELOAD_PARTIAL_FRACTION,






PARAM_GCSE_AFTER_RELOAD_CRITICAL_FRACTION,







PARAM_GCSE_COST_DISTANCE_RATIO,





PARAM_GCSE_UNRESTRICTED_COST,







PARAM_MAX_HOIST_DEPTH,
# 262 "params.def"
PARAM_MAX_UNROLLED_INSNS,





PARAM_MAX_AVERAGE_UNROLLED_INSNS,




PARAM_MAX_UNROLL_TIMES,




PARAM_MAX_PEELED_INSNS,




PARAM_MAX_PEEL_TIMES,




PARAM_MAX_COMPLETELY_PEELED_INSNS,




PARAM_MAX_COMPLETELY_PEEL_TIMES,




PARAM_MAX_ONCE_PEELED_INSNS,




PARAM_MAX_UNROLL_ITERATIONS,





PARAM_MAX_UNSWITCH_INSNS,




PARAM_MAX_UNSWITCH_LEVEL,






PARAM_MAX_ITERATIONS_TO_TRACK,





PARAM_MAX_ITERATIONS_COMPUTATION_COST,





PARAM_SMS_MAX_II_FACTOR,




PARAM_SMS_MIN_SC,



PARAM_SMS_DFA_HISTORY,



PARAM_SMS_LOOP_AVERAGE_COUNT_THRESHOLD,




HOT_BB_COUNT_FRACTION,



HOT_BB_FREQUENCY_FRACTION,




PARAM_ALIGN_THRESHOLD,




PARAM_ALIGN_LOOP_ITERATIONS,
# 381 "params.def"
PARAM_MAX_PREDICTED_ITERATIONS,



TRACER_DYNAMIC_COVERAGE_FEEDBACK,



TRACER_DYNAMIC_COVERAGE,



TRACER_MAX_CODE_GROWTH,



TRACER_MIN_BRANCH_RATIO,



TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK,



TRACER_MIN_BRANCH_PROBABILITY,





PARAM_MAX_CROSSJUMP_EDGES,





PARAM_MIN_CROSSJUMP_INSNS,





PARAM_MAX_GROW_COPY_BB_INSNS,





PARAM_MAX_GOTO_DUPLICATION_INSNS,





PARAM_MAX_CSE_PATH_LENGTH,



PARAM_MAX_CSE_INSNS,






PARAM_LIM_EXPENSIVE,
# 455 "params.def"
PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND,







PARAM_IV_MAX_CONSIDERED_USES,







PARAM_IV_ALWAYS_PRUNE_CAND_SET_BOUND,




PARAM_SCEV_MAX_EXPR_SIZE,




PARAM_SCEV_MAX_EXPR_COMPLEXITY,




PARAM_OMEGA_MAX_VARS,




PARAM_OMEGA_MAX_GEQS,




PARAM_OMEGA_MAX_EQS,




PARAM_OMEGA_MAX_WILD_CARDS,




PARAM_OMEGA_HASH_TABLE_SIZE,




PARAM_OMEGA_MAX_KEYS,




PARAM_OMEGA_ELIMINATE_REDUNDANT_CONSTRAINTS,




PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS,




PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS,




PARAM_MAX_CSELIB_MEMORY_LOCATIONS,
# 544 "params.def"
GGC_MIN_EXPAND,




GGC_MIN_HEAPSIZE,







PARAM_MAX_RELOAD_SEARCH_INSNS,




PARAM_MAX_SCHED_REGION_BLOCKS,




PARAM_MAX_SCHED_REGION_INSNS,




PARAM_MAX_PIPELINE_REGION_BLOCKS,




PARAM_MAX_PIPELINE_REGION_INSNS,




PARAM_MIN_SPEC_PROB,




PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS,




PARAM_MAX_SCHED_INSN_CONFLICT_DELAY,




PARAM_SCHED_SPEC_PROB_CUTOFF,




PARAM_SELSCHED_MAX_LOOKAHEAD,




PARAM_SELSCHED_MAX_SCHED_TIMES,




PARAM_SELSCHED_INSNS_TO_RENAME,




PARAM_SCHED_MEM_TRUE_DEP_COST,




PARAM_MAX_LAST_VALUE_RTL,







PARAM_INTEGER_SHARE_LIMIT,
# 649 "params.def"
PARAM_MIN_VIRTUAL_MAPPINGS,




PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO,




PARAM_SSP_BUFFER_SIZE,
# 677 "params.def"
PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS,
# 686 "params.def"
PARAM_MAX_FIELDS_FOR_FIELD_SENSITIVE,




PARAM_MAX_SCHED_READY_INSNS,





PARAM_MAX_DSE_ACTIVE_LOCAL_STORES,
# 707 "params.def"
PARAM_PREFETCH_LATENCY,






PARAM_SIMULTANEOUS_PREFETCHES,






PARAM_L1_CACHE_SIZE,






PARAM_L1_CACHE_LINE_SIZE,






PARAM_L2_CACHE_SIZE,
# 746 "params.def"
PARAM_USE_CANONICAL_TYPES,




PARAM_MAX_PARTIAL_ANTIC_LENGTH,
# 761 "params.def"
PARAM_SCCVN_MAX_SCC_SIZE,




PARAM_IRA_MAX_LOOPS_NUM,




PARAM_IRA_MAX_CONFLICT_TABLE_SIZE,




PARAM_IRA_LOOP_RESERVED_REGS,







PARAM_SWITCH_CONVERSION_BRANCH_RATIO,







PARAM_LOOP_BLOCK_TILE_SIZE,






PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS,






PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION,






PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP,





PARAM_SLP_MAX_INSNS_IN_BB,




PARAM_MIN_INSN_TO_PREFETCH_RATIO,





PARAM_PREFETCH_MIN_INSN_TO_MEM_RATIO,






PARAM_MAX_VARTRACK_SIZE,







PARAM_MAX_VARTRACK_EXPR_DEPTH,






PARAM_MIN_NONDEBUG_INSN_UID,




PARAM_IPA_SRA_PTR_GROWTH_FACTOR,





PARAM_IPA_CP_VALUE_LIST_SIZE,





PARAM_IPA_CP_EVAL_THRESHOLD,







PARAM_LTO_PARTITIONS,




MIN_PARTITION_SIZE,






CXX_MAX_NAMESPACES_FOR_DIAGNOSTIC_HELP,






PARAM_MAX_STORES_TO_SINK,







PARAM_CASE_VALUES_THRESHOLD,







PARAM_ALLOW_STORE_DATA_RACES,





PARAM_TREE_REASSOC_WIDTH,
# 88 "params.h" 2

  LAST_PARAM
} compiler_param;
# 100 "params.h"
extern void maybe_set_param_value (compiler_param num, int value,
       int *params, int *params_set);




extern void set_default_param_value (compiler_param num, int value);




extern void global_init_params (void);



extern void finish_params (void);



extern int default_param_value (compiler_param num);



extern void init_param_values (int *params);
# 47 "gcc.c" 2
# 70 "gcc.c"
static const char dir_separator_str[] = { '/', 0 };
# 83 "gcc.c"
int is_cpp_driver;


static unsigned char at_file_supplied;


# 1 "configargs.h" 1

static const char configuration_arguments[] = "";
static const char thread_model[] = "posix";

static const struct {
  const char *name, *value;
} configure_default_options[] = { { "cpu", "generic" }, { "arch", "pentiumpro" } };
# 90 "gcc.c" 2




static int print_help_list;



static int print_version;






static int verbose_only_flag;



static int print_subprocess_help;



FILE *report_times_to_file = ((void *)0);







static const char *target_system_root = 0;




static int target_system_root_changed;



static const char *target_sysroot_suffix = 0;



static const char *target_sysroot_hdrs_suffix = 0;




static enum save_temps {
  SAVE_TEMPS_NONE,
  SAVE_TEMPS_CWD,
  SAVE_TEMPS_OBJ
} save_temps_flag;


static char *save_temps_prefix = 0;
static size_t save_temps_length = 0;



static const char *compiler_version;



static const char *const spec_version = DEFAULT_TARGET_VERSION;



static const char *spec_machine = DEFAULT_TARGET_MACHINE;







static const char *cross_compile = "0";




static int greatest_status = 1;



static struct obstack obstack;






static struct obstack collect_obstack;


struct path_prefix;
struct prefix_list;

static void init_spec (void);
static void store_arg (const char *, int, int);
static void insert_wrapper (const char *);
static char *load_specs (const char *);
static void read_specs (const char *, int);
static void set_spec (const char *, const char *);
static struct compiler *lookup_compiler (const char *, size_t, const char *);
static char *build_search_list (const struct path_prefix *, const char *,
    unsigned char, unsigned char);
static void xputenv (const char *);
static void putenv_from_prefixes (const struct path_prefix *, const char *,
      unsigned char);
static int access_check (const char *, int);
static char *find_a_file (const struct path_prefix *, const char *, int, unsigned char);
static void add_prefix (struct path_prefix *, const char *, const char *,
   int, int, int);
static void add_sysrooted_prefix (struct path_prefix *, const char *,
      const char *, int, int, int);
static char *skip_whitespace (char *);
static void delete_if_ordinary (const char *);
static void delete_temp_files (void);
static void delete_failure_queue (void);
static void clear_failure_queue (void);
static int check_live_switch (int, int);
static const char *handle_braces (const char *);
static inline unsigned char input_suffix_matches (const char *, const char *);
static inline unsigned char switch_matches (const char *, const char *, int);
static inline void mark_matching_switches (const char *, const char *, int);
static inline void process_marked_switches (void);
static const char *process_brace_body (const char *, const char *, const char *, int, int);
static const struct spec_function *lookup_spec_function (const char *);
static const char *eval_spec_function (const char *, const char *);
static const char *handle_spec_function (const char *);
static char *save_string (const char *, int);
static void set_collect_gcc_options (void);
static int do_spec_1 (const char *, int, const char *);
static int do_spec_2 (const char *);
static void do_option_spec (const char *, const char *);
static void do_self_spec (const char *);
static const char *find_file (const char *);
static int is_directory (const char *, unsigned char);
static const char *validate_switches (const char *);
static void validate_all_switches (void);
static inline void validate_switches_from_spec (const char *);
static void give_switch (int, int);
static int used_arg (const char *, int);
static int default_arg (const char *, int);
static void set_multilib_dir (void);
static void print_multilib_info (void);
static void perror_with_name (const char *);
static void display_help (void);
static void add_preprocessor_option (const char *, int);
static void add_assembler_option (const char *, int);
static void add_linker_option (const char *, int);
static void process_command (unsigned int, struct cl_decoded_option *);
static int execute (void);
static void alloc_args (void);
static void clear_args (void);
static void fatal_signal (int);
# 256 "gcc.c"
static const char *getenv_spec_function (int, const char **);
static const char *if_exists_spec_function (int, const char **);
static const char *if_exists_else_spec_function (int, const char **);
static const char *replace_outfile_spec_function (int, const char **);
static const char *remove_outfile_spec_function (int, const char **);
static const char *version_compare_spec_function (int, const char **);
static const char *include_spec_function (int, const char **);
static const char *find_file_spec_function (int, const char **);
static const char *find_plugindir_spec_function (int, const char **);
static const char *print_asm_header_spec_function (int, const char **);
static const char *compare_debug_dump_opt_spec_function (int, const char **);
static const char *compare_debug_self_opt_spec_function (int, const char **);
static const char *compare_debug_auxbase_opt_spec_function (int, const char **);
static const char *pass_through_libs_spec_func (int, const char **);
# 705 "gcc.c"
static const char *asm_debug;
static const char *cpp_spec = "";
static const char *cc1_spec = "";
static const char *cc1plus_spec = "";
static const char *link_gcc_c_sequence_spec = "%G %L %G";
static const char *link_ssp_spec = "%{fstack-protector:}";
static const char *asm_spec = "";
static const char *asm_final_spec = "";
static const char *link_spec = "";
static const char *lib_spec = "%{!shared:%{g*:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}";
static const char *mfwrap_spec = " %{static: %{fmudflap|fmudflapth:  --wrap=malloc --wrap=free --wrap=calloc --wrap=realloc --wrap=mmap --wrap=mmap64 --wrap=munmap --wrap=alloca} %{fmudflapth: --wrap=pthread_create}} %{fmudflap|fmudflapth: --wrap=main}";
static const char *mflib_spec = "%{fmudflap|fmudflapth: -export-dynamic}";
static const char *link_gomp_spec = "";
static const char *libgcc_spec = "-lgcc";
static const char *endfile_spec = "";
static const char *startfile_spec = "%{!shared:%{pg:gcrt0%O%s}%{!pg:%{p:mcrt0%O%s}%{!p:crt0%O%s}}}";
static const char *linker_name_spec = "collect2";
static const char *linker_plugin_file_spec = "";
static const char *lto_wrapper_spec = "";
static const char *lto_gcc_spec = "";
static const char *link_command_spec = "%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:    %(linker) " "%{fuse-linker-plugin:    %e-fuse-linker-plugin is not supported in this configuration}" "%{flto|flto=*:%<fcompare-debug*}     %{flto} %{flto=*} %l " "%{pie:} " "%X %{o*} %{e*} %{N} %{n} %{r}    %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}}    %{static:} %{L*} %(mfwrap) %(link_libgcc) %o    %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)}    %(mflib) " " %{fsplit-stack: --wrap=pthread_create}" "    %{fprofile-arcs|fprofile-generate*|coverage:-lgcov}    %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}    %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}";
static const char *link_libgcc_spec = "%D";
static const char *startfile_prefix_spec = "";
static const char *sysroot_spec = "--sysroot=%R";
static const char *sysroot_suffix_spec = "";
static const char *sysroot_hdrs_suffix_spec = "";
static const char *self_spec = "";
# 742 "gcc.c"
static const char *trad_capable_cpp =
"cc1 -E %{traditional|traditional-cpp:-traditional-cpp}";




static const char *cpp_unique_options =
"%{!Q:-quiet} %{nostdinc*} %{C} %{CC} %{v} %{I*&F*} %{P} %I %{MD:-MD %{!o:%b.d}%{o*:%.d%*}} %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}} %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*} %{!E:%{!M:%{!MM:%{!MT:%{!MQ:%{MD|MMD:%{o*:-MQ %*}}}}}}} %{remap} %{g3|ggdb3|gstabs3|gcoff3|gxcoff3|gvms3:-dD} %{!iplugindir*:%{fplugin*:%:find-plugindir()}} %{H} %C %{D*&U*&A*} %{i*} %Z %i %{fmudflap:-D_MUDFLAP -include mf-runtime.h} %{fmudflapth:-D_MUDFLAP -D_MUDFLAPTH -include mf-runtime.h} %{E|M|MM:%W{o*}}";
# 766 "gcc.c"
static const char *cpp_options =
"%(cpp_unique_options) %1 %{m*} %{std*&ansi&trigraphs} %{W*&pedantic*} %{w} %{f*} %{g*:%{!g0:%{g*} %{!fno-working-directory:-fworking-directory}}} %{O*} %{undef} %{save-temps*:-fpch-preprocess}";





static const char *cpp_debug_options = "%{d*}";


static const char *cc1_options =
"%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}} %{!iplugindir*:%{fplugin*:%:find-plugindir()}} %1 %{!Q:-quiet} %{!dumpbase:-dumpbase %B} %{d*} %{m*} %{aux-info*} %{fcompare-debug-second:%:compare-debug-auxbase-opt(%b)}  %{!fcompare-debug-second:%{c|S:%{o*:-auxbase-strip %*}%{!o*:-auxbase %b}}}%{!c:%{!S:-auxbase %b}}  %{g*} %{O*} %{W*&pedantic*} %{w} %{std*&ansi&trigraphs} %{v:-version} %{pg:-p} %{p} %{f*} %{undef} %{Qn:-fno-ident} %{Qy:} %{-help:--help} %{-target-help:--target-help} %{-version:--version} %{-help=*:--help=%*} %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}} %{fsyntax-only:-o %j} %{-param*} %{fmudflap|fmudflapth:-fno-builtin -fno-merge-constants} %{coverage:-fprofile-arcs -ftest-coverage}";
# 793 "gcc.c"
static const char *asm_options =
"%{-target-help:%:print-asm-header()} "





"%a %Y %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}";

static const char *invoke_as =






"%{!fwpa:   %{fcompare-debug=*|fdump-final-insns=*:%:compare-debug-dump-opt()}   %{!S:-o %|.s |\n as %(asm_options) %m.s %A }  }";
# 818 "gcc.c"
static struct obstack multilib_obstack;
static const char *multilib_select;
static const char *multilib_matches;
static const char *multilib_defaults;
static const char *multilib_exclusions;







static const char *const multilib_defaults_raw[] = { "" };
# 842 "gcc.c"
static const char *const driver_self_specs[] = {
  "%{fdump-final-insns:-fdump-final-insns=.} %<fdump-final-insns",
  "", CONFIGURE_SPECS, "%{fopenmp|ftree-parallelize-loops=*: -pthread}"
};





struct default_spec
{
  const char *name;
  const char *spec;
};

static const struct default_spec
  option_default_specs[] = { { "", "" } };

struct user_specs
{
  struct user_specs *next;
  const char *filename;
};

static struct user_specs *user_specs_head, *user_specs_tail;




struct compiler
{
  const char *suffix;


  const char *spec;

  const char *cpp_spec;


  const int combinable;

  const int needs_preprocessing;

};
# 896 "gcc.c"
static struct compiler *compilers;



static int n_compilers;



static const struct compiler default_compilers[] =
{




  {".m", "#Objective-C", 0, 0, 0}, {".mi", "#Objective-C", 0, 0, 0},
  {".mm", "#Objective-C++", 0, 0, 0}, {".M", "#Objective-C++", 0, 0, 0},
  {".mii", "#Objective-C++", 0, 0, 0},
  {".cc", "#C++", 0, 0, 0}, {".cxx", "#C++", 0, 0, 0},
  {".cpp", "#C++", 0, 0, 0}, {".cp", "#C++", 0, 0, 0},
  {".c++", "#C++", 0, 0, 0}, {".C", "#C++", 0, 0, 0},
  {".CPP", "#C++", 0, 0, 0}, {".ii", "#C++", 0, 0, 0},
  {".ads", "#Ada", 0, 0, 0}, {".adb", "#Ada", 0, 0, 0},
  {".f", "#Fortran", 0, 0, 0}, {".F", "#Fortran", 0, 0, 0},
  {".for", "#Fortran", 0, 0, 0}, {".FOR", "#Fortran", 0, 0, 0},
  {".ftn", "#Fortran", 0, 0, 0}, {".FTN", "#Fortran", 0, 0, 0},
  {".fpp", "#Fortran", 0, 0, 0}, {".FPP", "#Fortran", 0, 0, 0},
  {".f90", "#Fortran", 0, 0, 0}, {".F90", "#Fortran", 0, 0, 0},
  {".f95", "#Fortran", 0, 0, 0}, {".F95", "#Fortran", 0, 0, 0},
  {".f03", "#Fortran", 0, 0, 0}, {".F03", "#Fortran", 0, 0, 0},
  {".f08", "#Fortran", 0, 0, 0}, {".F08", "#Fortran", 0, 0, 0},
  {".r", "#Ratfor", 0, 0, 0},
  {".p", "#Pascal", 0, 0, 0}, {".pas", "#Pascal", 0, 0, 0},
  {".java", "#Java", 0, 0, 0}, {".class", "#Java", 0, 0, 0},
  {".zip", "#Java", 0, 0, 0}, {".jar", "#Java", 0, 0, 0},
  {".go", "#Go", 0, 1, 0},

  {".c", "@c", 0, 0, 1},
  {"@c",


     "%{E|M|MM:%(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)}      %{!E:%{!M:%{!MM:          %{traditional:%eGNU C no longer supports -traditional without -E}      %{save-temps*|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) 	  %(cpp_options) -o %{save-temps*:%b.i} %{!save-temps*:%g.i} \n	    cc1 -fpreprocessed %{save-temps*:%b.i} %{!save-temps*:%g.i} 	  %(cc1_options)}      %{!save-temps*:%{!traditional-cpp:%{!no-integrated-cpp:	  cc1 %(cpp_unique_options) %(cc1_options)}}}      %{!fsyntax-only:%(invoke_as)}}}}", 0, 0, 1},
# 947 "gcc.c"
  {"-",
   "%{!E:%e-E or -x required when input is from standard input}    %(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)", 0, 0, 0},

  {".h", "@c-header", 0, 0, 0},
  {"@c-header",


     "%{E|M|MM:%(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)}      %{!E:%{!M:%{!MM:	  %{save-temps*|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) 		%(cpp_options) -o %{save-temps*:%b.i} %{!save-temps*:%g.i} \n		    cc1 -fpreprocessed %{save-temps*:%b.i} %{!save-temps*:%g.i} 			%(cc1_options)                        %{!fdump-ada-spec*:-o %g.s %{!o*:--output-pch=%i.gch}                        %W{o*:--output-pch=%*}}%V}	  %{!save-temps*:%{!traditional-cpp:%{!no-integrated-cpp:		cc1 %(cpp_unique_options) %(cc1_options)                    %{!fdump-ada-spec*:-o %g.s %{!o*:--output-pch=%i.gch}                    %W{o*:--output-pch=%*}}%V}}}}}}", 0, 0, 0},
# 966 "gcc.c"
  {".i", "@cpp-output", 0, 0, 0},
  {"@cpp-output",
   "%{!M:%{!MM:%{!E:cc1 -fpreprocessed %i %(cc1_options) %{!fsyntax-only:%(invoke_as)}}}}", 0, 0, 0},
  {".s", "@assembler", 0, 0, 0},
  {"@assembler",
   "%{!M:%{!MM:%{!E:%{!S:as %(asm_debug) %(asm_options) %i %A }}}}", 0, 0, 0},
  {".sx", "@assembler-with-cpp", 0, 0, 0},
  {".S", "@assembler-with-cpp", 0, 0, 0},
  {"@assembler-with-cpp",






   "%(trad_capable_cpp) -lang-asm %(cpp_options) -fno-directives-only      %{E|M|MM:%(cpp_debug_options)}      %{!M:%{!MM:%{!E:%{!S:-o %|.s |\n       as %(asm_debug) %(asm_options) %m.s %A }}}}"




   , 0, 0, 0},



  {0, 0, 0, 0, 0}
};



static const int n_default_compilers = ARRAY_SIZE (default_compilers) - 1;

typedef char *char_p;
static inline void VEC_char_p_must_be_pointer_type (void) { (void)((char_p)1 == (void *)1); } typedef struct VEC_char_p_base { struct vec_prefix prefix; char_p vec[1]; } VEC_char_p_base; typedef struct VEC_char_p_none { VEC_char_p_base base; } VEC_char_p_none; static inline unsigned VEC_char_p_base_length (const VEC_char_p_base *vec_) { return vec_ ? vec_->prefix.num : 0; } static inline char_p VEC_char_p_base_last (const VEC_char_p_base *vec_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_ && vec_->prefix.num) ? 0 : (vec_assert_fail ("last","VEC(char_p,base)" ,file_,line_,function_), 0)); return vec_->vec[vec_->prefix.num - 1]; } static inline char_p VEC_char_p_base_index (const VEC_char_p_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_ && ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("index","VEC(char_p,base)" ,file_,line_,function_), 0)); return vec_->vec[ix_]; } static inline int VEC_char_p_base_iterate (const VEC_char_p_base *vec_, unsigned ix_, char_p *ptr) { if (vec_ && ix_ < vec_->prefix.num) { *ptr = vec_->vec[ix_]; return 1; } else { *ptr = (char_p) 0; return 0; } } static inline size_t VEC_char_p_base_embedded_size (int alloc_) { return __builtin_offsetof (VEC_char_p_base, vec) + alloc_ * sizeof(char_p); } static inline void VEC_char_p_base_embedded_init (VEC_char_p_base *vec_, int alloc_) { vec_->prefix.num = 0; vec_->prefix.alloc = alloc_; } static inline int VEC_char_p_base_space (VEC_char_p_base *vec_, int alloc_ ,const char *file_,unsigned line_,const char *function_) { (void)((alloc_ >= 0) ? 0 : (vec_assert_fail ("space","VEC(char_p,base)" ,file_,line_,function_), 0)); return vec_ ? vec_->prefix.alloc - vec_->prefix.num >= (unsigned)alloc_ : !alloc_; } static inline void VEC_char_p_base_splice (VEC_char_p_base *dst_, VEC_char_p_base *src_ ,const char *file_,unsigned line_,const char *function_) { if (src_) { unsigned len_ = src_->prefix.num; (void)((dst_->prefix.num + len_ <= dst_->prefix.alloc) ? 0 : (vec_assert_fail ("splice","VEC(char_p,base)" ,file_,line_,function_), 0)); memcpy (&dst_->vec[dst_->prefix.num], &src_->vec[0], len_ * sizeof (char_p)); dst_->prefix.num += len_; } } static inline char_p *VEC_char_p_base_quick_push (VEC_char_p_base *vec_, char_p obj_ ,const char *file_,unsigned line_,const char *function_) { char_p *slot_; (void)((vec_->prefix.num < vec_->prefix.alloc) ? 0 : (vec_assert_fail ("push","VEC(char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[vec_->prefix.num++]; *slot_ = obj_; return slot_; } static inline char_p VEC_char_p_base_pop (VEC_char_p_base *vec_ ,const char *file_,unsigned line_,const char *function_) { char_p obj_; (void)((vec_->prefix.num) ? 0 : (vec_assert_fail ("pop","VEC(char_p,base)" ,file_,line_,function_), 0)); obj_ = vec_->vec[--vec_->prefix.num]; return obj_; } static inline void VEC_char_p_base_truncate (VEC_char_p_base *vec_, unsigned size_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_ ? vec_->prefix.num >= size_ : !size_) ? 0 : (vec_assert_fail ("truncate","VEC(char_p,base)" ,file_,line_,function_), 0)); if (vec_) vec_->prefix.num = size_; } static inline char_p VEC_char_p_base_replace (VEC_char_p_base *vec_, unsigned ix_, char_p obj_ ,const char *file_,unsigned line_,const char *function_) { char_p old_obj_; (void)((ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("replace","VEC(char_p,base)" ,file_,line_,function_), 0)); old_obj_ = vec_->vec[ix_]; vec_->vec[ix_] = obj_; return old_obj_; } static inline char_p *VEC_char_p_base_quick_insert (VEC_char_p_base *vec_, unsigned ix_, char_p obj_ ,const char *file_,unsigned line_,const char *function_) { char_p *slot_; (void)((vec_->prefix.num < vec_->prefix.alloc) ? 0 : (vec_assert_fail ("insert","VEC(char_p,base)" ,file_,line_,function_), 0)); (void)((ix_ <= vec_->prefix.num) ? 0 : (vec_assert_fail ("insert","VEC(char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (char_p)); *slot_ = obj_; return slot_; } static inline char_p VEC_char_p_base_ordered_remove (VEC_char_p_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) { char_p *slot_; char_p obj_; (void)((ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("remove","VEC(char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; obj_ = *slot_; memmove (slot_, slot_ + 1, (--vec_->prefix.num - ix_) * sizeof (char_p)); return obj_; } static inline char_p VEC_char_p_base_unordered_remove (VEC_char_p_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) { char_p *slot_; char_p obj_; (void)((ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("remove","VEC(char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; obj_ = *slot_; *slot_ = vec_->vec[--vec_->prefix.num]; return obj_; } static inline void VEC_char_p_base_block_remove (VEC_char_p_base *vec_, unsigned ix_, unsigned len_ ,const char *file_,unsigned line_,const char *function_) { char_p *slot_; (void)((ix_ + len_ <= vec_->prefix.num) ? 0 : (vec_assert_fail ("block_remove","VEC(char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; vec_->prefix.num -= len_; memmove (slot_, slot_ + len_, (vec_->prefix.num - ix_) * sizeof (char_p)); } static inline char_p *VEC_char_p_base_address (VEC_char_p_base *vec_) { return vec_ ? vec_->vec : 0; } static inline unsigned VEC_char_p_base_lower_bound (VEC_char_p_base *vec_, const char_p obj_, unsigned char (*lessthan_)(const char_p, const char_p) ,const char *file_,unsigned line_,const char *function_) { unsigned int len_ = VEC_char_p_base_length (vec_); unsigned int half_, middle_; unsigned int first_ = 0; while (len_ > 0) { char_p middle_elem_; half_ = len_ >> 1; middle_ = first_; middle_ += half_; middle_elem_ = VEC_char_p_base_index (vec_, middle_ ,file_,line_,function_); if (lessthan_ (middle_elem_, obj_)) { first_ = middle_; ++first_; len_ = len_ - half_ - 1; } else len_ = half_; } return first_; } struct vec_swallow_trailing_semi;
typedef struct VEC_char_p_heap { VEC_char_p_base base; } VEC_char_p_heap; static inline VEC_char_p_heap *VEC_char_p_heap_alloc (int alloc_ ) { return (VEC_char_p_heap *) vec_heap_p_reserve_exact (((void *)0), alloc_ ); } static inline void VEC_char_p_heap_free (VEC_char_p_heap **vec_) { if (*vec_) (free) (*vec_); *vec_ = ((void *)0); } static inline VEC_char_p_heap *VEC_char_p_heap_copy (VEC_char_p_base *vec_ ) { size_t len_ = vec_ ? vec_->prefix.num : 0; VEC_char_p_heap *new_vec_ = ((void *)0); if (len_) { new_vec_ = (VEC_char_p_heap *)(vec_heap_p_reserve_exact (((void *)0), len_ )); new_vec_->base.prefix.num = len_; memcpy (new_vec_->base.vec, vec_->vec, sizeof (char_p) * len_); } return new_vec_; } static inline int VEC_char_p_heap_reserve (VEC_char_p_heap **vec_, int alloc_ ,const char *file_,unsigned line_,const char *function_ ) { int extend = !VEC_char_p_base_space (((*vec_) ? &(*vec_)->base : 0), alloc_ ,file_,line_,function_); if (extend) *vec_ = (VEC_char_p_heap *) vec_heap_p_reserve (*vec_, alloc_ ); return extend; } static inline int VEC_char_p_heap_reserve_exact (VEC_char_p_heap **vec_, int alloc_ ,const char *file_,unsigned line_,const char *function_ ) { int extend = !VEC_char_p_base_space (((*vec_) ? &(*vec_)->base : 0), alloc_ ,file_,line_,function_); if (extend) *vec_ = (VEC_char_p_heap *) vec_heap_p_reserve_exact (*vec_, alloc_ ); return extend; } static inline void VEC_char_p_heap_safe_grow (VEC_char_p_heap **vec_, int size_ ,const char *file_,unsigned line_,const char *function_ ) { (void)((size_ >= 0 && VEC_char_p_base_length ((*vec_) ? &(*vec_)->base : 0) <= (unsigned)size_) ? 0 : (vec_assert_fail ("grow","VEC(char_p,heap)" ,file_,line_,function_), 0)); VEC_char_p_heap_reserve_exact (vec_, size_ - (int)(*vec_ ? ((*vec_) ? &(*vec_)->base : 0)->prefix.num : 0) ,file_,line_,function_ ); ((*vec_) ? &(*vec_)->base : 0)->prefix.num = size_; } static inline void VEC_char_p_heap_safe_grow_cleared (VEC_char_p_heap **vec_, int size_ ,const char *file_,unsigned line_,const char *function_ ) { int oldsize = VEC_char_p_base_length ((*vec_) ? &(*vec_)->base : 0); VEC_char_p_heap_safe_grow (vec_, size_ ,file_,line_,function_ ); memset (&(VEC_char_p_base_address ((*vec_) ? &(*vec_)->base : 0))[oldsize], 0, sizeof (char_p) * (size_ - oldsize)); } static inline void VEC_char_p_heap_safe_splice (VEC_char_p_heap **dst_, VEC_char_p_base *src_ ,const char *file_,unsigned line_,const char *function_ ) { if (src_) { VEC_char_p_heap_reserve_exact (dst_, src_->prefix.num ,file_,line_,function_ ); VEC_char_p_base_splice (((*dst_) ? &(*dst_)->base : 0), src_ ,file_,line_,function_); } } static inline char_p *VEC_char_p_heap_safe_push (VEC_char_p_heap **vec_, char_p obj_ ,const char *file_,unsigned line_,const char *function_ ) { VEC_char_p_heap_reserve (vec_, 1 ,file_,line_,function_ ); return VEC_char_p_base_quick_push (((*vec_) ? &(*vec_)->base : 0), obj_ ,file_,line_,function_); } static inline char_p *VEC_char_p_heap_safe_insert (VEC_char_p_heap **vec_, unsigned ix_, char_p obj_ ,const char *file_,unsigned line_,const char *function_ ) { VEC_char_p_heap_reserve (vec_, 1 ,file_,line_,function_ ); return VEC_char_p_base_quick_insert (((*vec_) ? &(*vec_)->base : 0), ix_, obj_ ,file_,line_,function_); } struct vec_swallow_trailing_semi;




static VEC_char_p_heap *linker_options;




static VEC_char_p_heap *assembler_options;




static VEC_char_p_heap *preprocessor_options;

static char *
skip_whitespace (char *p)
{
  while (1)
    {


      if (p[0] == '\n' && p[1] == '\n' && p[2] == '\n')
 return p + 1;
      else if (*p == '\n' || *p == ' ' || *p == '\t')
 p++;
      else if (*p == '#')
 {
   while (*p != '\n')
     p++;
   p++;
 }
      else
 break;
    }

  return p;
}


struct prefix_list
{
  const char *prefix;
  struct prefix_list *next;
  int require_machine_suffix;

  int priority;
  int os_multilib;

};

struct path_prefix
{
  struct prefix_list *plist;
  int max_len;
  const char *name;
};



static struct path_prefix exec_prefixes = { 0, 0, "exec" };



static struct path_prefix startfile_prefixes = { 0, 0, "startfile" };



static struct path_prefix include_prefixes = { 0, 0, "include" };




static const char *machine_suffix = 0;




static const char *just_machine_suffix = 0;



static const char *gcc_exec_prefix;



static const char *gcc_libexec_prefix;
# 1121 "gcc.c"
static const char *const standard_exec_prefix = STANDARD_EXEC_PREFIX;
static const char *const standard_libexec_prefix = STANDARD_LIBEXEC_PREFIX;
static const char *const standard_bindir_prefix = STANDARD_BINDIR_PREFIX;
static const char *const standard_startfile_prefix = STANDARD_STARTFILE_PREFIX;




static const char *md_exec_prefix = "";
static const char *md_startfile_prefix = "";
static const char *md_startfile_prefix_1 = "";
static const char *const standard_startfile_prefix_1
  = "/lib/";
static const char *const standard_startfile_prefix_2
  = "/usr/lib/";



static const char *const tooldir_base_prefix = TOOLDIR_BASE_PREFIX;




static const char *multilib_dir;




static const char *multilib_os_dir;





struct spec_list
{


  const char *name;
  const char *ptr;



  const char **ptr_spec;
  struct spec_list *next;
  int name_len;
  int alloc_p;
};





static struct spec_list static_specs[] =
{
  { "asm", ((void *)0), &asm_spec, (struct spec_list *) 0, sizeof ("asm") - 1, 0 },
  { "asm_debug", ((void *)0), &asm_debug, (struct spec_list *) 0, sizeof ("asm_debug") - 1, 0 },
  { "asm_final", ((void *)0), &asm_final_spec, (struct spec_list *) 0, sizeof ("asm_final") - 1, 0 },
  { "asm_options", ((void *)0), &asm_options, (struct spec_list *) 0, sizeof ("asm_options") - 1, 0 },
  { "invoke_as", ((void *)0), &invoke_as, (struct spec_list *) 0, sizeof ("invoke_as") - 1, 0 },
  { "cpp", ((void *)0), &cpp_spec, (struct spec_list *) 0, sizeof ("cpp") - 1, 0 },
  { "cpp_options", ((void *)0), &cpp_options, (struct spec_list *) 0, sizeof ("cpp_options") - 1, 0 },
  { "cpp_debug_options", ((void *)0), &cpp_debug_options, (struct spec_list *) 0, sizeof ("cpp_debug_options") - 1, 0 },
  { "cpp_unique_options", ((void *)0), &cpp_unique_options, (struct spec_list *) 0, sizeof ("cpp_unique_options") - 1, 0 },
  { "trad_capable_cpp", ((void *)0), &trad_capable_cpp, (struct spec_list *) 0, sizeof ("trad_capable_cpp") - 1, 0 },
  { "cc1", ((void *)0), &cc1_spec, (struct spec_list *) 0, sizeof ("cc1") - 1, 0 },
  { "cc1_options", ((void *)0), &cc1_options, (struct spec_list *) 0, sizeof ("cc1_options") - 1, 0 },
  { "cc1plus", ((void *)0), &cc1plus_spec, (struct spec_list *) 0, sizeof ("cc1plus") - 1, 0 },
  { "link_gcc_c_sequence", ((void *)0), &link_gcc_c_sequence_spec, (struct spec_list *) 0, sizeof ("link_gcc_c_sequence") - 1, 0 },
  { "link_ssp", ((void *)0), &link_ssp_spec, (struct spec_list *) 0, sizeof ("link_ssp") - 1, 0 },
  { "endfile", ((void *)0), &endfile_spec, (struct spec_list *) 0, sizeof ("endfile") - 1, 0 },
  { "link", ((void *)0), &link_spec, (struct spec_list *) 0, sizeof ("link") - 1, 0 },
  { "lib", ((void *)0), &lib_spec, (struct spec_list *) 0, sizeof ("lib") - 1, 0 },
  { "mfwrap", ((void *)0), &mfwrap_spec, (struct spec_list *) 0, sizeof ("mfwrap") - 1, 0 },
  { "mflib", ((void *)0), &mflib_spec, (struct spec_list *) 0, sizeof ("mflib") - 1, 0 },
  { "link_gomp", ((void *)0), &link_gomp_spec, (struct spec_list *) 0, sizeof ("link_gomp") - 1, 0 },
  { "libgcc", ((void *)0), &libgcc_spec, (struct spec_list *) 0, sizeof ("libgcc") - 1, 0 },
  { "startfile", ((void *)0), &startfile_spec, (struct spec_list *) 0, sizeof ("startfile") - 1, 0 },
  { "cross_compile", ((void *)0), &cross_compile, (struct spec_list *) 0, sizeof ("cross_compile") - 1, 0 },
  { "version", ((void *)0), &compiler_version, (struct spec_list *) 0, sizeof ("version") - 1, 0 },
  { "multilib", ((void *)0), &multilib_select, (struct spec_list *) 0, sizeof ("multilib") - 1, 0 },
  { "multilib_defaults", ((void *)0), &multilib_defaults, (struct spec_list *) 0, sizeof ("multilib_defaults") - 1, 0 },
  { "multilib_extra", ((void *)0), &multilib_extra, (struct spec_list *) 0, sizeof ("multilib_extra") - 1, 0 },
  { "multilib_matches", ((void *)0), &multilib_matches, (struct spec_list *) 0, sizeof ("multilib_matches") - 1, 0 },
  { "multilib_exclusions", ((void *)0), &multilib_exclusions, (struct spec_list *) 0, sizeof ("multilib_exclusions") - 1, 0 },
  { "multilib_options", ((void *)0), &multilib_options, (struct spec_list *) 0, sizeof ("multilib_options") - 1, 0 },
  { "linker", ((void *)0), &linker_name_spec, (struct spec_list *) 0, sizeof ("linker") - 1, 0 },
  { "linker_plugin_file", ((void *)0), &linker_plugin_file_spec, (struct spec_list *) 0, sizeof ("linker_plugin_file") - 1, 0 },
  { "lto_wrapper", ((void *)0), &lto_wrapper_spec, (struct spec_list *) 0, sizeof ("lto_wrapper") - 1, 0 },
  { "lto_gcc", ((void *)0), &lto_gcc_spec, (struct spec_list *) 0, sizeof ("lto_gcc") - 1, 0 },
  { "link_libgcc", ((void *)0), &link_libgcc_spec, (struct spec_list *) 0, sizeof ("link_libgcc") - 1, 0 },
  { "md_exec_prefix", ((void *)0), &md_exec_prefix, (struct spec_list *) 0, sizeof ("md_exec_prefix") - 1, 0 },
  { "md_startfile_prefix", ((void *)0), &md_startfile_prefix, (struct spec_list *) 0, sizeof ("md_startfile_prefix") - 1, 0 },
  { "md_startfile_prefix_1", ((void *)0), &md_startfile_prefix_1, (struct spec_list *) 0, sizeof ("md_startfile_prefix_1") - 1, 0 },
  { "startfile_prefix_spec", ((void *)0), &startfile_prefix_spec, (struct spec_list *) 0, sizeof ("startfile_prefix_spec") - 1, 0 },
  { "sysroot_spec", ((void *)0), &sysroot_spec, (struct spec_list *) 0, sizeof ("sysroot_spec") - 1, 0 },
  { "sysroot_suffix_spec", ((void *)0), &sysroot_suffix_spec, (struct spec_list *) 0, sizeof ("sysroot_suffix_spec") - 1, 0 },
  { "sysroot_hdrs_suffix_spec", ((void *)0), &sysroot_hdrs_suffix_spec, (struct spec_list *) 0, sizeof ("sysroot_hdrs_suffix_spec") - 1, 0 },
  { "self_spec", ((void *)0), &self_spec, (struct spec_list *) 0, sizeof ("self_spec") - 1, 0 },
};
# 1237 "gcc.c"
static struct spec_list *specs = (struct spec_list *) 0;



static const struct spec_function static_spec_functions[] =
{
  { "getenv", getenv_spec_function },
  { "if-exists", if_exists_spec_function },
  { "if-exists-else", if_exists_else_spec_function },
  { "replace-outfile", replace_outfile_spec_function },
  { "remove-outfile", remove_outfile_spec_function },
  { "version-compare", version_compare_spec_function },
  { "include", include_spec_function },
  { "find-file", find_file_spec_function },
  { "find-plugindir", find_plugindir_spec_function },
  { "print-asm-header", print_asm_header_spec_function },
  { "compare-debug-dump-opt", compare_debug_dump_opt_spec_function },
  { "compare-debug-self-opt", compare_debug_self_opt_spec_function },
  { "compare-debug-auxbase-opt", compare_debug_auxbase_opt_spec_function },
  { "pass-through-libs", pass_through_libs_spec_func },



  { 0, 0 }
};

static int processing_spec_function;
# 1312 "gcc.c"
static void
init_spec (void)
{
  struct spec_list *next = (struct spec_list *) 0;
  struct spec_list *sl = (struct spec_list *) 0;
  int i;

  if (specs)
    return;

  if (global_options.x_verbose_flag)
    fnotice (stderr, "Using built-in specs.\n");
# 1340 "gcc.c"
  for (i = ARRAY_SIZE (static_specs) - 1; i >= 0; i--)
    {
      sl = &static_specs[i];
      sl->next = next;
      next = sl;
    }
# 1467 "gcc.c"
  specs = sl;
}





static void
set_spec (const char *name, const char *spec)
{
  struct spec_list *sl;
  const char *old_spec;
  int name_len = strlen (name);
  int i;


  if (!specs)
    {
      struct spec_list *next = (struct spec_list *) 0;
      for (i = ARRAY_SIZE (static_specs) - 1; i >= 0; i--)
 {
   sl = &static_specs[i];
   sl->next = next;
   next = sl;
 }
      specs = sl;
    }


  for (sl = specs; sl; sl = sl->next)
    if (name_len == sl->name_len && !strcmp (sl->name, name))
      break;

  if (!sl)
    {

      sl = XNEW (struct spec_list);
      sl->name = xstrdup (name);
      sl->name_len = name_len;
      sl->ptr_spec = &sl->ptr;
      sl->alloc_p = 0;
      *(sl->ptr_spec) = "";
      sl->next = specs;
      specs = sl;
    }

  old_spec = *(sl->ptr_spec);
  *(sl->ptr_spec) = ((spec[0] == '+' && ISSPACE ((unsigned char)spec[1]))
       ? concat (old_spec, spec + 1, ((void *)0))
       : xstrdup (spec));







  if (old_spec && sl->alloc_p)
    free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((old_spec)))));

  sl->alloc_p = 1;
}



typedef const char *const_char_p;
static inline void VEC_const_char_p_must_be_pointer_type (void) { (void)((const_char_p)1 == (void *)1); } typedef struct VEC_const_char_p_base { struct vec_prefix prefix; const_char_p vec[1]; } VEC_const_char_p_base; typedef struct VEC_const_char_p_none { VEC_const_char_p_base base; } VEC_const_char_p_none; static inline unsigned VEC_const_char_p_base_length (const VEC_const_char_p_base *vec_) { return vec_ ? vec_->prefix.num : 0; } static inline const_char_p VEC_const_char_p_base_last (const VEC_const_char_p_base *vec_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_ && vec_->prefix.num) ? 0 : (vec_assert_fail ("last","VEC(const_char_p,base)" ,file_,line_,function_), 0)); return vec_->vec[vec_->prefix.num - 1]; } static inline const_char_p VEC_const_char_p_base_index (const VEC_const_char_p_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_ && ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("index","VEC(const_char_p,base)" ,file_,line_,function_), 0)); return vec_->vec[ix_]; } static inline int VEC_const_char_p_base_iterate (const VEC_const_char_p_base *vec_, unsigned ix_, const_char_p *ptr) { if (vec_ && ix_ < vec_->prefix.num) { *ptr = vec_->vec[ix_]; return 1; } else { *ptr = (const_char_p) 0; return 0; } } static inline size_t VEC_const_char_p_base_embedded_size (int alloc_) { return __builtin_offsetof (VEC_const_char_p_base, vec) + alloc_ * sizeof(const_char_p); } static inline void VEC_const_char_p_base_embedded_init (VEC_const_char_p_base *vec_, int alloc_) { vec_->prefix.num = 0; vec_->prefix.alloc = alloc_; } static inline int VEC_const_char_p_base_space (VEC_const_char_p_base *vec_, int alloc_ ,const char *file_,unsigned line_,const char *function_) { (void)((alloc_ >= 0) ? 0 : (vec_assert_fail ("space","VEC(const_char_p,base)" ,file_,line_,function_), 0)); return vec_ ? vec_->prefix.alloc - vec_->prefix.num >= (unsigned)alloc_ : !alloc_; } static inline void VEC_const_char_p_base_splice (VEC_const_char_p_base *dst_, VEC_const_char_p_base *src_ ,const char *file_,unsigned line_,const char *function_) { if (src_) { unsigned len_ = src_->prefix.num; (void)((dst_->prefix.num + len_ <= dst_->prefix.alloc) ? 0 : (vec_assert_fail ("splice","VEC(const_char_p,base)" ,file_,line_,function_), 0)); memcpy (&dst_->vec[dst_->prefix.num], &src_->vec[0], len_ * sizeof (const_char_p)); dst_->prefix.num += len_; } } static inline const_char_p *VEC_const_char_p_base_quick_push (VEC_const_char_p_base *vec_, const_char_p obj_ ,const char *file_,unsigned line_,const char *function_) { const_char_p *slot_; (void)((vec_->prefix.num < vec_->prefix.alloc) ? 0 : (vec_assert_fail ("push","VEC(const_char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[vec_->prefix.num++]; *slot_ = obj_; return slot_; } static inline const_char_p VEC_const_char_p_base_pop (VEC_const_char_p_base *vec_ ,const char *file_,unsigned line_,const char *function_) { const_char_p obj_; (void)((vec_->prefix.num) ? 0 : (vec_assert_fail ("pop","VEC(const_char_p,base)" ,file_,line_,function_), 0)); obj_ = vec_->vec[--vec_->prefix.num]; return obj_; } static inline void VEC_const_char_p_base_truncate (VEC_const_char_p_base *vec_, unsigned size_ ,const char *file_,unsigned line_,const char *function_) { (void)((vec_ ? vec_->prefix.num >= size_ : !size_) ? 0 : (vec_assert_fail ("truncate","VEC(const_char_p,base)" ,file_,line_,function_), 0)); if (vec_) vec_->prefix.num = size_; } static inline const_char_p VEC_const_char_p_base_replace (VEC_const_char_p_base *vec_, unsigned ix_, const_char_p obj_ ,const char *file_,unsigned line_,const char *function_) { const_char_p old_obj_; (void)((ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("replace","VEC(const_char_p,base)" ,file_,line_,function_), 0)); old_obj_ = vec_->vec[ix_]; vec_->vec[ix_] = obj_; return old_obj_; } static inline const_char_p *VEC_const_char_p_base_quick_insert (VEC_const_char_p_base *vec_, unsigned ix_, const_char_p obj_ ,const char *file_,unsigned line_,const char *function_) { const_char_p *slot_; (void)((vec_->prefix.num < vec_->prefix.alloc) ? 0 : (vec_assert_fail ("insert","VEC(const_char_p,base)" ,file_,line_,function_), 0)); (void)((ix_ <= vec_->prefix.num) ? 0 : (vec_assert_fail ("insert","VEC(const_char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; memmove (slot_ + 1, slot_, (vec_->prefix.num++ - ix_) * sizeof (const_char_p)); *slot_ = obj_; return slot_; } static inline const_char_p VEC_const_char_p_base_ordered_remove (VEC_const_char_p_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) { const_char_p *slot_; const_char_p obj_; (void)((ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("remove","VEC(const_char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; obj_ = *slot_; memmove (slot_, slot_ + 1, (--vec_->prefix.num - ix_) * sizeof (const_char_p)); return obj_; } static inline const_char_p VEC_const_char_p_base_unordered_remove (VEC_const_char_p_base *vec_, unsigned ix_ ,const char *file_,unsigned line_,const char *function_) { const_char_p *slot_; const_char_p obj_; (void)((ix_ < vec_->prefix.num) ? 0 : (vec_assert_fail ("remove","VEC(const_char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; obj_ = *slot_; *slot_ = vec_->vec[--vec_->prefix.num]; return obj_; } static inline void VEC_const_char_p_base_block_remove (VEC_const_char_p_base *vec_, unsigned ix_, unsigned len_ ,const char *file_,unsigned line_,const char *function_) { const_char_p *slot_; (void)((ix_ + len_ <= vec_->prefix.num) ? 0 : (vec_assert_fail ("block_remove","VEC(const_char_p,base)" ,file_,line_,function_), 0)); slot_ = &vec_->vec[ix_]; vec_->prefix.num -= len_; memmove (slot_, slot_ + len_, (vec_->prefix.num - ix_) * sizeof (const_char_p)); } static inline const_char_p *VEC_const_char_p_base_address (VEC_const_char_p_base *vec_) { return vec_ ? vec_->vec : 0; } static inline unsigned VEC_const_char_p_base_lower_bound (VEC_const_char_p_base *vec_, const const_char_p obj_, unsigned char (*lessthan_)(const const_char_p, const const_char_p) ,const char *file_,unsigned line_,const char *function_) { unsigned int len_ = VEC_const_char_p_base_length (vec_); unsigned int half_, middle_; unsigned int first_ = 0; while (len_ > 0) { const_char_p middle_elem_; half_ = len_ >> 1; middle_ = first_; middle_ += half_; middle_elem_ = VEC_const_char_p_base_index (vec_, middle_ ,file_,line_,function_); if (lessthan_ (middle_elem_, obj_)) { first_ = middle_; ++first_; len_ = len_ - half_ - 1; } else len_ = half_; } return first_; } struct vec_swallow_trailing_semi;
typedef struct VEC_const_char_p_heap { VEC_const_char_p_base base; } VEC_const_char_p_heap; static inline VEC_const_char_p_heap *VEC_const_char_p_heap_alloc (int alloc_ ) { return (VEC_const_char_p_heap *) vec_heap_p_reserve_exact (((void *)0), alloc_ ); } static inline void VEC_const_char_p_heap_free (VEC_const_char_p_heap **vec_) { if (*vec_) (free) (*vec_); *vec_ = ((void *)0); } static inline VEC_const_char_p_heap *VEC_const_char_p_heap_copy (VEC_const_char_p_base *vec_ ) { size_t len_ = vec_ ? vec_->prefix.num : 0; VEC_const_char_p_heap *new_vec_ = ((void *)0); if (len_) { new_vec_ = (VEC_const_char_p_heap *)(vec_heap_p_reserve_exact (((void *)0), len_ )); new_vec_->base.prefix.num = len_; memcpy (new_vec_->base.vec, vec_->vec, sizeof (const_char_p) * len_); } return new_vec_; } static inline int VEC_const_char_p_heap_reserve (VEC_const_char_p_heap **vec_, int alloc_ ,const char *file_,unsigned line_,const char *function_ ) { int extend = !VEC_const_char_p_base_space (((*vec_) ? &(*vec_)->base : 0), alloc_ ,file_,line_,function_); if (extend) *vec_ = (VEC_const_char_p_heap *) vec_heap_p_reserve (*vec_, alloc_ ); return extend; } static inline int VEC_const_char_p_heap_reserve_exact (VEC_const_char_p_heap **vec_, int alloc_ ,const char *file_,unsigned line_,const char *function_ ) { int extend = !VEC_const_char_p_base_space (((*vec_) ? &(*vec_)->base : 0), alloc_ ,file_,line_,function_); if (extend) *vec_ = (VEC_const_char_p_heap *) vec_heap_p_reserve_exact (*vec_, alloc_ ); return extend; } static inline void VEC_const_char_p_heap_safe_grow (VEC_const_char_p_heap **vec_, int size_ ,const char *file_,unsigned line_,const char *function_ ) { (void)((size_ >= 0 && VEC_const_char_p_base_length ((*vec_) ? &(*vec_)->base : 0) <= (unsigned)size_) ? 0 : (vec_assert_fail ("grow","VEC(const_char_p,heap)" ,file_,line_,function_), 0)); VEC_const_char_p_heap_reserve_exact (vec_, size_ - (int)(*vec_ ? ((*vec_) ? &(*vec_)->base : 0)->prefix.num : 0) ,file_,line_,function_ ); ((*vec_) ? &(*vec_)->base : 0)->prefix.num = size_; } static inline void VEC_const_char_p_heap_safe_grow_cleared (VEC_const_char_p_heap **vec_, int size_ ,const char *file_,unsigned line_,const char *function_ ) { int oldsize = VEC_const_char_p_base_length ((*vec_) ? &(*vec_)->base : 0); VEC_const_char_p_heap_safe_grow (vec_, size_ ,file_,line_,function_ ); memset (&(VEC_const_char_p_base_address ((*vec_) ? &(*vec_)->base : 0))[oldsize], 0, sizeof (const_char_p) * (size_ - oldsize)); } static inline void VEC_const_char_p_heap_safe_splice (VEC_const_char_p_heap **dst_, VEC_const_char_p_base *src_ ,const char *file_,unsigned line_,const char *function_ ) { if (src_) { VEC_const_char_p_heap_reserve_exact (dst_, src_->prefix.num ,file_,line_,function_ ); VEC_const_char_p_base_splice (((*dst_) ? &(*dst_)->base : 0), src_ ,file_,line_,function_); } } static inline const_char_p *VEC_const_char_p_heap_safe_push (VEC_const_char_p_heap **vec_, const_char_p obj_ ,const char *file_,unsigned line_,const char *function_ ) { VEC_const_char_p_heap_reserve (vec_, 1 ,file_,line_,function_ ); return VEC_const_char_p_base_quick_push (((*vec_) ? &(*vec_)->base : 0), obj_ ,file_,line_,function_); } static inline const_char_p *VEC_const_char_p_heap_safe_insert (VEC_const_char_p_heap **vec_, unsigned ix_, const_char_p obj_ ,const char *file_,unsigned line_,const char *function_ ) { VEC_const_char_p_heap_reserve (vec_, 1 ,file_,line_,function_ ); return VEC_const_char_p_base_quick_insert (((*vec_) ? &(*vec_)->base : 0), ix_, obj_ ,file_,line_,function_); } struct vec_swallow_trailing_semi;



static VEC_const_char_p_heap *argbuf;




static int have_o_argbuf_index = 0;


static int have_c = 0;


static int have_o = 0;





static struct temp_name {
  const char *suffix;
  int length;
  int unique;
  const char *filename;
  int filename_length;
  struct temp_name *next;
} *temp_names;



static int execution_count;



static int signal_count;



static void
alloc_args (void)
{
  argbuf = (VEC_const_char_p_heap_alloc(10 ));
}



static void
clear_args (void)
{
  (VEC_const_char_p_base_truncate(((argbuf) ? &(argbuf)->base : 0),0 ,"gcc.c",1585,"?"));
}
# 1595 "gcc.c"
static void
store_arg (const char *arg, int delete_always, int delete_failure)
{
  (VEC_const_char_p_heap_safe_push(&(argbuf),arg ,"gcc.c",1598,"?" ));

  if (strcmp (arg, "-o") == 0)
    have_o_argbuf_index = (VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0)));
  if (delete_always || delete_failure)
    {
      const char *p;


      if (arg[0] == '-'
   && (p = strrchr (arg, '=')))
 arg = p + 1;
      record_temp_file (arg, delete_always, delete_failure);
    }
}





static char *
load_specs (const char *filename)
{
  int desc;
  int readlen;
  struct stat statbuf;
  char *buffer;
  char *buffer_p;
  char *specs;
  char *specs_p;

  if (global_options.x_verbose_flag)
    fnotice (stderr, "Reading specs from %s\n", filename);


  desc = open (filename, 00, 0);
  if (desc < 0)
    pfatal_with_name (filename);
  if (stat (filename, &statbuf) < 0)
    pfatal_with_name (filename);


  buffer = XNEWVEC (char, statbuf.st_size + 1);
  readlen = read (desc, buffer, (unsigned) statbuf.st_size);
  if (readlen < 0)
    pfatal_with_name (filename);
  buffer[readlen] = 0;
  close (desc);

  specs = XNEWVEC (char, readlen + 1);
  specs_p = specs;
  for (buffer_p = buffer; buffer_p && *buffer_p; buffer_p++)
    {
      int skip = 0;
      char c = *buffer_p;
      if (c == '\r')
 {
   if (buffer_p > buffer && *(buffer_p - 1) == '\n')
     skip = 1;
   else if (*(buffer_p + 1) == '\n')
     skip = 1;
   else
     c = '\n';
 }
      if (! skip)
 *specs_p++ = c;
    }
  *specs_p = '\0';

  free (buffer);
  return (specs);
}
# 1682 "gcc.c"
static void
read_specs (const char *filename, int main_p)
{
  char *buffer;
  char *p;

  buffer = load_specs (filename);


  p = buffer;
  while (1)
    {
      char *suffix;
      char *spec;
      char *in, *out, *p1, *p2, *p3;


      p = skip_whitespace (p);
      if (*p == 0)
 break;




      if (*p == '%' && !main_p)
 {
   p1 = p;
   while (*p && *p != '\n')
     p++;


   p++;

   if (!strncmp (p1, "%include", sizeof ("%include") - 1)
       && (p1[sizeof "%include" - 1] == ' '
    || p1[sizeof "%include" - 1] == '\t'))
     {
       char *new_filename;

       p1 += sizeof ("%include");
       while (*p1 == ' ' || *p1 == '\t')
  p1++;

       if (*p1++ != '<' || p[-2] != '>')
  fatal_error ("specs %%include syntax malformed after "
        "%ld characters",
        (long) (p1 - buffer + 1));

       p[-2] = '\0';
       new_filename = find_a_file (&startfile_prefixes, p1, 4, 1);
       read_specs (new_filename ? new_filename : p1, 0);
       continue;
     }
   else if (!strncmp (p1, "%include_noerr", sizeof "%include_noerr" - 1)
     && (p1[sizeof "%include_noerr" - 1] == ' '
         || p1[sizeof "%include_noerr" - 1] == '\t'))
     {
       char *new_filename;

       p1 += sizeof "%include_noerr";
       while (*p1 == ' ' || *p1 == '\t')
  p1++;

       if (*p1++ != '<' || p[-2] != '>')
  fatal_error ("specs %%include syntax malformed after "
        "%ld characters",
        (long) (p1 - buffer + 1));

       p[-2] = '\0';
       new_filename = find_a_file (&startfile_prefixes, p1, 4, 1);
       if (new_filename)
  read_specs (new_filename, 0);
       else if (global_options.x_verbose_flag)
  fnotice (stderr, "could not find specs file %s\n", p1);
       continue;
     }
   else if (!strncmp (p1, "%rename", sizeof "%rename" - 1)
     && (p1[sizeof "%rename" - 1] == ' '
         || p1[sizeof "%rename" - 1] == '\t'))
     {
       int name_len;
       struct spec_list *sl;
       struct spec_list *newsl;


       p1 += sizeof "%rename";
       while (*p1 == ' ' || *p1 == '\t')
  p1++;

       if (! ISALPHA ((unsigned char) *p1))
  fatal_error ("specs %%rename syntax malformed after "
        "%ld characters",
        (long) (p1 - buffer));

       p2 = p1;
       while (*p2 && !ISSPACE ((unsigned char) *p2))
  p2++;

       if (*p2 != ' ' && *p2 != '\t')
  fatal_error ("specs %%rename syntax malformed after "
        "%ld characters",
        (long) (p2 - buffer));

       name_len = p2 - p1;
       *p2++ = '\0';
       while (*p2 == ' ' || *p2 == '\t')
  p2++;

       if (! ISALPHA ((unsigned char) *p2))
  fatal_error ("specs %%rename syntax malformed after "
        "%ld characters",
        (long) (p2 - buffer));


       p3 = p2;
       while (*p3 && !ISSPACE ((unsigned char) *p3))
  p3++;

       if (p3 != p - 1)
  fatal_error ("specs %%rename syntax malformed after "
        "%ld characters",
        (long) (p3 - buffer));
       *p3 = '\0';

       for (sl = specs; sl; sl = sl->next)
  if (name_len == sl->name_len && !strcmp (sl->name, p1))
    break;

       if (!sl)
  fatal_error ("specs %s spec was not found to be renamed", p1);

       if (strcmp (p1, p2) == 0)
  continue;

       for (newsl = specs; newsl; newsl = newsl->next)
  if (strcmp (newsl->name, p2) == 0)
    fatal_error ("%s: attempt to rename spec %qs to "
          "already defined spec %qs",
      filename, p1, p2);

       if (global_options.x_verbose_flag)
  {
    fnotice (stderr, "rename spec %s to %s\n", p1, p2);



  }

       set_spec (p2, *(sl->ptr_spec));
       if (sl->alloc_p)
  free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((*(sl->ptr_spec))))));

       *(sl->ptr_spec) = "";
       sl->alloc_p = 0;
       continue;
     }
   else
     fatal_error ("specs unknown %% command after %ld characters",
    (long) (p1 - buffer));
 }


      p1 = p;
      while (*p1 && *p1 != ':' && *p1 != '\n')
 p1++;


      if (*p1 != ':')
 fatal_error ("specs file malformed after %ld characters",
       (long) (p1 - buffer));


      p2 = p1;
      while (p2 > buffer && (p2[-1] == ' ' || p2[-1] == '\t'))
 p2--;


      suffix = save_string (p, p2 - p);

      p = skip_whitespace (p1 + 1);
      if (p[1] == 0)
 fatal_error ("specs file malformed after %ld characters",
       (long) (p - buffer));

      p1 = p;

      while (*p1 && !(*p1 == '\n' && (p1[1] == '\n' || p1[1] == '\0')))
 p1++;


      spec = save_string (p, p1 - p);
      p = p1;


      in = spec;
      out = spec;
      while (*in != 0)
 {
   if (in[0] == '\\' && in[1] == '\n')
     in += 2;
   else if (in[0] == '#')
     while (*in && *in != '\n')
       in++;

   else
     *out++ = *in++;
 }
      *out = 0;

      if (suffix[0] == '*')
 {
   if (! strcmp (suffix, "*link_command"))
     link_command_spec = spec;
   else
     set_spec (suffix + 1, spec);
 }
      else
 {

   compilers
     = XRESIZEVEC (struct compiler, compilers, n_compilers + 2);

   compilers[n_compilers].suffix = suffix;
   compilers[n_compilers].spec = spec;
   n_compilers++;
   memset (&compilers[n_compilers], 0, sizeof compilers[n_compilers]);
 }

      if (*suffix == 0)
 link_command_spec = spec;
    }

  if (link_command_spec == 0)
    fatal_error ("spec file has no spec for linking");
}
# 1932 "gcc.c"
static const char *temp_filename;



static int temp_filename_length;



struct temp_file
{
  const char *name;
  struct temp_file *next;
};


static struct temp_file *always_delete_queue;

static struct temp_file *failure_delete_queue;







void
record_temp_file (const char *filename, int always_delete, int fail_delete)
{
  char *const name = xstrdup (filename);

  if (always_delete)
    {
      struct temp_file *temp;
      for (temp = always_delete_queue; temp; temp = temp->next)
 if (! filename_cmp (name, temp->name))
   goto already1;

      temp = XNEW (struct temp_file);
      temp->next = always_delete_queue;
      temp->name = name;
      always_delete_queue = temp;

    already1:;
    }

  if (fail_delete)
    {
      struct temp_file *temp;
      for (temp = failure_delete_queue; temp; temp = temp->next)
 if (! filename_cmp (name, temp->name))
   goto already2;

      temp = XNEW (struct temp_file);
      temp->next = failure_delete_queue;
      temp->name = name;
      failure_delete_queue = temp;

    already2:;
    }
}
# 2006 "gcc.c"
static void
delete_if_ordinary (const char *name)
{
  struct stat st;
# 2022 "gcc.c"
  do { if (stat (name, &st) >= 0 && ((((st.st_mode)) & 0170000) == (0100000))) if (unlink (name) < 0) if (global_options.x_verbose_flag) perror_with_name (name); } while (0);
}

static void
delete_temp_files (void)
{
  struct temp_file *temp;

  for (temp = always_delete_queue; temp; temp = temp->next)
    delete_if_ordinary (temp->name);
  always_delete_queue = 0;
}



static void
delete_failure_queue (void)
{
  struct temp_file *temp;

  for (temp = failure_delete_queue; temp; temp = temp->next)
    delete_if_ordinary (temp->name);
}

static void
clear_failure_queue (void)
{
  failure_delete_queue = 0;
}
# 2065 "gcc.c"
static void *
for_each_path (const struct path_prefix *paths,
        unsigned char do_multi,
        size_t extra_space,
        void *(*callback) (char *, void *),
        void *callback_info)
{
  struct prefix_list *pl;
  const char *multi_dir = ((void *)0);
  const char *multi_os_dir = ((void *)0);
  const char *multi_suffix;
  const char *just_multi_suffix;
  char *path = ((void *)0);
  void *ret = ((void *)0);
  unsigned char skip_multi_dir = 0;
  unsigned char skip_multi_os_dir = 0;

  multi_suffix = machine_suffix;
  just_multi_suffix = just_machine_suffix;
  if (do_multi && multilib_dir && strcmp (multilib_dir, ".") != 0)
    {
      multi_dir = concat (multilib_dir, dir_separator_str, ((void *)0));
      multi_suffix = concat (multi_suffix, multi_dir, ((void *)0));
      just_multi_suffix = concat (just_multi_suffix, multi_dir, ((void *)0));
    }
  if (do_multi && multilib_os_dir && strcmp (multilib_os_dir, ".") != 0)
    multi_os_dir = concat (multilib_os_dir, dir_separator_str, ((void *)0));

  while (1)
    {
      size_t multi_dir_len = 0;
      size_t multi_os_dir_len = 0;
      size_t suffix_len;
      size_t just_suffix_len;
      size_t len;

      if (multi_dir)
 multi_dir_len = strlen (multi_dir);
      if (multi_os_dir)
 multi_os_dir_len = strlen (multi_os_dir);
      suffix_len = strlen (multi_suffix);
      just_suffix_len = strlen (just_multi_suffix);

      if (path == ((void *)0))
 {
   len = paths->max_len + extra_space + 1;
   if (suffix_len > multi_os_dir_len)
     len += suffix_len;
   else
     len += multi_os_dir_len;
   path = XNEWVEC (char, len);
 }

      for (pl = paths->plist; pl != 0; pl = pl->next)
 {
   len = strlen (pl->prefix);
   memcpy (path, pl->prefix, len);


   if (!skip_multi_dir)
     {
       memcpy (path + len, multi_suffix, suffix_len + 1);
       ret = callback (path, callback_info);
       if (ret)
  break;
     }



   if (!skip_multi_dir
       && pl->require_machine_suffix == 2)
     {
       memcpy (path + len, just_multi_suffix, just_suffix_len + 1);
       ret = callback (path, callback_info);
       if (ret)
  break;
     }


   if (!pl->require_machine_suffix
       && !(pl->os_multilib ? skip_multi_os_dir : skip_multi_dir))
     {
       const char *this_multi;
       size_t this_multi_len;

       if (pl->os_multilib)
  {
    this_multi = multi_os_dir;
    this_multi_len = multi_os_dir_len;
  }
       else
  {
    this_multi = multi_dir;
    this_multi_len = multi_dir_len;
  }

       if (this_multi_len)
  memcpy (path + len, this_multi, this_multi_len + 1);
       else
  path[len] = '\0';

       ret = callback (path, callback_info);
       if (ret)
  break;
     }
 }
      if (pl)
 break;

      if (multi_dir == ((void *)0) && multi_os_dir == ((void *)0))
 break;



      if (multi_dir)
 {
   free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((multi_dir)))));
   multi_dir = ((void *)0);
   free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((multi_suffix)))));
   multi_suffix = machine_suffix;
   free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((just_multi_suffix)))));
   just_multi_suffix = just_machine_suffix;
 }
      else
 skip_multi_dir = 1;
      if (multi_os_dir)
 {
   free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((multi_os_dir)))));
   multi_os_dir = ((void *)0);
 }
      else
 skip_multi_os_dir = 1;
    }

  if (multi_dir)
    {
      free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((multi_dir)))));
      free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((multi_suffix)))));
      free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((just_multi_suffix)))));
    }
  if (multi_os_dir)
    free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((multi_os_dir)))));
  if (ret != path)
    free (path);
  return ret;
}



struct add_to_obstack_info {
  struct obstack *ob;
  unsigned char check_dir;
  unsigned char first_time;
};

static void *
add_to_obstack (char *path, void *data)
{
  struct add_to_obstack_info *info = (struct add_to_obstack_info *) data;

  if (info->check_dir && !is_directory (path, 0))
    return ((void *)0);

  if (!info->first_time)
    __extension__ ({ struct obstack *__o = (info->ob); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (':')); (void) 0; });

  __extension__ ({ struct obstack *__o = (info->ob); int __len = (strlen (path)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, path, __len); __o->next_free += __len; (void) 0; });

  info->first_time = 0;
  return ((void *)0);
}



static void
xputenv (const char *string)
{
  if (global_options.x_verbose_flag)
    fnotice (stderr, "%s\n", string);
  putenv (((char *) helper_const_non_const_cast ((const char *) (const char *) ((string)))));
}
# 2255 "gcc.c"
static char *
build_search_list (const struct path_prefix *paths, const char *prefix,
     unsigned char check_dir, unsigned char do_multi)
{
  struct add_to_obstack_info info;

  info.ob = &collect_obstack;
  info.check_dir = check_dir;
  info.first_time = 1;

  __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (strlen (prefix)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, prefix, __len); __o->next_free += __len; (void) 0; });
  __extension__ ({ struct obstack *__o = (&collect_obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = ('=')); (void) 0; });

  for_each_path (paths, do_multi, 0, add_to_obstack, &info);

  __extension__ ({ struct obstack *__o = (&collect_obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = ('\0')); (void) 0; });
  return XOBFINISH (&collect_obstack, char *);
}




static void
putenv_from_prefixes (const struct path_prefix *paths, const char *env_var,
        unsigned char do_multi)
{
  xputenv (build_search_list (paths, env_var, 1, do_multi));
}




static int
access_check (const char *name, int mode)
{
  if (mode == 1)
    {
      struct stat st;

      if (stat (name, &st) < 0
   || ((((st.st_mode)) & 0170000) == (0040000)))
 return -1;
    }

  return access (name, mode);
}





struct file_at_path_info {
  const char *name;
  const char *suffix;
  int name_len;
  int suffix_len;
  int mode;
};

static void *
file_at_path (char *path, void *data)
{
  struct file_at_path_info *info = (struct file_at_path_info *) data;
  size_t len = strlen (path);

  memcpy (path + len, info->name, info->name_len);
  len += info->name_len;



  if (info->suffix_len)
    {
      memcpy (path + len, info->suffix, info->suffix_len + 1);
      if (access_check (path, info->mode) == 0)
 return path;
    }

  path[len] = '\0';
  if (access_check (path, info->mode) == 0)
    return path;

  return ((void *)0);
}






static char *
find_a_file (const struct path_prefix *pprefix, const char *name, int mode,
      unsigned char do_multi)
{
  struct file_at_path_info info;
# 2362 "gcc.c"
  if (IS_ABSOLUTE_PATH (name))
    {
      if (access (name, mode) == 0)
 return xstrdup (name);

      return ((void *)0);
    }

  info.name = name;
  info.suffix = (mode & 1) != 0 ? "" : "";
  info.name_len = strlen (info.name);
  info.suffix_len = strlen (info.suffix);
  info.mode = mode;

  return (char*) for_each_path (pprefix, do_multi,
    info.name_len + info.suffix_len,
    file_at_path, &info);
}




enum path_prefix_priority
{
  PREFIX_PRIORITY_B_OPT,
  PREFIX_PRIORITY_LAST
};
# 2404 "gcc.c"
static void
add_prefix (struct path_prefix *pprefix, const char *prefix,
     const char *component, int priority,
     int require_machine_suffix, int os_multilib)
{
  struct prefix_list *pl, **prev;
  int len;

  for (prev = &pprefix->plist;
       (*prev) != ((void *)0) && (*prev)->priority <= priority;
       prev = &(*prev)->next)
    ;



  prefix = update_path (prefix, component);
  len = strlen (prefix);
  if (len > pprefix->max_len)
    pprefix->max_len = len;

  pl = XNEW (struct prefix_list);
  pl->prefix = prefix;
  pl->require_machine_suffix = require_machine_suffix;
  pl->priority = priority;
  pl->os_multilib = os_multilib;


  pl->next = (*prev);
  (*prev) = pl;
}



static void
add_sysrooted_prefix (struct path_prefix *pprefix, const char *prefix,
        const char *component,
                                   int priority,
        int require_machine_suffix, int os_multilib)
{
  if (!IS_ABSOLUTE_PATH (prefix))
    fatal_error ("system path %qs is not absolute", prefix);

  if (target_system_root)
    {
      if (target_sysroot_suffix)
   prefix = concat (target_sysroot_suffix, prefix, ((void *)0));
      prefix = concat (target_system_root, prefix, ((void *)0));



      component = "GCC";
    }

  add_prefix (pprefix, prefix, component, priority,
       require_machine_suffix, os_multilib);
}







static int
execute (void)
{
  int i;
  int n_commands;
  char *string;
  struct pex_obj *pex;
  struct command
  {
    const char *prog;
    const char **argv;
  };
  const char *arg;

  struct command *commands;

  ((void)(!(!processing_spec_function) ? fancy_abort ("gcc.c", 2483, "?"), 0 : 0));

  if (global_options.x_wrapper_string)
    {
      string = find_a_file (&exec_prefixes,
       (VEC_const_char_p_base_index(((argbuf) ? &(argbuf)->base : 0),0 ,"gcc.c",2488,"?")), 1, 0);
      if (string)
 (VEC_const_char_p_base_replace(((argbuf) ? &(argbuf)->base : 0),0,string ,"gcc.c",2490,"?"));
      insert_wrapper (global_options.x_wrapper_string);
    }


  for (n_commands = 1, i = 0; (VEC_const_char_p_base_iterate(((argbuf) ? &(argbuf)->base : 0),i,&(arg))); i++)
    if (strcmp (arg, "|") == 0)
      n_commands++;


  commands = (struct command *) __builtin_alloca (n_commands * sizeof (struct command));





  (VEC_const_char_p_heap_safe_push(&(argbuf),0 ,"gcc.c",2506,"?" ));

  commands[0].prog = (VEC_const_char_p_base_index(((argbuf) ? &(argbuf)->base : 0),0 ,"gcc.c",2508,"?"));
  commands[0].argv = (VEC_const_char_p_base_address(((argbuf) ? &(argbuf)->base : 0)));

  if (!global_options.x_wrapper_string)
    {
      string = find_a_file (&exec_prefixes, commands[0].prog, 1, 0);
      commands[0].argv[0] = (string) ? string : commands[0].argv[0];
    }

  for (n_commands = 1, i = 0; (VEC_const_char_p_base_iterate(((argbuf) ? &(argbuf)->base : 0),i,&(arg))); i++)
    if (arg && strcmp (arg, "|") == 0)
      {



 (VEC_const_char_p_base_replace(((argbuf) ? &(argbuf)->base : 0),i,0 ,"gcc.c",2523,"?"));

 commands[n_commands].prog = (VEC_const_char_p_base_index(((argbuf) ? &(argbuf)->base : 0),i + 1 ,"gcc.c",2525,"?"));
 commands[n_commands].argv
   = &((VEC_const_char_p_base_address(((argbuf) ? &(argbuf)->base : 0))))[i + 1];
 string = find_a_file (&exec_prefixes, commands[n_commands].prog,
         1, 0);
 if (string)
   commands[n_commands].argv[0] = string;
 n_commands++;
      }



  if (global_options.x_verbose_flag)
    {

      if (print_help_list)
 fputc_unlocked ('\n', stderr);


      for (i = 0; i < n_commands; i++)
 {
   const char *const *j;

   if (verbose_only_flag)
     {
       for (j = commands[i].argv; *j; j++)
  {
    const char *p;
    for (p = *j; *p; ++p)
      if (!ISALNUM ((unsigned char) *p)
   && *p != '_' && *p != '/' && *p != '-' && *p != '.')
        break;
    if (*p || !*j)
      {
        fprintf (stderr, " \"");
        for (p = *j; *p; ++p)
   {
     if (*p == '"' || *p == '\\' || *p == '$')
       fputc_unlocked ('\\', stderr);
     fputc_unlocked (*p, stderr);
   }
        fputc_unlocked ('"', stderr);
      }

    else if (!**j)
      fprintf (stderr, " \"\"");
    else
      fprintf (stderr, " %s", *j);
  }
     }
   else
     for (j = commands[i].argv; *j; j++)

       if (!**j)
  fprintf (stderr, " \"\"");
       else
  fprintf (stderr, " %s", *j);


   if (i + 1 != n_commands)
     fprintf (stderr, " |");
   fprintf (stderr, "\n");
 }
      fflush_unlocked (stderr);
      if (verbose_only_flag != 0)
        {




   execution_count++;
   return 0;
        }
# 2609 "gcc.c"
    }
# 2640 "gcc.c"
  pex = pex_init (PEX_USE_PIPES | ((global_options.x_report_times || report_times_to_file)
       ? PEX_RECORD_TIMES : 0),
    progname, temp_filename);
  if (pex == ((void *)0))
    fatal_error ("pex_init failed: %m");

  for (i = 0; i < n_commands; i++)
    {
      const char *errmsg;
      int err;
      const char *string = commands[i].argv[0];

      errmsg = pex_run (pex,
   ((i + 1 == n_commands ? PEX_LAST : 0)
    | (string == commands[i].prog ? PEX_SEARCH : 0)),
   string, ((char **) helper_const_non_const_cast ((const char *) (const char **) ((commands[i].argv)))),
   ((void *)0), ((void *)0), &err);
      if (errmsg != ((void *)0))
 {
   if (err == 0)
     fatal_error (errmsg);
   else
     {
       (*__errno_location ()) = err;
       pfatal_with_name (errmsg);
     }
 }

      if (string != commands[i].prog)
 free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((string)))));
    }

  execution_count++;



  {
    int *statuses;
    struct pex_time *times = ((void *)0);
    int ret_code = 0;

    statuses = (int *) __builtin_alloca (n_commands * sizeof (int));
    if (!pex_get_status (pex, n_commands, statuses))
      fatal_error ("failed to get exit status: %m");

    if (global_options.x_report_times || report_times_to_file)
      {
 times = (struct pex_time *) __builtin_alloca (n_commands * sizeof (struct pex_time));
 if (!pex_get_times (pex, n_commands, times))
   fatal_error ("failed to get process times: %m");
      }

    pex_free (pex);

    for (i = 0; i < n_commands; ++i)
      {
 int status = statuses[i];

 if ((((signed char) ((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0x7f) + 1) >> 1) > 0))
   {







     if ((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0x7f) == 13
  && (signal_count || greatest_status >= 1))
       {
  signal_count++;
  ret_code = -1;
       }
     else

       internal_error ("%s (program %s)",
         strsignal ((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0x7f)), commands[i].prog);
   }
 else if (((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0x7f) == 0)
   && ((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0xff00) >> 8) >= 1)
   {
     if (((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0xff00) >> 8) > greatest_status)
       greatest_status = ((((__extension__ (((union { __typeof(status) __in; int __i; }) { .__in = (status) }).__i))) & 0xff00) >> 8);
     ret_code = -1;
   }

 if (global_options.x_report_times || report_times_to_file)
   {
     struct pex_time *pt = &times[i];
     double ut, st;

     ut = ((double) pt->user_seconds
    + (double) pt->user_microseconds / 1.0e6);
     st = ((double) pt->system_seconds
    + (double) pt->system_microseconds / 1.0e6);

     if (ut + st != 0)
       {
  if (global_options.x_report_times)
    fnotice (stderr, "# %s %.2f %.2f\n",
      commands[i].prog, ut, st);

  if (report_times_to_file)
    {
      int c = 0;
      const char *const *j;

      fprintf (report_times_to_file, "%g %g", ut, st);

      for (j = &commands[i].prog; *j; j = &commands[i].argv[++c])
        {
   const char *p;
   for (p = *j; *p; ++p)
     if (*p == '"' || *p == '\\' || *p == '$'
         || ISSPACE (*p))
       break;

   if (*p)
     {
       fprintf (report_times_to_file, " \"");
       for (p = *j; *p; ++p)
         {
    if (*p == '"' || *p == '\\' || *p == '$')
      fputc_unlocked ('\\', report_times_to_file);
    fputc_unlocked (*p, report_times_to_file);
         }
       fputc_unlocked ('"', report_times_to_file);
     }
   else
     fprintf (report_times_to_file, " %s", *j);
        }

      fputc_unlocked ('\n', report_times_to_file);
    }
       }
   }
      }

    return ret_code;
  }
}
# 2803 "gcc.c"
struct switchstr
{
  const char *part1;
  const char **args;
  unsigned int live_cond;
  unsigned char validated;
  unsigned char ordering;
};

static struct switchstr *switches;

static int n_switches;

static int n_switches_alloc;
# 2826 "gcc.c"
int compare_debug;


int compare_debug_second;



const char *compare_debug_opt;

static struct switchstr *switches_debug_check[2];

static int n_switches_debug_check[2];

static int n_switches_alloc_debug_check[2];

static char *debug_check_temp_file[2];
# 2850 "gcc.c"
struct infile
{
  const char *name;
  const char *language;
  struct compiler *incompiler;
  unsigned char compiled;
  unsigned char preprocessed;
};



static struct infile *infiles;

int n_infiles;

static int n_infiles_alloc;




static unsigned char combine_inputs;




static int added_libraries;



const char **outfiles;
# 2938 "gcc.c"
static void
display_help (void)
{
  printf (("Usage: %s [options] file...\n"), progname);
  fputs_unlocked (("Options:\n"), stdout);

  fputs_unlocked (("  -pass-exit-codes         Exit with highest error code from a phase\n"), stdout);
  fputs_unlocked (("  --help                   Display this information\n"), stdout);
  fputs_unlocked (("  --target-help            Display target specific command line options\n"), stdout);
  fputs_unlocked (("  --help={target|optimizers|warnings|params|[^]{joined|separate|undocumented}}[,...]\n"), stdout);
  fputs_unlocked (("                           Display specific types of command line options\n"), stdout);
  if (! global_options.x_verbose_flag)
    fputs_unlocked (("  (Use '-v --help' to display command line options of sub-processes)\n"), stdout);
  fputs_unlocked (("  --version                Display compiler version information\n"), stdout);
  fputs_unlocked (("  -dumpspecs               Display all of the built in spec strings\n"), stdout);
  fputs_unlocked (("  -dumpversion             Display the version of the compiler\n"), stdout);
  fputs_unlocked (("  -dumpmachine             Display the compiler's target processor\n"), stdout);
  fputs_unlocked (("  -print-search-dirs       Display the directories in the compiler's search path\n"), stdout);
  fputs_unlocked (("  -print-libgcc-file-name  Display the name of the compiler's companion library\n"), stdout);
  fputs_unlocked (("  -print-file-name=<lib>   Display the full path to library <lib>\n"), stdout);
  fputs_unlocked (("  -print-prog-name=<prog>  Display the full path to compiler component <prog>\n"), stdout);
  fputs_unlocked (("  -print-multi-directory   Display the root directory for versions of libgcc\n"), stdout);
  fputs_unlocked (("  -print-multi-lib         Display the mapping between command line options and\n                           multiple library search directories\n"), stdout);


  fputs_unlocked (("  -print-multi-os-directory Display the relative path to OS libraries\n"), stdout);
  fputs_unlocked (("  -print-sysroot           Display the target libraries directory\n"), stdout);
  fputs_unlocked (("  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers\n"), stdout);
  fputs_unlocked (("  -Wa,<options>            Pass comma-separated <options> on to the assembler\n"), stdout);
  fputs_unlocked (("  -Wp,<options>            Pass comma-separated <options> on to the preprocessor\n"), stdout);
  fputs_unlocked (("  -Wl,<options>            Pass comma-separated <options> on to the linker\n"), stdout);
  fputs_unlocked (("  -Xassembler <arg>        Pass <arg> on to the assembler\n"), stdout);
  fputs_unlocked (("  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor\n"), stdout);
  fputs_unlocked (("  -Xlinker <arg>           Pass <arg> on to the linker\n"), stdout);
  fputs_unlocked (("  -save-temps              Do not delete intermediate files\n"), stdout);
  fputs_unlocked (("  -save-temps=<arg>        Do not delete intermediate files\n"), stdout);
  fputs_unlocked (("  -no-canonical-prefixes   Do not canonicalize paths when building relative\n                           prefixes to other gcc components\n"), stdout);


  fputs_unlocked (("  -pipe                    Use pipes rather than intermediate files\n"), stdout);
  fputs_unlocked (("  -time                    Time the execution of each subprocess\n"), stdout);
  fputs_unlocked (("  -specs=<file>            Override built-in specs with the contents of <file>\n"), stdout);
  fputs_unlocked (("  -std=<standard>          Assume that the input sources are for <standard>\n"), stdout);
  fputs_unlocked (("  --sysroot=<directory>    Use <directory> as the root directory for headers\n                           and libraries\n"), stdout);


  fputs_unlocked (("  -B <directory>           Add <directory> to the compiler's search paths\n"), stdout);
  fputs_unlocked (("  -v                       Display the programs invoked by the compiler\n"), stdout);
  fputs_unlocked (("  -###                     Like -v but options quoted and commands not executed\n"), stdout);
  fputs_unlocked (("  -E                       Preprocess only; do not compile, assemble or link\n"), stdout);
  fputs_unlocked (("  -S                       Compile only; do not assemble or link\n"), stdout);
  fputs_unlocked (("  -c                       Compile and assemble, but do not link\n"), stdout);
  fputs_unlocked (("  -o <file>                Place the output into <file>\n"), stdout);
  fputs_unlocked (("  -x <language>            Specify the language of the following input files\n                           Permissible languages include: c c++ assembler none\n                           'none' means revert to the default behavior of\n                           guessing the language based on the file's extension\n"), stdout);






  printf (("\nOptions starting with -g, -f, -m, -O, -W, or --param are automatically\n passed on to the various sub-processes invoked by %s.  In order to pass\n other options on to these processes the -W<letter> options must be used.\n"), progname);







}

static void
add_preprocessor_option (const char *option, int len)
{
  (VEC_char_p_heap_safe_push(&(preprocessor_options),save_string (option, len) ,"gcc.c",3012,"?" ));

}

static void
add_assembler_option (const char *option, int len)
{
  (VEC_char_p_heap_safe_push(&(assembler_options),save_string (option, len) ,"gcc.c",3018,"?" ));
}

static void
add_linker_option (const char *option, int len)
{
  (VEC_char_p_heap_safe_push(&(linker_options),save_string (option, len) ,"gcc.c",3024,"?" ));
}



static void
alloc_infile (void)
{
  if (n_infiles_alloc == 0)
    {
      n_infiles_alloc = 16;
      infiles = XNEWVEC (struct infile, n_infiles_alloc);
    }
  else if (n_infiles_alloc == n_infiles)
    {
      n_infiles_alloc *= 2;
      infiles = XRESIZEVEC (struct infile, infiles, n_infiles_alloc);
    }
}




static void
add_infile (const char *name, const char *language)
{
  alloc_infile ();
  infiles[n_infiles].name = name;
  infiles[n_infiles++].language = language;
}



static void
alloc_switch (void)
{
  if (n_switches_alloc == 0)
    {
      n_switches_alloc = 16;
      switches = XNEWVEC (struct switchstr, n_switches_alloc);
    }
  else if (n_switches_alloc == n_switches)
    {
      n_switches_alloc *= 2;
      switches = XRESIZEVEC (struct switchstr, switches, n_switches_alloc);
    }
}




static void
save_switch (const char *opt, size_t n_args, const char *const *args,
      unsigned char validated)
{
  alloc_switch ();
  switches[n_switches].part1 = opt + 1;
  if (n_args == 0)
    switches[n_switches].args = 0;
  else
    {
      switches[n_switches].args = XNEWVEC (const char *, n_args + 1);
      memcpy (switches[n_switches].args, args, n_args * sizeof (const char *));
      switches[n_switches].args[n_args] = ((void *)0);
    }

  switches[n_switches].live_cond = 0;
  switches[n_switches].validated = validated;
  switches[n_switches].ordering = 0;
  n_switches++;
}




static unsigned char
driver_unknown_option_callback (const struct cl_decoded_option *decoded)
{
  const char *opt = decoded->arg;
  if (opt[1] == 'W' && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-'
      && !(decoded->errors & (1 << 5)))
    {


      save_switch (decoded->canonical_option[0],
     decoded->canonical_option_num_elements - 1,
     &decoded->canonical_option[1], 0);
      return 0;
    }
  else
    return 1;
}




static void
driver_wrong_lang_callback (const struct cl_decoded_option *decoded,
       unsigned int lang_mask ATTRIBUTE_UNUSED)
{





  const struct cl_option *option = &cl_options[decoded->opt_index];

  if (option->cl_reject_driver)
    error ("unrecognized command line option %qs",
    decoded->orig_option_with_args_text);
  else
    save_switch (decoded->canonical_option[0],
   decoded->canonical_option_num_elements - 1,
   &decoded->canonical_option[1], 0);
}




static void
driver_post_handling_callback (const struct cl_decoded_option *decoded ATTRIBUTE_UNUSED,
          unsigned int mask ATTRIBUTE_UNUSED)
{

}

static const char *spec_lang = 0;
static int last_language_n_infiles;




static unsigned char
driver_handle_option (struct gcc_options *opts,
        struct gcc_options *opts_set,
        const struct cl_decoded_option *decoded,
        unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,
        location_t loc,
        const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED,
        diagnostic_context *dc)
{
  size_t opt_index = decoded->opt_index;
  const char *arg = decoded->arg;
  const char *compare_debug_replacement_opt;
  int value = decoded->value;
  unsigned char validated = 0;
  unsigned char do_save = 1;

  ((void)(!(opts == &global_options) ? fancy_abort ("gcc.c", 3172, "?"), 0 : 0));
  ((void)(!(opts_set == &global_options_set) ? fancy_abort ("gcc.c", 3173, "?"), 0 : 0));
  ((void)(!(kind == DK_UNSPECIFIED) ? fancy_abort ("gcc.c", 3174, "?"), 0 : 0));
  ((void)(!(loc == ((source_location) 0)) ? fancy_abort ("gcc.c", 3175, "?"), 0 : 0));
  ((void)(!(dc == global_dc) ? fancy_abort ("gcc.c", 3176, "?"), 0 : 0));

  switch (opt_index)
    {
    case OPT_dumpspecs:
      {
 struct spec_list *sl;
 init_spec ();
 for (sl = specs; sl; sl = sl->next)
   printf ("*%s:\n%s\n\n", sl->name, *(sl->ptr_spec));
 if (link_command_spec)
   printf ("*link_command:\n%s\n\n", link_command_spec);
 exit (0);
      }

    case OPT_dumpversion:
      printf ("%s\n", spec_version);
      exit (0);

    case OPT_dumpmachine:
      printf ("%s\n", spec_machine);
      exit (0);

    case OPT__version:
      print_version = 1;


      if (is_cpp_driver)
 add_preprocessor_option ("--version", strlen ("--version"));
      add_assembler_option ("--version", strlen ("--version"));
      add_linker_option ("--version", strlen ("--version"));
      break;

    case OPT__help:
      print_help_list = 1;


      if (is_cpp_driver)
 add_preprocessor_option ("--help", 6);
      add_assembler_option ("--help", 6);
      add_linker_option ("--help", 6);
      break;

    case OPT__help_:
      print_subprocess_help = 2;
      break;

    case OPT__target_help:
      print_subprocess_help = 1;


      if (is_cpp_driver)
 add_preprocessor_option ("--target-help", 13);
      add_assembler_option ("--target-help", 13);
      add_linker_option ("--target-help", 13);
      break;

    case OPT_pass_exit_codes:
    case OPT_print_search_dirs:
    case OPT_print_file_name_:
    case OPT_print_prog_name_:
    case OPT_print_multi_lib:
    case OPT_print_multi_directory:
    case OPT_print_sysroot:
    case OPT_print_multi_os_directory:
    case OPT_print_sysroot_headers_suffix:
    case OPT_time:
    case OPT_wrapper:



      do_save = 0;
      break;

    case OPT_print_libgcc_file_name:
      global_options.x_print_file_name = "libgcc.a";
      do_save = 0;
      break;

    case OPT_fcompare_debug_second:
      compare_debug_second = 1;
      break;

    case OPT_fcompare_debug:
      switch (value)
 {
 case 0:
   compare_debug_replacement_opt = "-fcompare-debug=";
   arg = "";
   goto compare_debug_with_arg;

 case 1:
   compare_debug_replacement_opt = "-fcompare-debug=-gtoggle";
   arg = "-gtoggle";
   goto compare_debug_with_arg;

 default:
   (fancy_abort ("gcc.c", 3273, "?"));
 }
      break;

    case OPT_fcompare_debug_:
      compare_debug_replacement_opt = decoded->canonical_option[0];
    compare_debug_with_arg:
      ((void)(!(decoded->canonical_option_num_elements == 1) ? fancy_abort ("gcc.c", 3280, "?"), 0 : 0));
      ((void)(!(arg != ((void *)0)) ? fancy_abort ("gcc.c", 3281, "?"), 0 : 0));
      if (*arg)
 compare_debug = 1;
      else
 compare_debug = -1;
      if (compare_debug < 0)
 compare_debug_opt = ((void *)0);
      else
 compare_debug_opt = arg;
      save_switch (compare_debug_replacement_opt, 0, ((void *)0), validated);
      return 1;

    case OPT_Wa_:
      {
 int prev, j;



 prev = 0;
 for (j = 0; arg[j]; j++)
   if (arg[j] == ',')
     {
       add_assembler_option (arg + prev, j - prev);
       prev = j + 1;
     }


 add_assembler_option (arg + prev, j - prev);
      }
      do_save = 0;
      break;

    case OPT_Wp_:
      {
 int prev, j;



 prev = 0;
 for (j = 0; arg[j]; j++)
   if (arg[j] == ',')
     {
       add_preprocessor_option (arg + prev, j - prev);
       prev = j + 1;
     }


 add_preprocessor_option (arg + prev, j - prev);
      }
      do_save = 0;
      break;

    case OPT_Wl_:
      {
 int prev, j;

 prev = 0;
 for (j = 0; arg[j]; j++)
   if (arg[j] == ',')
     {
       add_infile (save_string (arg + prev, j - prev), "*");
       prev = j + 1;
     }

 add_infile (arg + prev, "*");
      }
      do_save = 0;
      break;

    case OPT_Xlinker:
      add_infile (arg, "*");
      do_save = 0;
      break;

    case OPT_Xpreprocessor:
      add_preprocessor_option (arg, strlen (arg));
      do_save = 0;
      break;

    case OPT_Xassembler:
      add_assembler_option (arg, strlen (arg));
      do_save = 0;
      break;

    case OPT_l:


      add_infile (concat ("-l", arg, ((void *)0)), "*");
      do_save = 0;
      break;

    case OPT_L:


      save_switch (concat ("-L", arg, ((void *)0)), 0, ((void *)0), validated);
      return 1;

    case OPT_F:

      save_switch (concat ("-F", arg, ((void *)0)), 0, ((void *)0), validated);
      return 1;

    case OPT_save_temps:
      save_temps_flag = SAVE_TEMPS_CWD;
      validated = 1;
      break;

    case OPT_save_temps_:
      if (strcmp (arg, "cwd") == 0)
 save_temps_flag = SAVE_TEMPS_CWD;
      else if (strcmp (arg, "obj") == 0
        || strcmp (arg, "object") == 0)
 save_temps_flag = SAVE_TEMPS_OBJ;
      else
 fatal_error ("%qs is an unknown -save-temps option",
       decoded->orig_option_with_args_text);
      break;

    case OPT_no_canonical_prefixes:

      do_save = 0;
      break;

    case OPT_pipe:
      validated = 1;



      break;

    case OPT_specs_:
      {
 struct user_specs *user = XNEW (struct user_specs);

 user->next = (struct user_specs *) 0;
 user->filename = arg;
 if (user_specs_tail)
   user_specs_tail->next = user;
 else
   user_specs_head = user;
 user_specs_tail = user;
      }
      do_save = 0;
      break;

    case OPT__sysroot_:
      target_system_root = arg;
      target_system_root_changed = 1;
      do_save = 0;
      break;

    case OPT_time_:
      if (report_times_to_file)
 fclose (report_times_to_file);
      report_times_to_file = fopen_unlocked(arg,"a");
      do_save = 0;
      break;

    case OPT____:





      verbose_only_flag++;
      global_options.x_verbose_flag = 1;
      do_save = 0;
      break;

    case OPT_B:
      {
 size_t len = strlen (arg);
# 3461 "gcc.c"
 if (!IS_DIR_SEPARATOR (arg[len - 1])
     && is_directory (arg, 0))
   {
     char *tmp = XNEWVEC (char, len + 2);
     strcpy (tmp, arg);
     tmp[len] = '/';
     tmp[++len] = 0;
     arg = tmp;
   }

 add_prefix (&exec_prefixes, arg, ((void *)0),
      PREFIX_PRIORITY_B_OPT, 0, 0);
 add_prefix (&startfile_prefixes, arg, ((void *)0),
      PREFIX_PRIORITY_B_OPT, 0, 0);
 add_prefix (&include_prefixes, arg, ((void *)0),
      PREFIX_PRIORITY_B_OPT, 0, 0);
      }
      validated = 1;
      break;

    case OPT_x:
      spec_lang = arg;
      if (!strcmp (spec_lang, "none"))



 spec_lang = 0;
      else
 last_language_n_infiles = n_infiles;
      do_save = 0;
      break;

    case OPT_o:
      have_o = 1;




      save_temps_prefix = xstrdup (arg);


      save_switch ("-o", 1, &arg, validated);
      return 1;

    case OPT_static_libgcc:
    case OPT_shared_libgcc:
    case OPT_static_libgfortran:
    case OPT_static_libstdc__:



      validated = 1;
      break;

    default:



      break;
    }

  if (do_save)
    save_switch (decoded->canonical_option[0],
   decoded->canonical_option_num_elements - 1,
   &decoded->canonical_option[1], validated);
  return 1;
}



static void
set_option_handlers (struct cl_option_handlers *handlers)
{
  handlers->unknown_option_callback = driver_unknown_option_callback;
  handlers->wrong_lang_callback = driver_wrong_lang_callback;
  handlers->post_handling_callback = driver_post_handling_callback;
  handlers->num_handlers = 3;
  handlers->handlers[0].handler = driver_handle_option;
  handlers->handlers[0].mask = (1U << 19);
  handlers->handlers[1].handler = common_handle_option;
  handlers->handlers[1].mask = (1U << 21);
  handlers->handlers[2].handler = target_handle_option;
  handlers->handlers[2].mask = (1U << 20);
}




static void
process_command (unsigned int decoded_options_count,
   struct cl_decoded_option *decoded_options)
{
  const char *temp;
  char *temp1;
  const char *tooldir_prefix;
  char *(*get_relative_prefix) (const char *, const char *,
    const char *) = ((void *)0);
  struct cl_option_handlers handlers;
  unsigned int j;

  gcc_exec_prefix = getenv ("GCC_EXEC_PREFIX");

  n_switches = 0;
  n_infiles = 0;
  added_libraries = 0;



  compiler_version = temp1 = xstrdup (version_string);

  for (; *temp1; ++temp1)
    {
      if (*temp1 == ' ')
 {
   *temp1 = '\0';
   break;
 }
    }





  for (j = 1; j < decoded_options_count; j++)
    {
      if (decoded_options[j].opt_index == OPT_no_canonical_prefixes)
 {
   get_relative_prefix = make_relative_prefix_ignore_links;
   break;
 }
    }
  if (! get_relative_prefix)
    get_relative_prefix = make_relative_prefix;





  gcc_libexec_prefix = standard_libexec_prefix;


  if (!gcc_exec_prefix)
    {
      gcc_exec_prefix = get_relative_prefix (decoded_options[0].arg,
          standard_bindir_prefix,
          standard_exec_prefix);
      gcc_libexec_prefix = get_relative_prefix (decoded_options[0].arg,
          standard_bindir_prefix,
          standard_libexec_prefix);
      if (gcc_exec_prefix)
 xputenv (concat ("GCC_EXEC_PREFIX=", gcc_exec_prefix, ((void *)0)));
    }
  else
    {




      char *tmp_prefix = concat (gcc_exec_prefix, "gcc", ((void *)0));
      gcc_libexec_prefix = get_relative_prefix (tmp_prefix,
      standard_exec_prefix,
      standard_libexec_prefix);


      if (!gcc_libexec_prefix)
 gcc_libexec_prefix = standard_libexec_prefix;

      free (tmp_prefix);
    }
# 3638 "gcc.c"
  lang_specific_driver (&decoded_options, &decoded_options_count,
   &added_libraries);

  if (gcc_exec_prefix)
    {
      int len = strlen (gcc_exec_prefix);

      if (len > (int) sizeof ("/lib/gcc/") - 1
   && (IS_DIR_SEPARATOR (gcc_exec_prefix[len-1])))
 {
   temp = gcc_exec_prefix + len - sizeof ("/lib/gcc/") + 1;
   if (IS_DIR_SEPARATOR (*temp)
       && filename_ncmp (temp + 1, "lib", 3) == 0
       && IS_DIR_SEPARATOR (temp[4])
       && filename_ncmp (temp + 5, "gcc", 3) == 0)
     len -= sizeof ("/lib/gcc/") - 1;
 }

      set_std_prefix (gcc_exec_prefix, len);
      add_prefix (&exec_prefixes, gcc_libexec_prefix, "GCC",
    PREFIX_PRIORITY_LAST, 0, 0);
      add_prefix (&startfile_prefixes, gcc_exec_prefix, "GCC",
    PREFIX_PRIORITY_LAST, 0, 0);
    }




  temp = getenv ("COMPILER_PATH");
  if (temp)
    {
      const char *startp, *endp;
      char *nstore = (char *) __builtin_alloca (strlen (temp) + 3);

      startp = endp = temp;
      while (1)
 {
   if (*endp == ':' || *endp == 0)
     {
       strncpy (nstore, startp, endp - startp);
       if (endp == startp)
  strcpy (nstore, concat (".", dir_separator_str, ((void *)0)));
       else if (!IS_DIR_SEPARATOR (endp[-1]))
  {
    nstore[endp - startp] = '/';
    nstore[endp - startp + 1] = 0;
  }
       else
  nstore[endp - startp] = 0;
       add_prefix (&exec_prefixes, nstore, 0,
     PREFIX_PRIORITY_LAST, 0, 0);
       add_prefix (&include_prefixes, nstore, 0,
     PREFIX_PRIORITY_LAST, 0, 0);
       if (*endp == 0)
  break;
       endp = startp = endp + 1;
     }
   else
     endp++;
 }
    }

  temp = getenv ("LIBRARY_PATH");
  if (temp && *cross_compile == '0')
    {
      const char *startp, *endp;
      char *nstore = (char *) __builtin_alloca (strlen (temp) + 3);

      startp = endp = temp;
      while (1)
 {
   if (*endp == ':' || *endp == 0)
     {
       strncpy (nstore, startp, endp - startp);
       if (endp == startp)
  strcpy (nstore, concat (".", dir_separator_str, ((void *)0)));
       else if (!IS_DIR_SEPARATOR (endp[-1]))
  {
    nstore[endp - startp] = '/';
    nstore[endp - startp + 1] = 0;
  }
       else
  nstore[endp - startp] = 0;
       add_prefix (&startfile_prefixes, nstore, ((void *)0),
     PREFIX_PRIORITY_LAST, 0, 1);
       if (*endp == 0)
  break;
       endp = startp = endp + 1;
     }
   else
     endp++;
 }
    }


  temp = getenv ("LPATH");
  if (temp && *cross_compile == '0')
    {
      const char *startp, *endp;
      char *nstore = (char *) __builtin_alloca (strlen (temp) + 3);

      startp = endp = temp;
      while (1)
 {
   if (*endp == ':' || *endp == 0)
     {
       strncpy (nstore, startp, endp - startp);
       if (endp == startp)
  strcpy (nstore, concat (".", dir_separator_str, ((void *)0)));
       else if (!IS_DIR_SEPARATOR (endp[-1]))
  {
    nstore[endp - startp] = '/';
    nstore[endp - startp + 1] = 0;
  }
       else
  nstore[endp - startp] = 0;
       add_prefix (&startfile_prefixes, nstore, ((void *)0),
     PREFIX_PRIORITY_LAST, 0, 1);
       if (*endp == 0)
  break;
       endp = startp = endp + 1;
     }
   else
     endp++;
 }
    }




  last_language_n_infiles = -1;

  set_option_handlers (&handlers);

  for (j = 1; j < decoded_options_count; j++)
    {
      switch (decoded_options[j].opt_index)
 {
 case OPT_S:
 case OPT_c:
 case OPT_E:
   have_c = 1;
   break;
 }
      if (have_c)
 break;
    }

  for (j = 1; j < decoded_options_count; j++)
    {
      if (decoded_options[j].opt_index == OPT_SPECIAL_input_file)
 {
   const char *arg = decoded_options[j].arg;
          const char *p = strrchr (arg, '@');
          char *fname;
   long offset;
   int consumed;






   if (p
       && p != arg
       && sscanf (p, "@%li%n", &offset, &consumed) >= 1
       && strlen (p) == (unsigned int)consumed)
     {
              fname = (char *)xmalloc (p - arg + 1);
              memcpy (fname, arg, p - arg);
              fname[p - arg] = '\0';


       if (strcmp (fname, "-") == 0 || access (fname, 0) < 0)
  {
    free (fname);
    fname = xstrdup (arg);
  }
     }
   else
     fname = xstrdup (arg);

          if (strcmp (fname, "-") != 0 && access (fname, 0) < 0)
     perror_with_name (fname);
          else
     add_infile (arg, spec_lang);

          free (fname);
   continue;
 }

      read_cmdline_option (&global_options, &global_options_set,
      decoded_options + j, ((source_location) 0),
      (1U << 19), &handlers, global_dc);
    }



  if (save_temps_flag == SAVE_TEMPS_OBJ && save_temps_prefix != ((void *)0))
    {
      save_temps_length = strlen (save_temps_prefix);
      temp = strrchr (lbasename (save_temps_prefix), '.');
      if (temp)
 {
   save_temps_length -= strlen (temp);
   save_temps_prefix[save_temps_length] = '\0';
 }

    }
  else if (save_temps_prefix != ((void *)0))
    {
      free (save_temps_prefix);
      save_temps_prefix = ((void *)0);
    }

  if (save_temps_flag && global_options.x_use_pipes)
    {

      if (save_temps_flag)
 warning (0, "-pipe ignored because -save-temps specified");
      global_options.x_use_pipes = 0;
    }

  if (!compare_debug)
    {
      const char *gcd = getenv ("GCC_COMPARE_DEBUG");

      if (gcd && gcd[0] == '-')
 {
   compare_debug = 2;
   compare_debug_opt = gcd;
 }
      else if (gcd && *gcd && strcmp (gcd, "0"))
 {
   compare_debug = 3;
   compare_debug_opt = "-gtoggle";
 }
    }
  else if (compare_debug < 0)
    {
      compare_debug = 0;
      ((void)(!(!compare_debug_opt) ? fancy_abort ("gcc.c", 3879, "?"), 0 : 0));
    }
# 3889 "gcc.c"
  if (!gcc_exec_prefix)
    {

      add_prefix (&exec_prefixes, standard_libexec_prefix, "GCC",
    PREFIX_PRIORITY_LAST, 1, 0);
      add_prefix (&exec_prefixes, standard_libexec_prefix, "BINUTILS",
    PREFIX_PRIORITY_LAST, 2, 0);
      add_prefix (&exec_prefixes, standard_exec_prefix, "BINUTILS",
    PREFIX_PRIORITY_LAST, 2, 0);

      add_prefix (&startfile_prefixes, standard_exec_prefix, "BINUTILS",
    PREFIX_PRIORITY_LAST, 1, 0);
    }

  ((void)(!(!IS_ABSOLUTE_PATH (tooldir_base_prefix)) ? fancy_abort ("gcc.c", 3903, "?"), 0 : 0));
  tooldir_prefix = concat (tooldir_base_prefix, spec_machine,
      dir_separator_str, ((void *)0));



  tooldir_prefix
    = concat (gcc_exec_prefix ? gcc_exec_prefix : standard_exec_prefix,
       spec_machine, dir_separator_str,
       spec_version, dir_separator_str, tooldir_prefix, ((void *)0));

  add_prefix (&exec_prefixes,
       concat (tooldir_prefix, "bin", dir_separator_str, ((void *)0)),
       "BINUTILS", PREFIX_PRIORITY_LAST, 0, 0);
  add_prefix (&startfile_prefixes,
       concat (tooldir_prefix, "lib", dir_separator_str, ((void *)0)),
       "BINUTILS", PREFIX_PRIORITY_LAST, 0, 1);
# 3942 "gcc.c"
  if (n_infiles == last_language_n_infiles && spec_lang != 0)
    warning (0, "%<-x %s%> after last input file has no effect", spec_lang);

  if (compare_debug == 2 || compare_debug == 3)
    {
      alloc_switch ();
      switches[n_switches].part1 = concat ("fcompare-debug=",
        compare_debug_opt,
        ((void *)0));
      switches[n_switches].args = 0;
      switches[n_switches].live_cond = 0;
      switches[n_switches].validated = 0;
      switches[n_switches].ordering = 0;
      n_switches++;
      compare_debug = 1;
    }


  if (print_subprocess_help || print_help_list || print_version)
    {
      n_infiles = 0;



      add_infile ("help-dummy", "c");
    }

  alloc_switch ();
  switches[n_switches].part1 = 0;
  alloc_infile ();
  infiles[n_infiles].name = 0;
}




static void
set_collect_gcc_options (void)
{
  int i;
  int first_time;



  __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (sizeof ("COLLECT_GCC_OPTIONS=") - 1); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "COLLECT_GCC_OPTIONS=", __len); __o->next_free += __len; (void) 0; });


  first_time = 1;
  for (i = 0; (int) i < n_switches; i++)
    {
      const char *const *args;
      const char *p, *q;
      if (!first_time)
 __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (1); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, " ", __len); __o->next_free += __len; (void) 0; });

      first_time = 0;


      if ((switches[i].live_cond
    & ((1 << 2) | (1 << 4)))
   == (1 << 2))
 continue;

      __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (2); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "'-", __len); __o->next_free += __len; (void) 0; });
      q = switches[i].part1;
      while ((p = strchr (q, '\'')))
 {
   __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (p - q); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, q, __len); __o->next_free += __len; (void) 0; });
   __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (4); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "'\\''", __len); __o->next_free += __len; (void) 0; });
   q = ++p;
 }
      __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (strlen (q)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, q, __len); __o->next_free += __len; (void) 0; });
      __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (1); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "'", __len); __o->next_free += __len; (void) 0; });

      for (args = switches[i].args; args && *args; args++)
 {
   __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (2); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, " '", __len); __o->next_free += __len; (void) 0; });
   q = *args;
   while ((p = strchr (q, '\'')))
     {
       __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (p - q); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, q, __len); __o->next_free += __len; (void) 0; });
       __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (4); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "'\\''", __len); __o->next_free += __len; (void) 0; });
       q = ++p;
     }
   __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (strlen (q)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, q, __len); __o->next_free += __len; (void) 0; });
   __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (1); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "'", __len); __o->next_free += __len; (void) 0; });
 }
    }
  __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (1); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "\0", __len); __o->next_free += __len; (void) 0; });
  xputenv (XOBFINISH (&collect_obstack, char *));
}
# 4043 "gcc.c"
static const char *gcc_input_filename;
static int input_file_number;
size_t input_filename_length;
static int basename_length;
static int suffixed_basename_length;
static const char *input_basename;
static const char *input_suffix;

static struct stat input_stat;

static int input_stat_set;


static struct compiler *input_file_compiler;





static int arg_going;



static int delete_this_arg;



static int this_is_output_file;




static int this_is_library_file;






static int this_is_linker_script;


static int input_from_pipe;



static const char *suffix_subst;



static void
end_going_arg (void)
{
  if (arg_going)
    {
      const char *string;

      __extension__ ({ struct obstack *__o = (&obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (0)); (void) 0; });
      string = XOBFINISH (&obstack, const char *);
      if (this_is_library_file)
 string = find_file (string);
      if (this_is_linker_script)
 {
   char * full_script_path = find_a_file (&startfile_prefixes, string, 4, 1);

   if (full_script_path == ((void *)0))
     {
       error ("unable to locate default linker script %qs in the library search paths", string);

       return;
     }
   store_arg ("--script", 0, 0);
   string = full_script_path;
 }
      store_arg (string, delete_this_arg, this_is_output_file);
      if (this_is_output_file)
 outfiles[input_file_number] = string;
      arg_going = 0;
    }
}





static void
insert_wrapper (const char *wrapper)
{
  int n = 0;
  int i;
  char *buf = xstrdup (wrapper);
  char *p = buf;
  unsigned int old_length = (VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0)));

  do
    {
      n++;
      while (*p == ',')
        p++;
    }
  while ((p = strchr (p, ',')) != ((void *)0));

  (VEC_const_char_p_heap_safe_grow(&(argbuf),old_length + n ,"gcc.c",4145,"?" ));
  memmove ((VEC_const_char_p_base_address(((argbuf) ? &(argbuf)->base : 0))) + n,
    (VEC_const_char_p_base_address(((argbuf) ? &(argbuf)->base : 0))),
    old_length * sizeof (const_char_p));

  i = 0;
  p = buf;
  do
    {
      while (*p == ',')
        {
          *p = 0;
          p++;
        }
      (VEC_const_char_p_base_replace(((argbuf) ? &(argbuf)->base : 0),i,p ,"gcc.c",4159,"?"));
      i++;
    }
  while ((p = strchr (p, ',')) != ((void *)0));
  ((void)(!(i == n) ? fancy_abort ("gcc.c", 4163, "?"), 0 : 0));
}




int
do_spec (const char *spec)
{
  int value;

  value = do_spec_2 (spec);



  if (value == 0)
    {
      if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 0
   && !strcmp ((VEC_const_char_p_base_last(((argbuf) ? &(argbuf)->base : 0) ,"gcc.c",4181,"?")), "|"))
 (VEC_const_char_p_base_pop(((argbuf) ? &(argbuf)->base : 0) ,"gcc.c",4182,"?"));

      set_collect_gcc_options ();

      if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 0)
 value = execute ();
    }

  return value;
}

static int
do_spec_2 (const char *spec)
{
  int result;

  clear_args ();
  arg_going = 0;
  delete_this_arg = 0;
  this_is_output_file = 0;
  this_is_library_file = 0;
  this_is_linker_script = 0;
  input_from_pipe = 0;
  suffix_subst = ((void *)0);

  result = do_spec_1 (spec, 0, ((void *)0));

  end_going_arg ();

  return result;
}





static void
do_option_spec (const char *name, const char *spec)
{
  unsigned int i, value_count, value_len;
  const char *p, *q, *value;
  char *tmp_spec, *tmp_spec_p;

  if (configure_default_options[0].name == ((void *)0))
    return;

  for (i = 0; i < ARRAY_SIZE (configure_default_options); i++)
    if (strcmp (configure_default_options[i].name, name) == 0)
      break;
  if (i == ARRAY_SIZE (configure_default_options))
    return;

  value = configure_default_options[i].value;
  value_len = strlen (value);


  value_count = 0;
  p = spec;
  while ((p = strstr (p, "%(VALUE)")) != ((void *)0))
    {
      p ++;
      value_count ++;
    }


  tmp_spec = (char *) __builtin_alloca (strlen (spec) + 1 + value_count * (value_len - strlen ("%(VALUE)")));

  tmp_spec_p = tmp_spec;
  q = spec;
  while ((p = strstr (q, "%(VALUE)")) != ((void *)0))
    {
      memcpy (tmp_spec_p, q, p - q);
      tmp_spec_p = tmp_spec_p + (p - q);
      memcpy (tmp_spec_p, value, value_len);
      tmp_spec_p += value_len;
      q = p + strlen ("%(VALUE)");
    }
  strcpy (tmp_spec_p, q);

  do_self_spec (tmp_spec);
}




static void
do_self_spec (const char *spec)
{
  int i;

  do_spec_2 (spec);
  do_spec_1 (" ", 0, ((void *)0));




  for (i = 0; i < n_switches; i++)
    if ((switches[i].live_cond & (1 << 2)))
      switches[i].live_cond |= (1 << 3);

  if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 0)
    {
      const char **argbuf_copy;
      struct cl_decoded_option *decoded_options;
      struct cl_option_handlers handlers;
      unsigned int decoded_options_count;
      unsigned int j;



      argbuf_copy = XNEWVEC (const char *,
        (VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) + 1);
      argbuf_copy[0] = "";
      memcpy (argbuf_copy + 1, (VEC_const_char_p_base_address(((argbuf) ? &(argbuf)->base : 0))),
       (VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) * sizeof (const char *));

      decode_cmdline_options_to_array ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) + 1,
           argbuf_copy,
           (1U << 19), &decoded_options,
           &decoded_options_count);

      set_option_handlers (&handlers);

      for (j = 1; j < decoded_options_count; j++)
 {
   switch (decoded_options[j].opt_index)
     {
     case OPT_SPECIAL_input_file:


       if (strcmp (decoded_options[j].arg, "-") != 0)
  fatal_error ("switch %qs does not start with %<-%>",
        decoded_options[j].arg);
       else
  fatal_error ("spec-generated switch is just %<-%>");
       break;

     case OPT_fcompare_debug_second:
     case OPT_fcompare_debug:
     case OPT_fcompare_debug_:
     case OPT_o:


       save_switch (decoded_options[j].canonical_option[0],
      (decoded_options[j].canonical_option_num_elements
       - 1),
      &decoded_options[j].canonical_option[1], 0);
       break;

     default:
       read_cmdline_option (&global_options, &global_options_set,
       decoded_options + j, ((source_location) 0),
       (1U << 19), &handlers, global_dc);
       break;
     }
 }

      alloc_switch ();
      switches[n_switches].part1 = 0;
    }
}



struct spec_path_info {
  const char *option;
  const char *append;
  size_t append_len;
  unsigned char omit_relative;
  unsigned char separate_options;
};

static void *
spec_path (char *path, void *data)
{
  struct spec_path_info *info = (struct spec_path_info *) data;
  size_t len = 0;
  char save = 0;

  if (info->omit_relative && !IS_ABSOLUTE_PATH (path))
    return ((void *)0);

  if (info->append_len != 0)
    {
      len = strlen (path);
      memcpy (path + len, info->append, info->append_len + 1);
    }

  if (!is_directory (path, 1))
    return ((void *)0);

  do_spec_1 (info->option, 1, ((void *)0));
  if (info->separate_options)
    do_spec_1 (" ", 0, ((void *)0));

  if (info->append_len == 0)
    {
      len = strlen (path);
      save = path[len - 1];
      if (IS_DIR_SEPARATOR (path[len - 1]))
 path[len - 1] = '\0';
    }

  do_spec_1 (path, 1, ((void *)0));
  do_spec_1 (" ", 0, ((void *)0));


  if (info->append_len == 0)
    path[len - 1] = save;

  return ((void *)0);
}




static void
create_at_file (char **argv)
{
  char *temp_file = make_temp_file ("");
  char *at_argument = concat ("@", temp_file, ((void *)0));
  FILE *f = fopen_unlocked(temp_file,"w");
  int status;

  if (f == ((void *)0))
    fatal_error ("could not open temporary response file %s",
   temp_file);

  status = writeargv (argv, f);

  if (status)
    fatal_error ("could not write to temporary response file %s",
   temp_file);

  status = fclose (f);

  if ((-1) == status)
    fatal_error ("could not close temporary response file %s",
   temp_file);

  store_arg (at_argument, 0, 0);

  record_temp_file (temp_file, !save_temps_flag, !save_temps_flag);
}



static unsigned char
compile_input_file_p (struct infile *infile)
{
  if ((!infile->language) || (infile->language[0] != '*'))
    if (infile->incompiler == input_file_compiler)
      return 1;
  return 0;
}



static void
do_specs_vec (VEC_char_p_heap *vec)
{
  unsigned ix;
  char *opt;

  for (ix = 0; (VEC_char_p_base_iterate((((vec)) ? &((vec))->base : 0),(ix),&((opt)))); ++(ix))
    {
      do_spec_1 (opt, 1, ((void *)0));

      do_spec_1 (" ", 0, ((void *)0));
    }
}
# 4466 "gcc.c"
static int
do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)
{
  const char *p = spec;
  int c;
  int i;
  int value;


  if (inswitch && !*p)
    arg_going = 1;

  while ((c = *p++))


    switch (inswitch ? 'a' : c)
      {
      case '\n':
 end_going_arg ();

 if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 0
     && !strcmp ((VEC_const_char_p_base_last(((argbuf) ? &(argbuf)->base : 0) ,"gcc.c",4487,"?")), "|"))
   {



     if (global_options.x_use_pipes)
       {
  input_from_pipe = 1;
  break;
       }
     else
       (VEC_const_char_p_base_pop(((argbuf) ? &(argbuf)->base : 0) ,"gcc.c",4498,"?"));
   }

 set_collect_gcc_options ();

 if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 0)
   {
     value = execute ();
     if (value)
       return value;
   }

 clear_args ();
 arg_going = 0;
 delete_this_arg = 0;
 this_is_output_file = 0;
 this_is_library_file = 0;
 this_is_linker_script = 0;
 input_from_pipe = 0;
 break;

      case '|':
 end_going_arg ();


 __extension__ ({ struct obstack *__o = (&obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (c)); (void) 0; });
 arg_going = 1;
 break;

      case '\t':
      case ' ':
 end_going_arg ();


 delete_this_arg = 0;
 this_is_output_file = 0;
 this_is_library_file = 0;
 this_is_linker_script = 0;
 break;

      case '%':
 switch (c = *p++)
   {
   case 0:
     fatal_error ("spec %qs invalid", spec);

   case 'b':
     if (save_temps_length)
       __extension__ ({ struct obstack *__o = (&obstack); int __len = (save_temps_length); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, save_temps_prefix, __len); __o->next_free += __len; (void) 0; });
     else
       __extension__ ({ struct obstack *__o = (&obstack); int __len = (basename_length); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, input_basename, __len); __o->next_free += __len; (void) 0; });
     if (compare_debug < 0)
       __extension__ ({ struct obstack *__o = (&obstack); int __len = (3); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, ".gk", __len); __o->next_free += __len; (void) 0; });
     arg_going = 1;
     break;

   case 'B':
     if (save_temps_length)
       __extension__ ({ struct obstack *__o = (&obstack); int __len = (save_temps_length); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, save_temps_prefix, __len); __o->next_free += __len; (void) 0; });
     else
       __extension__ ({ struct obstack *__o = (&obstack); int __len = (suffixed_basename_length); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, input_basename, __len); __o->next_free += __len; (void) 0; });
     if (compare_debug < 0)
       __extension__ ({ struct obstack *__o = (&obstack); int __len = (3); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, ".gk", __len); __o->next_free += __len; (void) 0; });
     arg_going = 1;
     break;

   case 'd':
     delete_this_arg = 2;
     break;




   case 'D':
     {
       struct spec_path_info info;

       info.option = "-L";
       info.append_len = 0;
# 4585 "gcc.c"
       info.omit_relative = 0;

       info.separate_options = 0;

       for_each_path (&startfile_prefixes, 1, 0, spec_path, &info);
     }
     break;

   case 'e':


     {
       const char *q = p;
       char *buf;
       while (*p != 0 && *p != '\n')
  p++;
       buf = (char *) __builtin_alloca (p - q + 1);
       strncpy (buf, q, p - q);
       buf[p - q] = 0;
       error ("%s", (buf));
       return -1;
     }
     break;
   case 'n':

     {
       const char *q = p;
       char *buf;
       while (*p != 0 && *p != '\n')
  p++;
       buf = (char *) __builtin_alloca (p - q + 1);
       strncpy (buf, q, p - q);
       buf[p - q] = 0;
       inform (0, "%s", (buf));
       if (*p)
  p++;
     }
     break;

   case 'j':
     {
       struct stat st;






       if ((!save_temps_flag)
    && (stat ("/dev/null", &st) == 0) && (!((((st.st_mode)) & 0170000) == (0040000)))
    && (access ("/dev/null", 2) == 0))
  {
    __extension__ ({ struct obstack *__o = (&obstack); int __len = (strlen ("/dev/null")); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "/dev/null", __len); __o->next_free += __len; (void) 0; });

    delete_this_arg = 0;
    arg_going = 1;
    break;
  }
     }
     goto create_temp_file;
   case '|':
     if (global_options.x_use_pipes)
       {
  __extension__ ({ struct obstack *__o = (&obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = ('-')); (void) 0; });
  delete_this_arg = 0;
  arg_going = 1;


  while (*p == '.' || ISALNUM ((unsigned char) *p))
    p++;
  if (p[0] == '%' && p[1] == 'O')
    p += 2;

  break;
       }
     goto create_temp_file;
   case 'm':
     if (global_options.x_use_pipes)
       {

  while (*p == '.' || ISALNUM ((unsigned char) *p))
    p++;
  if (p[0] == '%' && p[1] == 'O')
    p += 2;

  break;
       }
     goto create_temp_file;
   case 'g':
   case 'u':
   case 'U':
   create_temp_file:
       {
  struct temp_name *t;
  int suffix_length;
  const char *suffix = p;
  char *saved_suffix = ((void *)0);

  while (*p == '.' || ISALNUM ((unsigned char) *p))
    p++;
  suffix_length = p - suffix;
  if (p[0] == '%' && p[1] == 'O')
    {
      p += 2;

      if (*p == '.' || ISALNUM ((unsigned char) *p))
        fatal_error ("spec %qs has invalid %<%%0%c%>", spec, *p);
      if (suffix_length == 0)
        suffix = ".o";
      else
        {
   saved_suffix
     = XNEWVEC (char, suffix_length
         + strlen (".o"));
   strncpy (saved_suffix, suffix, suffix_length);
   strcpy (saved_suffix + suffix_length,
    ".o");
        }
      suffix_length += strlen (".o");
    }

  if (compare_debug < 0)
    {
      suffix = concat (".gk", suffix, ((void *)0));
      suffix_length += 3;
    }



  if (save_temps_length)
    {
      char *tmp;
      temp_filename_length
        = save_temps_length + suffix_length + 1;
      tmp = (char *) __builtin_alloca (temp_filename_length);
      memcpy (tmp, save_temps_prefix, save_temps_length);
      memcpy (tmp + save_temps_length, suffix, suffix_length);
      tmp[save_temps_length + suffix_length] = '\0';
      temp_filename = save_string (tmp,
       temp_filename_length + 1);
      __extension__ ({ struct obstack *__o = (&obstack); int __len = (temp_filename_length); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, temp_filename, __len); __o->next_free += __len; (void) 0; });

      arg_going = 1;
      delete_this_arg = 0;
      break;
    }
# 4740 "gcc.c"
  if (save_temps_flag)
    {
      char *tmp;
      temp_filename_length = basename_length + suffix_length + 1;
      tmp = (char *) __builtin_alloca (temp_filename_length);
      memcpy (tmp, input_basename, basename_length);
      memcpy (tmp + basename_length, suffix, suffix_length);
      tmp[basename_length + suffix_length] = '\0';
      temp_filename = tmp;

      if (filename_cmp (temp_filename, gcc_input_filename) != 0)
        {

   struct stat st_temp;


   if (input_stat_set == 0)
     {
       input_stat_set = stat (gcc_input_filename,
         &input_stat);
       if (input_stat_set >= 0)
         input_stat_set = 1;
     }





   if (input_stat_set != 1
       || stat (temp_filename, &st_temp) < 0
       || input_stat.st_dev != st_temp.st_dev
       || input_stat.st_ino != st_temp.st_ino)
# 4781 "gcc.c"
     {
       temp_filename = save_string (temp_filename,
        temp_filename_length + 1);
       __extension__ ({ struct obstack *__o = (&obstack); int __len = (temp_filename_length); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, temp_filename, __len); __o->next_free += __len; (void) 0; });

       arg_going = 1;
       delete_this_arg = 0;
       break;
     }
        }
    }



  for (t = temp_names; t; t = t->next)
    if (t->length == suffix_length
        && strncmp (t->suffix, suffix, suffix_length) == 0
        && t->unique == (c == 'u' || c == 'U' || c == 'j'))
      break;



  if (t == 0 || c == 'u' || c == 'j')
    {
      if (t == 0)
        {
   t = XNEW (struct temp_name);
   t->next = temp_names;
   temp_names = t;
        }
      t->length = suffix_length;
      if (saved_suffix)
        {
   t->suffix = saved_suffix;
   saved_suffix = ((void *)0);
        }
      else
        t->suffix = save_string (suffix, suffix_length);
      t->unique = (c == 'u' || c == 'U' || c == 'j');
      temp_filename = make_temp_file (t->suffix);
      temp_filename_length = strlen (temp_filename);
      t->filename = temp_filename;
      t->filename_length = temp_filename_length;
    }

  free (saved_suffix);

  __extension__ ({ struct obstack *__o = (&obstack); int __len = (t->filename_length); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, t->filename, __len); __o->next_free += __len; (void) 0; });
  delete_this_arg = 1;
       }
     arg_going = 1;
     break;

   case 'i':
     if (combine_inputs)
       {
  if (at_file_supplied)
    {




      char **argv;
      int n_files = 0;
      int j;

      for (i = 0; i < n_infiles; i++)
        if (compile_input_file_p (&infiles[i]))
   n_files++;

      argv = (char **) __builtin_alloca (sizeof (char *) * (n_files + 1));


      for (i = 0, j = 0; i < n_infiles; i++)
        if (compile_input_file_p (&infiles[i]))
   {
     argv[j] = ((char *) helper_const_non_const_cast ((const char *) (const char *) ((infiles[i].name))));
     infiles[i].compiled = 1;
     j++;
   }
      argv[j] = ((void *)0);

      create_at_file (argv);
    }
  else
    for (i = 0; (int) i < n_infiles; i++)
      if (compile_input_file_p (&infiles[i]))
        {
   store_arg (infiles[i].name, 0, 0);
   infiles[i].compiled = 1;
        }
       }
     else
       {
  __extension__ ({ struct obstack *__o = (&obstack); int __len = (input_filename_length); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, gcc_input_filename, __len); __o->next_free += __len; (void) 0; });

  arg_going = 1;
       }
     break;

   case 'I':
     {
       struct spec_path_info info;

       if (multilib_dir)
  {
    do_spec_1 ("-imultilib", 1, ((void *)0));

    do_spec_1 (" ", 0, ((void *)0));
    do_spec_1 (multilib_dir, 1, ((void *)0));
    do_spec_1 (" ", 0, ((void *)0));
  }

       if (gcc_exec_prefix)
  {
    do_spec_1 ("-iprefix", 1, ((void *)0));

    do_spec_1 (" ", 0, ((void *)0));
    do_spec_1 (gcc_exec_prefix, 1, ((void *)0));
    do_spec_1 (" ", 0, ((void *)0));
  }

       if (target_system_root_changed ||
    (target_system_root && target_sysroot_hdrs_suffix))
  {
    do_spec_1 ("-isysroot", 1, ((void *)0));

    do_spec_1 (" ", 0, ((void *)0));
    do_spec_1 (target_system_root, 1, ((void *)0));
    if (target_sysroot_hdrs_suffix)
      do_spec_1 (target_sysroot_hdrs_suffix, 1, ((void *)0));
    do_spec_1 (" ", 0, ((void *)0));
  }

       info.option = "-isystem";
       info.append = "include";
       info.append_len = strlen (info.append);
       info.omit_relative = 0;
       info.separate_options = 1;

       for_each_path (&include_prefixes, 0, info.append_len,
        spec_path, &info);

       info.append = "include-fixed";
       if (*sysroot_hdrs_suffix_spec)
  info.append = concat (info.append, dir_separator_str,
          multilib_dir, ((void *)0));
       info.append_len = strlen (info.append);
       for_each_path (&include_prefixes, 0, info.append_len,
        spec_path, &info);
     }
     break;

   case 'o':
     {
       int max = n_infiles;
       max += lang_specific_extra_outfiles;

              if (0 && at_file_supplied)
                {





                  char **argv;
                  int n_files, j;




                  for (n_files = 0, i = 0; i < max; i++)
                    n_files += outfiles[i] != ((void *)0);

                  argv = (char **) __builtin_alloca (sizeof (char *) * (n_files + 1));


                  for (i = 0, j = 0; i < max; i++)
                    if (outfiles[i])
                      {
                        argv[j] = ((char *) helper_const_non_const_cast ((const char *) (const char *) ((outfiles[i]))));
                        j++;
                      }
                  argv[j] = ((void *)0);

    create_at_file (argv);
                }
              else
                for (i = 0; i < max; i++)
           if (outfiles[i])
      store_arg (outfiles[i], 0, 0);
       break;
     }

   case 'O':
     __extension__ ({ struct obstack *__o = (&obstack); int __len = (strlen (".o")); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, ".o", __len); __o->next_free += __len; (void) 0; });
     arg_going = 1;
     break;

   case 's':
     this_is_library_file = 1;
     break;

   case 'T':
     this_is_linker_script = 1;
     break;

   case 'V':
     outfiles[input_file_number] = ((void *)0);
     break;

   case 'w':
     this_is_output_file = 1;
     break;

   case 'W':
     {
       unsigned int cur_index = (VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0)));

       if (*p != '{')
  fatal_error ("spec %qs has invalid %<%%W%c%>", spec, *p);
       p = handle_braces (p + 1);
       if (p == 0)
  return -1;
       end_going_arg ();


       if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) != cur_index)
  record_temp_file ((VEC_const_char_p_base_last(((argbuf) ? &(argbuf)->base : 0) ,"gcc.c",5009,"?")), 0, 1);
       break;
     }


   case 'x':
     {
       const char *p1 = p;
       char *string;
       char *opt;
       unsigned ix;


       if (*p != '{')
  fatal_error ("spec %qs has invalid %<%%x%c%>", spec, *p);
       while (*p++ != '}')
  ;
       string = save_string (p1 + 1, p - p1 - 2);


       for (ix = 0; (VEC_char_p_base_iterate((((linker_options)) ? &((linker_options))->base : 0),(ix),&((opt)))); ++(ix))
  if (! strcmp (string, opt))
    {
      free (string);
      return 0;
    }


       add_linker_option (string, strlen (string));
     }
     break;


   case 'X':
     do_specs_vec (linker_options);
     break;


   case 'Y':
     do_specs_vec (assembler_options);
     break;


   case 'Z':
     do_specs_vec (preprocessor_options);
     break;




   case '1':
     value = do_spec_1 (cc1_spec, 0, ((void *)0));
     if (value != 0)
       return value;
     break;

   case '2':
     value = do_spec_1 (cc1plus_spec, 0, ((void *)0));
     if (value != 0)
       return value;
     break;

   case 'a':
     value = do_spec_1 (asm_spec, 0, ((void *)0));
     if (value != 0)
       return value;
     break;

   case 'A':
     value = do_spec_1 (asm_final_spec, 0, ((void *)0));
     if (value != 0)
       return value;
     break;

   case 'C':
     {
       const char *const spec
  = (input_file_compiler->cpp_spec
     ? input_file_compiler->cpp_spec
     : cpp_spec);
       value = do_spec_1 (spec, 0, ((void *)0));
       if (value != 0)
  return value;
     }
     break;

   case 'E':
     value = do_spec_1 (endfile_spec, 0, ((void *)0));
     if (value != 0)
       return value;
     break;

   case 'l':
     value = do_spec_1 (link_spec, 0, ((void *)0));
     if (value != 0)
       return value;
     break;

   case 'L':
     value = do_spec_1 (lib_spec, 0, ((void *)0));
     if (value != 0)
       return value;
     break;

   case 'G':
     value = do_spec_1 (libgcc_spec, 0, ((void *)0));
     if (value != 0)
       return value;
     break;

   case 'R':


     if (target_system_root)
       {
         __extension__ ({ struct obstack *__o = (&obstack); int __len = (strlen (target_system_root)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, target_system_root, __len); __o->next_free += __len; (void) 0; });

  if (target_sysroot_suffix)
    __extension__ ({ struct obstack *__o = (&obstack); int __len = (strlen (target_sysroot_suffix)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, target_sysroot_suffix, __len); __o->next_free += __len; (void) 0; });

       }
     break;

   case 'S':
     value = do_spec_1 (startfile_spec, 0, ((void *)0));
     if (value != 0)
       return value;
     break;



   case '{':
     p = handle_braces (p);
     if (p == 0)
       return -1;
     break;

   case ':':
     p = handle_spec_function (p);
     if (p == 0)
       return -1;
     break;

   case '%':
     __extension__ ({ struct obstack *__o = (&obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = ('%')); (void) 0; });
     break;

   case '.':
     {
       unsigned len = 0;

       while (p[len] && p[len] != ' ' && p[len] != '%')
  len++;
       suffix_subst = save_string (p - 1, len + 1);
       p += len;
     }
    break;



   case '<':
   case '>':
     {
       unsigned len = 0;
       int have_wildcard = 0;
       int i;
       int switch_option;

       if (c == '>')
  switch_option = (1 << 2) | (1 << 4);
       else
  switch_option = (1 << 2);

       while (p[len] && p[len] != ' ' && p[len] != '\t')
  len++;

       if (p[len-1] == '*')
  have_wildcard = 1;

       for (i = 0; i < n_switches; i++)
  if (!strncmp (switches[i].part1, p, len - have_wildcard)
      && (have_wildcard || switches[i].part1[len] == '\0'))
    {
      switches[i].live_cond |= switch_option;
      switches[i].validated = 1;
    }

       p += len;
     }
     break;

   case '*':
     if (soft_matched_part)
       {
  if (soft_matched_part[0])
    do_spec_1 (soft_matched_part, 1, ((void *)0));
  do_spec_1 (" ", 0, ((void *)0));
       }
     else



       error ("spec failure: %<%%*%> has not been initialized by pattern match");
     break;




   case '(':
     {
       const char *name = p;
       struct spec_list *sl;
       int len;



       while (*p && *p != ')')
  p++;


       for (len = p - name, sl = specs; sl; sl = sl->next)
  if (sl->name_len == len && !strncmp (sl->name, name, len))
    {
      name = *(sl->ptr_spec);




      break;
    }

       if (sl)
  {
    value = do_spec_1 (name, 0, ((void *)0));
    if (value != 0)
      return value;
  }


       if (*p)
  p++;
     }
     break;

   default:
     error ("spec failure: unrecognized spec option %qc", c);
     break;
   }
 break;

      case '\\':

 c = *p++;


      default:

 __extension__ ({ struct obstack *__o = (&obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (c)); (void) 0; });
 arg_going = 1;
      }



  if (processing_spec_function)
    end_going_arg ();

  return 0;
}



static const struct spec_function *
lookup_spec_function (const char *name)
{
  const struct spec_function *sf;

  for (sf = static_spec_functions; sf->name != ((void *)0); sf++)
    if (strcmp (sf->name, name) == 0)
      return sf;

  return ((void *)0);
}



static const char *
eval_spec_function (const char *func, const char *args)
{
  const struct spec_function *sf;
  const char *funcval;


  VEC_const_char_p_heap *save_argbuf;

  int save_arg_going;
  int save_delete_this_arg;
  int save_this_is_output_file;
  int save_this_is_library_file;
  int save_input_from_pipe;
  int save_this_is_linker_script;
  const char *save_suffix_subst;


  sf = lookup_spec_function (func);
  if (sf == ((void *)0))
    fatal_error ("unknown spec function %qs", func);


  save_argbuf = argbuf;

  save_arg_going = arg_going;
  save_delete_this_arg = delete_this_arg;
  save_this_is_output_file = this_is_output_file;
  save_this_is_library_file = this_is_library_file;
  save_this_is_linker_script = this_is_linker_script;
  save_input_from_pipe = input_from_pipe;
  save_suffix_subst = suffix_subst;




  alloc_args ();
  if (do_spec_2 (args) < 0)
    fatal_error ("error in args to spec function %qs", func);




  funcval = (*sf->func) ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))),
    (VEC_const_char_p_base_address(((argbuf) ? &(argbuf)->base : 0))));


  (VEC_const_char_p_heap_free(&argbuf));
  argbuf = save_argbuf;

  arg_going = save_arg_going;
  delete_this_arg = save_delete_this_arg;
  this_is_output_file = save_this_is_output_file;
  this_is_library_file = save_this_is_library_file;
  this_is_linker_script = save_this_is_linker_script;
  input_from_pipe = save_input_from_pipe;
  suffix_subst = save_suffix_subst;

  return funcval;
}
# 5364 "gcc.c"
static const char *
handle_spec_function (const char *p)
{
  char *func, *args;
  const char *endp, *funcval;
  int count;

  processing_spec_function++;


  for (endp = p; *endp != '\0'; endp++)
    {
      if (*endp == '(')
        break;

      if (!ISALNUM (*endp) && !(*endp == '-' || *endp == '_'))
 fatal_error ("malformed spec function name");
    }
  if (*endp != '(')
    fatal_error ("no arguments for spec function");
  func = save_string (p, endp - p);
  p = ++endp;


  for (count = 0; *endp != '\0'; endp++)
    {

      if (*endp == ')')
 {
   if (count == 0)
     break;
   count--;
 }
      else if (*endp == '(')
 count++;
    }

  if (*endp != ')')
    fatal_error ("malformed spec function arguments");
  args = save_string (p, endp - p);
  p = ++endp;



  funcval = eval_spec_function (func, args);
  if (funcval != ((void *)0) && do_spec_1 (funcval, 0, ((void *)0)) < 0)
    p = ((void *)0);

  free (func);
  free (args);

  processing_spec_function--;

  return p;
}



static inline unsigned char
input_suffix_matches (const char *atom, const char *end_atom)
{
  return (input_suffix
   && !strncmp (input_suffix, atom, end_atom - atom)
   && input_suffix[end_atom - atom] == '\0');
}



static unsigned char
input_spec_matches (const char *atom, const char *end_atom)
{
  return (input_file_compiler
   && input_file_compiler->suffix
   && input_file_compiler->suffix[0] != '\0'
   && !strncmp (input_file_compiler->suffix + 1, atom,
         end_atom - atom)
   && input_file_compiler->suffix[end_atom - atom + 1] == '\0');
}




static unsigned char
switch_matches (const char *atom, const char *end_atom, int starred)
{
  int i;
  int len = end_atom - atom;
  int plen = starred ? len : -1;

  for (i = 0; i < n_switches; i++)
    if (!strncmp (switches[i].part1, atom, len)
 && (starred || switches[i].part1[len] == '\0')
 && check_live_switch (i, plen))
      return 1;

  return 0;
}




static inline void
mark_matching_switches (const char *atom, const char *end_atom, int starred)
{
  int i;
  int len = end_atom - atom;
  int plen = starred ? len : -1;

  for (i = 0; i < n_switches; i++)
    if (!strncmp (switches[i].part1, atom, len)
 && (starred || switches[i].part1[len] == '\0')
 && check_live_switch (i, plen))
      switches[i].ordering = 1;
}



static inline void
process_marked_switches (void)
{
  int i;

  for (i = 0; i < n_switches; i++)
    if (switches[i].ordering == 1)
      {
 switches[i].ordering = 0;
 give_switch (i, 0);
      }
}





static const char *
handle_braces (const char *p)
{
  const char *atom, *end_atom;
  const char *d_atom = ((void *)0), *d_end_atom = ((void *)0);
  const char *orig = p;

  unsigned char a_is_suffix;
  unsigned char a_is_spectype;
  unsigned char a_is_starred;
  unsigned char a_is_negated;
  unsigned char a_matched;

  unsigned char a_must_be_last = 0;
  unsigned char ordered_set = 0;
  unsigned char disjunct_set = 0;
  unsigned char disj_matched = 0;
  unsigned char disj_starred = 1;
  unsigned char n_way_choice = 0;
  unsigned char n_way_matched = 0;



  do
    {
      if (a_must_be_last)
 goto invalid;



      a_matched = 0;
      a_is_suffix = 0;
      a_is_starred = 0;
      a_is_negated = 0;
      a_is_spectype = 0;

      do { while (*p == ' ' || *p == '\t') p++; } while (0);
      if (*p == '!')
 p++, a_is_negated = 1;

      do { while (*p == ' ' || *p == '\t') p++; } while (0);
      if (*p == '.')
 p++, a_is_suffix = 1;
      else if (*p == ',')
 p++, a_is_spectype = 1;

      atom = p;
      while (ISIDNUM(*p) || *p == '-' || *p == '+' || *p == '='
      || *p == ',' || *p == '.' || *p == '@')
 p++;
      end_atom = p;

      if (*p == '*')
 p++, a_is_starred = 1;

      do { while (*p == ' ' || *p == '\t') p++; } while (0);
      switch (*p)
 {
 case '&': case '}':

   ordered_set = 1;
   if (disjunct_set || n_way_choice || a_is_negated || a_is_suffix
       || a_is_spectype || atom == end_atom)
     goto invalid;

   mark_matching_switches (atom, end_atom, a_is_starred);

   if (*p == '}')
     process_marked_switches ();
   break;

 case '|': case ':':


   disjunct_set = 1;
   if (ordered_set)
     goto invalid;

   if (atom == end_atom)
     {
       if (!n_way_choice || disj_matched || *p == '|'
    || a_is_negated || a_is_suffix || a_is_spectype
    || a_is_starred)
  goto invalid;



       a_must_be_last = 1;
       disj_matched = !n_way_matched;
       disj_starred = 0;
     }
   else
     {
       if ((a_is_suffix || a_is_spectype) && a_is_starred)
  goto invalid;

       if (!a_is_starred)
  disj_starred = 0;



       if (!disj_matched && !n_way_matched)
  {
    if (a_is_suffix)
      a_matched = input_suffix_matches (atom, end_atom);
    else if (a_is_spectype)
      a_matched = input_spec_matches (atom, end_atom);
    else
      a_matched = switch_matches (atom, end_atom, a_is_starred);

    if (a_matched != a_is_negated)
      {
        disj_matched = 1;
        d_atom = atom;
        d_end_atom = end_atom;
      }
  }
     }

   if (*p == ':')
     {


       p = process_brace_body (p + 1, d_atom, d_end_atom, disj_starred,
          disj_matched && !n_way_matched);
       if (p == 0)
  return 0;



       if (*p == ';')
  {
    n_way_choice = 1;
    n_way_matched |= disj_matched;
    disj_matched = 0;
    disj_starred = 1;
    d_atom = d_end_atom = ((void *)0);
  				}
     			}
   break;

 default:
   goto invalid;
		}
	}
  while (*p++ != '}');

  return p;

 invalid:
  fatal_error ("braced spec %qs is invalid at %qc", orig, *p);


}
# 5663 "gcc.c"
static const char *
process_brace_body (const char *p, const char *atom, const char *end_atom,
      int starred, int matched)
{
  const char *body, *end_body;
  unsigned int nesting_level;
  unsigned char have_subst = 0;



  body = p;
  nesting_level = 1;
  for (;;)
    {
      if (*p == '{')
 nesting_level++;
      else if (*p == '}')
 {
   if (!--nesting_level)
     break;
 }
      else if (*p == ';' && nesting_level == 1)
 break;
      else if (*p == '%' && p[1] == '*' && nesting_level == 1)
 have_subst = 1;
      else if (*p == '\0')
 goto invalid;
      p++;
    }

  end_body = p;
  while (end_body[-1] == ' ' || end_body[-1] == '\t')
    end_body--;

  if (have_subst && !starred)
    goto invalid;

  if (matched)
    {



      char *string = save_string (body, end_body - body);
      if (!have_subst)
 {
   if (do_spec_1 (string, 0, ((void *)0)) < 0)
     return 0;
 }
      else
 {



   unsigned int hard_match_len = end_atom - atom;
   int i;

   for (i = 0; i < n_switches; i++)
     if (!strncmp (switches[i].part1, atom, hard_match_len)
  && check_live_switch (i, hard_match_len))
       {
  if (do_spec_1 (string, 0,
          &switches[i].part1[hard_match_len]) < 0)
    return 0;

  give_switch (i, 1);
  suffix_subst = ((void *)0);
       }
 }
    }

  return p;

 invalid:
  fatal_error ("braced spec body %qs is invalid", body);
}
# 5747 "gcc.c"
static int
check_live_switch (int switchnum, int prefix_length)
{
  const char *name = switches[switchnum].part1;
  int i;



  if (switches[switchnum].live_cond != 0)
    return ((switches[switchnum].live_cond & (1 << 0)) != 0
     && (switches[switchnum].live_cond & (1 << 1)) == 0
     && (switches[switchnum].live_cond & (1 << 3))
        == 0);




  if (prefix_length >= 0 && prefix_length <= 1)
    return 1;


  switch (*name)
    {
    case 'O':
      for (i = switchnum + 1; i < n_switches; i++)
 if (switches[i].part1[0] == 'O')
   {
     switches[switchnum].validated = 1;
     switches[switchnum].live_cond = (1 << 1);
     return 0;
   }
      break;

    case 'W': case 'f': case 'm':
      if (! strncmp (name + 1, "no-", 3))
 {

   for (i = switchnum + 1; i < n_switches; i++)
     if (switches[i].part1[0] == name[0]
  && ! strcmp (&switches[i].part1[1], &name[4]))
       {
  switches[switchnum].validated = 1;
  switches[switchnum].live_cond = (1 << 1);
  return 0;
       }
 }
      else
 {

   for (i = switchnum + 1; i < n_switches; i++)
     if (switches[i].part1[0] == name[0]
  && switches[i].part1[1] == 'n'
  && switches[i].part1[2] == 'o'
  && switches[i].part1[3] == '-'
  && !strcmp (&switches[i].part1[4], &name[1]))
       {
  switches[switchnum].validated = 1;
  switches[switchnum].live_cond = (1 << 1);
  return 0;
       }
 }
      break;
    }


  switches[switchnum].live_cond |= (1 << 0);
  return 1;
}
# 5824 "gcc.c"
static void
give_switch (int switchnum, int omit_first_word)
{
  if ((switches[switchnum].live_cond & (1 << 2)) != 0)
    return;

  if (!omit_first_word)
    {
      do_spec_1 ("-", 0, ((void *)0));
      do_spec_1 (switches[switchnum].part1, 1, ((void *)0));
    }

  if (switches[switchnum].args != 0)
    {
      const char **p;
      for (p = switches[switchnum].args; *p; p++)
 {
   const char *arg = *p;

   do_spec_1 (" ", 0, ((void *)0));
   if (suffix_subst)
     {
       unsigned length = strlen (arg);
       int dot = 0;

       while (length-- && !IS_DIR_SEPARATOR (arg[length]))
  if (arg[length] == '.')
    {
      (((char *) helper_const_non_const_cast ((const char *) (const char *) ((arg)))))[length] = 0;
      dot = 1;
      break;
    }
       do_spec_1 (arg, 1, ((void *)0));
       if (dot)
  (((char *) helper_const_non_const_cast ((const char *) (const char *) ((arg)))))[length] = '.';
       do_spec_1 (suffix_subst, 1, ((void *)0));
     }
   else
     do_spec_1 (arg, 1, ((void *)0));
 }
    }

  do_spec_1 (" ", 0, ((void *)0));
  switches[switchnum].validated = 1;
}





static const char *
find_file (const char *name)
{
  char *newname = find_a_file (&startfile_prefixes, name, 4, 1);
  return newname ? newname : name;
}




static int
is_directory (const char *path1, unsigned char linker)
{
  int len1;
  char *path;
  char *cp;
  struct stat st;



  len1 = strlen (path1);
  path = (char *) __builtin_alloca (3 + len1);
  memcpy (path, path1, len1);
  cp = path + len1;
  if (!IS_DIR_SEPARATOR (cp[-1]))
    *cp++ = '/';
  *cp++ = '.';
  *cp = '\0';


  if (linker
      && IS_DIR_SEPARATOR (path[0])
      && ((cp - path == 6
    && filename_ncmp (path + 1, "lib", 3) == 0)
   || (cp - path == 10
       && filename_ncmp (path + 1, "usr", 3) == 0
       && IS_DIR_SEPARATOR (path[4])
       && filename_ncmp (path + 5, "lib", 3) == 0)))
    return 0;

  return (stat (path, &st) >= 0 && ((((st.st_mode)) & 0170000) == (0040000)));
}




void
set_input (const char *filename)
{
  const char *p;

  gcc_input_filename = filename;
  input_filename_length = strlen (gcc_input_filename);
  input_basename = lbasename (gcc_input_filename);



  basename_length = strlen (input_basename);
  suffixed_basename_length = basename_length;
  p = input_basename + basename_length;
  while (p != input_basename && *p != '.')
    --p;
  if (*p == '.' && p != input_basename)
    {
      basename_length = p - input_basename;
      input_suffix = p + 1;
    }
  else
    input_suffix = "";




  input_stat_set = 0;
}



static void
fatal_signal (int signum)
{
  signal (signum, ((__sighandler_t) 0));
  delete_failure_queue ();
  delete_temp_files ();


  kill (getpid (), signum);
}





static int
compare_files (char *cmpfile[])
{
  int ret = 0;
  FILE *temp[2] = { ((void *)0), ((void *)0) };
  int i;


  {
    size_t length[2];
    void *map[2] = { ((void *)0), ((void *)0) };

    for (i = 0; i < 2; i++)
      {
 struct stat st;

 if (stat (cmpfile[i], &st) < 0 || !((((st.st_mode)) & 0170000) == (0100000)))
   {
     error ("%s: could not determine length of compare-debug file %s",
     gcc_input_filename, cmpfile[i]);
     ret = 1;
     break;
   }

 length[i] = st.st_size;
      }

    if (!ret && length[0] != length[1])
      {
 error ("%s: -fcompare-debug failure (length)", gcc_input_filename);
 ret = 1;
      }

    if (!ret)
      for (i = 0; i < 2; i++)
 {
   int fd = open (cmpfile[i], 00);
   if (fd < 0)
     {
       error ("%s: could not open compare-debug file %s",
       gcc_input_filename, cmpfile[i]);
       ret = 1;
       break;
     }

   map[i] = mmap (((void *)0), length[i], 0x1, 0x02, fd, 0);
   close (fd);

   if (map[i] == (void *) ((void *) -1))
     {
       ret = -1;
       break;
     }
 }

    if (!ret)
      {
 if (memcmp (map[0], map[1], length[0]) != 0)
   {
     error ("%s: -fcompare-debug failure", gcc_input_filename);
     ret = 1;
   }
      }

    for (i = 0; i < 2; i++)
      if (map[i])
 munmap ((caddr_t) map[i], length[i]);

    if (ret >= 0)
      return ret;

    ret = 0;
  }


  for (i = 0; i < 2; i++)
    {
      temp[i] = fopen_unlocked(cmpfile[i],"r");
      if (!temp[i])
 {
   error ("%s: could not open compare-debug file %s",
   gcc_input_filename, cmpfile[i]);
   ret = 1;
   break;
 }
    }

  if (!ret && temp[0] && temp[1])
    for (;;)
      {
 int c0, c1;
 c0 = fgetc_unlocked (temp[0]);
 c1 = fgetc_unlocked (temp[1]);

 if (c0 != c1)
   {
     error ("%s: -fcompare-debug failure",
     gcc_input_filename);
     ret = 1;
     break;
   }

 if (c0 == (-1))
   break;
      }

  for (i = 1; i >= 0; i--)
    {
      if (temp[i])
 fclose (temp[i]);
    }

  return ret;
}

extern int main (int, char **);

int
main (int argc, char **argv)
{
  size_t i;
  int value;
  int linker_was_run = 0;
  int lang_n_infiles = 0;
  int num_linker_inputs = 0;
  char *explicit_link_files;
  char *specs_file;
  char *lto_wrapper_file;
  const char *p;
  struct user_specs *uptr;
  char **old_argv = argv;
  struct cl_decoded_option *decoded_options;
  unsigned int decoded_options_count;



  asm_debug = "";

  p = argv[0] + strlen (argv[0]);
  while (p != argv[0] && !IS_DIR_SEPARATOR (p[-1]))
    --p;
  progname = p;

  xmalloc_set_program_name (progname);

  expandargv (&argc, &argv);


  if (argv != old_argv)
    at_file_supplied = 1;


  global_init_params ();
  finish_params ();

  init_options_struct (&global_options, &global_options_set);

  decode_cmdline_options_to_array (argc, ((const char **) helper_const_non_const_cast ((const char *) (char **) (argv))),

       (1U << 19),
       &decoded_options, &decoded_options_count);







  unlock_std_streams ();

  ;

  diagnostic_initialize (global_dc, 0);
  if (atexit (delete_temp_files) != 0)
    fatal_error ("atexit failed");

  if (signal (2, ((__sighandler_t) 1)) != ((__sighandler_t) 1))
    signal (2, fatal_signal);

  if (signal (1, ((__sighandler_t) 1)) != ((__sighandler_t) 1))
    signal (1, fatal_signal);

  if (signal (15, ((__sighandler_t) 1)) != ((__sighandler_t) 1))
    signal (15, fatal_signal);

  if (signal (13, ((__sighandler_t) 1)) != ((__sighandler_t) 1))
    signal (13, fatal_signal);




  signal (17, ((__sighandler_t) 0));




  stack_limit_increase (64 * 1024 * 1024);


  alloc_args ();

  _obstack_begin ((&obstack), 0, 0, (void *(*) (long)) ((void *(*) (long)) xmalloc), (void (*) (void *)) ((void (*) (void *)) free));



  {
    const char *const *q = multilib_raw;
    int need_space;

    _obstack_begin ((&multilib_obstack), 0, 0, (void *(*) (long)) ((void *(*) (long)) xmalloc), (void (*) (void *)) ((void (*) (void *)) free));
    while ((p = *q++) != (char *) 0)
      __extension__ ({ struct obstack *__o = (&multilib_obstack); int __len = (strlen (p)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, p, __len); __o->next_free += __len; (void) 0; });

    __extension__ ({ struct obstack *__o = (&multilib_obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (0)); (void) 0; });
    multilib_select = XOBFINISH (&multilib_obstack, const char *);

    q = multilib_matches_raw;
    while ((p = *q++) != (char *) 0)
      __extension__ ({ struct obstack *__o = (&multilib_obstack); int __len = (strlen (p)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, p, __len); __o->next_free += __len; (void) 0; });

    __extension__ ({ struct obstack *__o = (&multilib_obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (0)); (void) 0; });
    multilib_matches = XOBFINISH (&multilib_obstack, const char *);

    q = multilib_exclusions_raw;
    while ((p = *q++) != (char *) 0)
      __extension__ ({ struct obstack *__o = (&multilib_obstack); int __len = (strlen (p)); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, p, __len); __o->next_free += __len; (void) 0; });

    __extension__ ({ struct obstack *__o = (&multilib_obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (0)); (void) 0; });
    multilib_exclusions = XOBFINISH (&multilib_obstack, const char *);

    need_space = 0;
    for (i = 0; i < ARRAY_SIZE (multilib_defaults_raw); i++)
      {
 if (need_space)
   __extension__ ({ struct obstack *__o = (&multilib_obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (' ')); (void) 0; });
 __extension__ ({ struct obstack *__o = (&multilib_obstack); int __len = (strlen (multilib_defaults_raw[i])); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, multilib_defaults_raw[i], __len); __o->next_free += __len; (void) 0; });


 need_space = 1;
      }

    __extension__ ({ struct obstack *__o = (&multilib_obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (0)); (void) 0; });
    multilib_defaults = XOBFINISH (&multilib_obstack, const char *);
  }
# 6221 "gcc.c"
  process_command (decoded_options_count, decoded_options);




  compilers = XNEWVAR (struct compiler, sizeof default_compilers);
  memcpy (compilers, default_compilers, sizeof default_compilers);
  n_compilers = n_default_compilers;



  machine_suffix = concat (spec_machine, dir_separator_str,
      spec_version, dir_separator_str, ((void *)0));
  just_machine_suffix = concat (spec_machine, dir_separator_str, ((void *)0));

  specs_file = find_a_file (&startfile_prefixes, "specs", 4, 1);

  if (specs_file != 0 && strcmp (specs_file, "specs"))
    read_specs (specs_file, 1);
  else
    init_spec ();



  specs_file = (char *) __builtin_alloca (strlen (standard_exec_prefix) + strlen (just_machine_suffix) + sizeof ("specs"));


  strcpy (specs_file, standard_exec_prefix);
  strcat (specs_file, just_machine_suffix);
  strcat (specs_file, "specs");
  if (access (specs_file, 4) == 0)
    read_specs (specs_file, 1);



  for (i = 0; i < ARRAY_SIZE (option_default_specs); i++)
    do_option_spec (option_default_specs[i].name,
      option_default_specs[i].spec);




  for (i = 0; i < ARRAY_SIZE (driver_self_specs); i++)
    do_self_spec (driver_self_specs[i]);



  if (*cross_compile == '0')
    {
      if (*md_exec_prefix)
 {
   add_prefix (&exec_prefixes, md_exec_prefix, "GCC",
        PREFIX_PRIORITY_LAST, 0, 0);
 }
    }


  if (*sysroot_suffix_spec != 0
      && do_spec_2 (sysroot_suffix_spec) == 0)
    {
      if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 1)
        error ("spec failure: more than one arg to SYSROOT_SUFFIX_SPEC");
      else if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) == 1)
        target_sysroot_suffix = xstrdup ((VEC_const_char_p_base_last(((argbuf) ? &(argbuf)->base : 0) ,"gcc.c",6284,"?")));
    }
# 6301 "gcc.c"
  if (*sysroot_hdrs_suffix_spec != 0
      && do_spec_2 (sysroot_hdrs_suffix_spec) == 0)
    {
      if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 1)
        error ("spec failure: more than one arg to SYSROOT_HEADERS_SUFFIX_SPEC");
      else if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) == 1)
        target_sysroot_hdrs_suffix = xstrdup ((VEC_const_char_p_base_last(((argbuf) ? &(argbuf)->base : 0) ,"gcc.c",6307,"?")));
    }


  if (*startfile_prefix_spec != 0
      && do_spec_2 (startfile_prefix_spec) == 0
      && do_spec_1 (" ", 0, ((void *)0)) == 0)
    {
      const char *arg;
      int ndx;
      for (ndx = 0; (VEC_const_char_p_base_iterate((((argbuf)) ? &((argbuf))->base : 0),(ndx),&((arg)))); ++(ndx))
 add_sysrooted_prefix (&startfile_prefixes, arg, "BINUTILS",
         PREFIX_PRIORITY_LAST, 0, 1);
    }


  else if (*cross_compile == '0' || target_system_root)
    {
      if (*md_startfile_prefix)
 add_sysrooted_prefix (&startfile_prefixes, md_startfile_prefix,
         "GCC", PREFIX_PRIORITY_LAST, 0, 1);

      if (*md_startfile_prefix_1)
 add_sysrooted_prefix (&startfile_prefixes, md_startfile_prefix_1,
         "GCC", PREFIX_PRIORITY_LAST, 0, 1);
# 6340 "gcc.c"
      if (IS_ABSOLUTE_PATH (standard_startfile_prefix))
 add_sysrooted_prefix (&startfile_prefixes,
         standard_startfile_prefix, "BINUTILS",
         PREFIX_PRIORITY_LAST, 0, 1);
      else if (*cross_compile == '0')
 {
   add_prefix (&startfile_prefixes,
        concat (gcc_exec_prefix
         ? gcc_exec_prefix : standard_exec_prefix,
         machine_suffix,
         standard_startfile_prefix, ((void *)0)),
        ((void *)0), PREFIX_PRIORITY_LAST, 0, 1);
 }



      if (*standard_startfile_prefix_1)
  add_sysrooted_prefix (&startfile_prefixes,
         standard_startfile_prefix_1, "BINUTILS",
         PREFIX_PRIORITY_LAST, 0, 1);
      if (*standard_startfile_prefix_2)
 add_sysrooted_prefix (&startfile_prefixes,
         standard_startfile_prefix_2, "BINUTILS",
         PREFIX_PRIORITY_LAST, 0, 1);
    }



  for (uptr = user_specs_head; uptr; uptr = uptr->next)
    {
      char *filename = find_a_file (&startfile_prefixes, uptr->filename,
        4, 1);
      read_specs (filename ? filename : uptr->filename, 0);
    }


  {
    struct spec_list *sl;
    for (sl = specs; sl; sl = sl->next)
      if (sl->name_len == sizeof "self_spec" - 1
   && !strcmp (sl->name, "self_spec"))
 do_self_spec (*sl->ptr_spec);
  }

  if (compare_debug)
    {
      enum save_temps save;

      if (!compare_debug_second)
 {
   n_switches_debug_check[1] = n_switches;
   n_switches_alloc_debug_check[1] = n_switches_alloc;
   switches_debug_check[1] = XDUPVEC (struct switchstr, switches,
          n_switches_alloc);

   do_self_spec ("%:compare-debug-self-opt()");
   n_switches_debug_check[0] = n_switches;
   n_switches_alloc_debug_check[0] = n_switches_alloc;
   switches_debug_check[0] = switches;

   n_switches = n_switches_debug_check[1];
   n_switches_alloc = n_switches_alloc_debug_check[1];
   switches = switches_debug_check[1];
 }


      save = save_temps_flag;
      save_temps_flag = SAVE_TEMPS_NONE;

      compare_debug = -compare_debug;
      do_self_spec ("%:compare-debug-self-opt()");

      save_temps_flag = save;

      if (!compare_debug_second)
 {
   n_switches_debug_check[1] = n_switches;
   n_switches_alloc_debug_check[1] = n_switches_alloc;
   switches_debug_check[1] = switches;
   compare_debug = -compare_debug;
   n_switches = n_switches_debug_check[0];
   n_switches_alloc = n_switches_debug_check[0];
   switches = switches_debug_check[0];
 }
    }



  if (gcc_exec_prefix)
    gcc_exec_prefix = concat (gcc_exec_prefix, spec_machine, dir_separator_str,
         spec_version, dir_separator_str, ((void *)0));




  validate_all_switches ();



  set_multilib_dir ();




  _obstack_begin ((&collect_obstack), 0, 0, (void *(*) (long)) ((void *(*) (long)) xmalloc), (void (*) (void *)) ((void (*) (void *)) free));
  __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (sizeof ("COLLECT_GCC=") - 1); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "COLLECT_GCC=", __len); __o->next_free += __len; (void) 0; });
  __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (strlen (argv[0]) + 1); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, argv[0], __len); __o->next_free += __len; (void) 0; });
  xputenv (XOBFINISH (&collect_obstack, char *));



  lto_wrapper_file = find_a_file (&exec_prefixes, "lto-wrapper", 1, 0);
  if (lto_wrapper_file)
    {
      lto_wrapper_spec = lto_wrapper_file;
      _obstack_begin ((&collect_obstack), 0, 0, (void *(*) (long)) ((void *(*) (long)) xmalloc), (void (*) (void *)) ((void (*) (void *)) free));
      __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (sizeof ("COLLECT_LTO_WRAPPER=") - 1); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, "COLLECT_LTO_WRAPPER=", __len); __o->next_free += __len; (void) 0; });

      __extension__ ({ struct obstack *__o = (&collect_obstack); int __len = (strlen (lto_wrapper_spec) + 1); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, lto_wrapper_spec, __len); __o->next_free += __len; (void) 0; });

      xputenv (XOBFINISH (&collect_obstack, char *));
    }



  for (i = 0; (int) i < n_switches; i++)
    if (! switches[i].validated)
      error ("unrecognized option %<-%s%>", switches[i].part1);



  if (global_options.x_print_search_dirs)
    {
      printf (("install: %s%s\n"),
       gcc_exec_prefix ? gcc_exec_prefix : standard_exec_prefix,
       gcc_exec_prefix ? "" : machine_suffix);
      printf (("programs: %s\n"),
       build_search_list (&exec_prefixes, "", 0, 0));
      printf (("libraries: %s\n"),
       build_search_list (&startfile_prefixes, "", 0, 1));
      return (0);
    }

  if (global_options.x_print_file_name)
    {
      printf ("%s\n", find_file (global_options.x_print_file_name));
      return (0);
    }

  if (global_options.x_print_prog_name)
    {
      char *newname = find_a_file (&exec_prefixes, global_options.x_print_prog_name, 1, 0);
      printf ("%s\n", (newname ? newname : global_options.x_print_prog_name));
      return (0);
    }

  if (global_options.x_print_multi_lib)
    {
      print_multilib_info ();
      return (0);
    }

  if (global_options.x_print_multi_directory)
    {
      if (multilib_dir == ((void *)0))
 printf (".\n");
      else
 printf ("%s\n", multilib_dir);
      return (0);
    }

  if (global_options.x_print_sysroot)
    {
      if (target_system_root)
 {
          if (target_sysroot_suffix)
     printf ("%s%s\n", target_system_root, target_sysroot_suffix);
          else
     printf ("%s\n", target_system_root);
 }
      return (0);
    }

  if (global_options.x_print_multi_os_directory)
    {
      if (multilib_os_dir == ((void *)0))
 printf (".\n");
      else
 printf ("%s\n", multilib_os_dir);
      return (0);
    }

  if (global_options.x_print_sysroot_headers_suffix)
    {
      if (*sysroot_hdrs_suffix_spec)
 {
   printf("%s\n", (target_sysroot_hdrs_suffix
     ? target_sysroot_hdrs_suffix
     : ""));
   return (0);
 }
      else


 fatal_error ("not configured with sysroot headers suffix");
    }

  if (print_help_list)
    {
      display_help ();

      if (! global_options.x_verbose_flag)
 {
   printf (("\nFor bug reporting instructions, please see:\n"));
   printf ("%s.\n", bug_report_url);

   return (0);
 }





      fputc_unlocked ('\n', stdout);
      fflush_unlocked (stdout);
    }

  if (print_version)
    {
      printf (("%s %s%s\n"), progname, pkgversion_string,
       version_string);
      printf ("Copyright %s 2011 Free Software Foundation, Inc.\n",
       ("(C)"));
      fputs_unlocked (("This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"), stdout);


      if (! global_options.x_verbose_flag)
 return 0;



      fputc_unlocked ('\n', stdout);
      fflush_unlocked (stdout);
    }

  if (global_options.x_verbose_flag)
    {
      int n;
      const char *thrmod;

      fnotice (stderr, "Target: %s\n", spec_machine);
      fnotice (stderr, "Configured with: %s\n", configuration_arguments);
# 6602 "gcc.c"
      thrmod = thread_model;


      fnotice (stderr, "Thread model: %s\n", thrmod);




      for (n = 0; version_string[n]; n++)
 if (version_string[n] == ' ')
   break;

      if (! strncmp (version_string, compiler_version, n)
   && compiler_version[n] == 0)
 fnotice (stderr, "gcc version %s %s\n", version_string,
   pkgversion_string);
      else
 fnotice (stderr, "gcc driver version %s %sexecuting gcc version %s\n",
   version_string, pkgversion_string, compiler_version);

      if (n_infiles == 0)
 return (0);
    }

  if (n_infiles == added_libraries)
    fatal_error ("no input files");

  if (seen_error ())
    goto out;




  i = n_infiles;
  i += lang_specific_extra_outfiles;
  outfiles = XCNEWVEC (const char *, i);



  explicit_link_files = XCNEWVEC (char, n_infiles);

  combine_inputs = have_o || global_options.x_flag_wpa;

  for (i = 0; (int) i < n_infiles; i++)
    {
      const char *name = infiles[i].name;
      struct compiler *compiler = lookup_compiler (name,
         strlen (name),
         infiles[i].language);

      if (compiler && !(compiler->combinable))
 combine_inputs = 0;

      if (lang_n_infiles > 0 && compiler != input_file_compiler
   && infiles[i].language && infiles[i].language[0] != '*')
 infiles[i].incompiler = compiler;
      else if (compiler)
 {
   lang_n_infiles++;
   input_file_compiler = compiler;
   infiles[i].incompiler = compiler;
 }
      else
 {


   explicit_link_files[i] = 1;
   infiles[i].incompiler = ((void *)0);
 }
      infiles[i].compiled = 0;
      infiles[i].preprocessed = 0;
    }

  if (!combine_inputs && have_c && have_o && lang_n_infiles > 1)
    fatal_error ("cannot specify -o with -c, -S or -E with multiple files");

  for (i = 0; (int) i < n_infiles; i++)
    {
      int this_file_error = 0;



      input_file_number = i;
      set_input (infiles[i].name);

      if (infiles[i].compiled)
 continue;



      outfiles[i] = gcc_input_filename;



      input_file_compiler
 = lookup_compiler (infiles[i].name, input_filename_length,
      infiles[i].language);

      if (input_file_compiler)
 {


   if (input_file_compiler->spec[0] == '#')
     {
       error ("%s: %s compiler not installed on this system",
       gcc_input_filename, &input_file_compiler->spec[1]);
       this_file_error = 1;
     }
   else
     {
       if (compare_debug)
  {
    free (debug_check_temp_file[0]);
    debug_check_temp_file[0] = ((void *)0);

    free (debug_check_temp_file[1]);
    debug_check_temp_file[1] = ((void *)0);
  }

       value = do_spec (input_file_compiler->spec);
       infiles[i].compiled = 1;
       if (value < 0)
  this_file_error = 1;
       else if (compare_debug && debug_check_temp_file[0])
  {
    if (global_options.x_verbose_flag)
      inform (0, "recompiling with -fcompare-debug");

    compare_debug = -compare_debug;
    n_switches = n_switches_debug_check[1];
    n_switches_alloc = n_switches_alloc_debug_check[1];
    switches = switches_debug_check[1];

    value = do_spec (input_file_compiler->spec);

    compare_debug = -compare_debug;
    n_switches = n_switches_debug_check[0];
    n_switches_alloc = n_switches_alloc_debug_check[0];
    switches = switches_debug_check[0];

    if (value < 0)
      {
        error ("during -fcompare-debug recompilation");
        this_file_error = 1;
      }

    ((void)(!(debug_check_temp_file[1] && filename_cmp (debug_check_temp_file[0], debug_check_temp_file[1])) ? fancy_abort ("gcc.c", 6750, "?"), 0 : 0));



    if (global_options.x_verbose_flag)
      inform (0, "comparing final insns dumps");

    if (compare_files (debug_check_temp_file))
      this_file_error = 1;
  }

       if (compare_debug)
  {
    free (debug_check_temp_file[0]);
    debug_check_temp_file[0] = ((void *)0);

    free (debug_check_temp_file[1]);
    debug_check_temp_file[1] = ((void *)0);
  }
     }
 }




      else
 explicit_link_files[i] = 1;




      if (this_file_error)
 {
   delete_failure_queue ();
   (global_dc)->diagnostic_count[(int) (DK_ERROR)]++;
 }

      clear_failure_queue ();
    }





  if (n_infiles > 0)
    {
      int i;

      for (i = 0; i < n_infiles ; i++)
 if (infiles[i].incompiler
     || (infiles[i].language && infiles[i].language[0] != '*'))
   {
     set_input (infiles[i].name);
     break;
   }
    }

  if (!seen_error ())
    {


      input_file_number = n_infiles;
      if (lang_specific_pre_link ())
 (global_dc)->diagnostic_count[(int) (DK_ERROR)]++;
    }


  num_linker_inputs = 0;
  for (i = 0; (int) i < n_infiles; i++)
    if (explicit_link_files[i] || outfiles[i] != ((void *)0))
      num_linker_inputs++;



  if (num_linker_inputs > 0 && !seen_error () && print_subprocess_help < 2)
    {
      int tmp = execution_count;
# 6834 "gcc.c"
      if (! strcmp (linker_name_spec, "collect2"))
 {
   char *s = find_a_file (&exec_prefixes, "collect2", 1, 0);
   if (s == ((void *)0))
     linker_name_spec = "ld";
 }
# 6857 "gcc.c"
      lto_gcc_spec = argv[0];



      putenv_from_prefixes (&exec_prefixes, "COMPILER_PATH", 0);
      putenv_from_prefixes (&startfile_prefixes, "LIBRARY_PATH", 1);

      if (print_subprocess_help == 1)
 {
   printf (("\nLinker options\n==============\n\n"));
   printf (("Use \"-Wl,OPTION\" to pass \"OPTION\"" " to the linker.\n\n"));

   fflush_unlocked (stdout);
 }
      value = do_spec (link_command_spec);
      if (value < 0)
 (global_dc)->diagnostic_count[(int) (DK_ERROR)] = 1;
      linker_was_run = (tmp != execution_count);
    }




  if (! linker_was_run && !seen_error ())
    for (i = 0; (int) i < n_infiles; i++)
      if (explicit_link_files[i]
   && !(infiles[i].language && infiles[i].language[0] == '*'))
 warning (0, "%s: linker input file unused because linking not done",
   outfiles[i]);



  if (seen_error ())
    delete_failure_queue ();
  delete_temp_files ();

  if (print_help_list)
    {
      printf (("\nFor bug reporting instructions, please see:\n"));
      printf ("%s\n", bug_report_url);
    }

 out:
  return (signal_count != 0 ? 2
   : seen_error () ? (global_options.x_pass_exit_codes ? greatest_status : 1)
   : 0);
}





static struct compiler *
lookup_compiler (const char *name, size_t length, const char *language)
{
  struct compiler *cp;


  if (language != 0 && language[0] == '*')
    return 0;


  if (language != 0)
    {
      for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)
 if (cp->suffix[0] == '@' && !strcmp (cp->suffix + 1, language))
   return cp;

      error ("language %s not recognized", language);
      return 0;
    }


  for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)
    {
      if (
   (!strcmp (cp->suffix, "-") && !strcmp (name, "-"))
   || (strlen (cp->suffix) < length

       && !strcmp (cp->suffix,
     name + length - strlen (cp->suffix))
  ))
 break;
    }
# 6961 "gcc.c"
  if (cp >= compilers)
    {
      if (cp->spec[0] != '@')

 return cp;




      return lookup_compiler (((void *)0), 0, cp->spec + 1);
    }
  return 0;
}

static char *
save_string (const char *s, int len)
{
  char *result = XNEWVEC (char, len + 1);

  memcpy (result, s, len);
  result[len] = 0;
  return result;
}

void
pfatal_with_name (const char *name)
{
  perror_with_name (name);
  delete_temp_files ();
  exit (1);
}

static void
perror_with_name (const char *name)
{
  error ("%s: %m", name);
}

static inline void
validate_switches_from_spec (const char *spec)
{
  const char *p = spec;
  char c;
  while ((c = *p++))
    if (c == '%' && (*p == '{' || *p == '<' || (*p == 'W' && *++p == '{')))

      p = validate_switches (p + 1);
}

static void
validate_all_switches (void)
{
  struct compiler *comp;
  struct spec_list *spec;

  for (comp = compilers; comp->spec; comp++)
    validate_switches_from_spec (comp->spec);


  for (spec = specs; spec; spec = spec->next)
    validate_switches_from_spec (*spec->ptr_spec);

  validate_switches_from_spec (link_command_spec);
}




static const char *
validate_switches (const char *start)
{
  const char *p = start;
  const char *atom;
  size_t len;
  int i;
  unsigned char suffix = 0;
  unsigned char starred = 0;



next_member:
  do { while (*p == ' ' || *p == '\t') p++; } while (0);

  if (*p == '!')
    p++;

  do { while (*p == ' ' || *p == '\t') p++; } while (0);
  if (*p == '.' || *p == ',')
    suffix = 1, p++;

  atom = p;
  while (ISIDNUM (*p) || *p == '-' || *p == '+' || *p == '='
  || *p == ',' || *p == '.' || *p == '@')
    p++;
  len = p - atom;

  if (*p == '*')
    starred = 1, p++;

  do { while (*p == ' ' || *p == '\t') p++; } while (0);

  if (!suffix)
    {

      for (i = 0; i < n_switches; i++)
 if (!strncmp (switches[i].part1, atom, len)
     && (starred || switches[i].part1[len] == 0))
   switches[i].validated = 1;
    }

  if (*p) p++;
  if (*p && (p[-1] == '|' || p[-1] == '&'))
    goto next_member;

  if (*p && p[-1] == ':')
    {
      while (*p && *p != ';' && *p != '}')
 {
   if (*p == '%')
     {
       p++;
       if (*p == '{' || *p == '<')
  p = validate_switches (p+1);
       else if (p[0] == 'W' && p[1] == '{')
  p = validate_switches (p+2);
     }
   else
     p++;
 }

      if (*p) p++;
      if (*p && p[-1] == ';')
 goto next_member;
    }

  return p;

}

struct mdswitchstr
{
  const char *str;
  int len;
};

static struct mdswitchstr *mdswitches;
static int n_mdswitches;




static int
used_arg (const char *p, int len)
{
  struct mswitchstr
  {
    const char *str;
    const char *replace;
    int len;
    int rep_len;
  };

  static struct mswitchstr *mswitches;
  static int n_mswitches;
  int i, j;

  if (!mswitches)
    {
      struct mswitchstr *matches;
      const char *q;
      int cnt = 0;



      for (q = multilib_matches; *q != '\0'; q++)
 if (*q == ';')
   cnt++;

      matches
 = (struct mswitchstr *) __builtin_alloca ((sizeof (struct mswitchstr)) * cnt);
      i = 0;
      q = multilib_matches;
      while (*q != '\0')
 {
   matches[i].str = q;
   while (*q != ' ')
     {
       if (*q == '\0')
  {
  invalid_matches:
    fatal_error ("multilib spec %qs is invalid",
          multilib_matches);
  }
       q++;
     }
   matches[i].len = q - matches[i].str;

   matches[i].replace = ++q;
   while (*q != ';' && *q != '\0')
     {
       if (*q == ' ')
  goto invalid_matches;
       q++;
     }
   matches[i].rep_len = q - matches[i].replace;
   i++;
   if (*q == ';')
     q++;
 }





      mswitches
 = XNEWVEC (struct mswitchstr, n_mdswitches + (n_switches ? n_switches : 1));
      for (i = 0; i < n_switches; i++)
 if ((switches[i].live_cond & (1 << 2)) == 0)
   {
     int xlen = strlen (switches[i].part1);
     for (j = 0; j < cnt; j++)
       if (xlen == matches[j].len
    && ! strncmp (switches[i].part1, matches[j].str, xlen))
  {
    mswitches[n_mswitches].str = matches[j].replace;
    mswitches[n_mswitches].len = matches[j].rep_len;
    mswitches[n_mswitches].replace = (char *) 0;
    mswitches[n_mswitches].rep_len = 0;
    n_mswitches++;
    break;
  }
   }




      for (i = 0; i < n_mdswitches; i++)
 {
   const char *r;

   for (q = multilib_options; *q != '\0'; q++)
     {
       while (*q == ' ')
  q++;

       r = q;
       while (strncmp (q, mdswitches[i].str, mdswitches[i].len) != 0
       || strchr (" /", q[mdswitches[i].len]) == ((void *)0))
  {
    while (*q != ' ' && *q != '/' && *q != '\0')
      q++;
    if (*q != '/')
      break;
    q++;
  }

       if (*q != ' ' && *q != '\0')
  {
    while (*r != ' ' && *r != '\0')
      {
        q = r;
        while (*q != ' ' && *q != '/' && *q != '\0')
   q++;

        if (used_arg (r, q - r))
   break;

        if (*q != '/')
   {
     mswitches[n_mswitches].str = mdswitches[i].str;
     mswitches[n_mswitches].len = mdswitches[i].len;
     mswitches[n_mswitches].replace = (char *) 0;
     mswitches[n_mswitches].rep_len = 0;
     n_mswitches++;
     break;
   }

        r = q + 1;
      }
    break;
  }
     }
 }
    }

  for (i = 0; i < n_mswitches; i++)
    if (len == mswitches[i].len && ! strncmp (p, mswitches[i].str, len))
      return 1;

  return 0;
}

static int
default_arg (const char *p, int len)
{
  int i;

  for (i = 0; i < n_mdswitches; i++)
    if (len == mdswitches[i].len && ! strncmp (p, mdswitches[i].str, len))
      return 1;

  return 0;
}
# 7276 "gcc.c"
static void
set_multilib_dir (void)
{
  const char *p;
  unsigned int this_path_len;
  const char *this_path, *this_arg;
  const char *start, *end;
  int not_arg;
  int ok, ndfltok, first;

  n_mdswitches = 0;
  start = multilib_defaults;
  while (*start == ' ' || *start == '\t')
    start++;
  while (*start != '\0')
    {
      n_mdswitches++;
      while (*start != ' ' && *start != '\t' && *start != '\0')
 start++;
      while (*start == ' ' || *start == '\t')
        start++;
    }

  if (n_mdswitches)
    {
      int i = 0;

      mdswitches = XNEWVEC (struct mdswitchstr, n_mdswitches);
      for (start = multilib_defaults; *start != '\0'; start = end + 1)
 {
   while (*start == ' ' || *start == '\t')
     start++;

   if (*start == '\0')
     break;

   for (end = start + 1;
        *end != ' ' && *end != '\t' && *end != '\0'; end++)
     ;

   __extension__ ({ struct obstack *__o = (&multilib_obstack); int __len = (end - start); if (__o->next_free + __len > __o->chunk_limit) _obstack_newchunk (__o, __len); memcpy (__o->next_free, start, __len); __o->next_free += __len; (void) 0; });
   __extension__ ({ struct obstack *__o = (&multilib_obstack); if (__o->next_free + 1 > __o->chunk_limit) _obstack_newchunk (__o, 1); (*((__o)->next_free)++ = (0)); (void) 0; });
   mdswitches[i].str = XOBFINISH (&multilib_obstack, const char *);
   mdswitches[i++].len = end - start;

   if (*end == '\0')
     break;
 }
    }

  p = multilib_exclusions;
  while (*p != '\0')
    {

      if (*p == '\n')
 {
   ++p;
   continue;
 }


      ok = 1;
      while (*p != ';')
 {
   if (*p == '\0')
     {
     invalid_exclusions:
       fatal_error ("multilib exclusions %qs is invalid",
      multilib_exclusions);
     }

   if (! ok)
     {
       ++p;
       continue;
     }

   this_arg = p;
   while (*p != ' ' && *p != ';')
     {
       if (*p == '\0')
  goto invalid_exclusions;
       ++p;
     }

   if (*this_arg != '!')
     not_arg = 0;
   else
     {
       not_arg = 1;
       ++this_arg;
     }

   ok = used_arg (this_arg, p - this_arg);
   if (not_arg)
     ok = ! ok;

   if (*p == ' ')
     ++p;
 }

      if (ok)
 return;

      ++p;
    }

  first = 1;
  p = multilib_select;
  while (*p != '\0')
    {

      if (*p == '\n')
 {
   ++p;
   continue;
 }


      this_path = p;
      while (*p != ' ')
 {
   if (*p == '\0')
     {
     invalid_select:
       fatal_error ("multilib select %qs is invalid",
      multilib_select);
     }
   ++p;
 }
      this_path_len = p - this_path;


      ok = 1;
      ndfltok = 1;
      ++p;
      while (*p != ';')
 {
   if (*p == '\0')
     goto invalid_select;

   if (! ok)
     {
       ++p;
       continue;
     }

   this_arg = p;
   while (*p != ' ' && *p != ';')
     {
       if (*p == '\0')
  goto invalid_select;
       ++p;
     }

   if (*this_arg != '!')
     not_arg = 0;
   else
     {
       not_arg = 1;
       ++this_arg;
     }
# 7446 "gcc.c"
   ok = used_arg (this_arg, p - this_arg);
   if (not_arg)
     ok = ! ok;

   if (! ok)
     ndfltok = 0;

   if (default_arg (this_arg, p - this_arg))
     ok = 1;

   if (*p == ' ')
     ++p;
 }

      if (ok && first)
 {
   if (this_path_len != 1
       || this_path[0] != '.')
     {
       char *new_multilib_dir = XNEWVEC (char, this_path_len + 1);
       char *q;

       strncpy (new_multilib_dir, this_path, this_path_len);
       new_multilib_dir[this_path_len] = '\0';
       q = strchr (new_multilib_dir, ':');
       if (q != ((void *)0))
  *q = '\0';
       multilib_dir = new_multilib_dir;
     }
   first = 0;
 }

      if (ndfltok)
 {
   const char *q = this_path, *end = this_path + this_path_len;

   while (q < end && *q != ':')
     q++;
   if (q < end)
     {
       char *new_multilib_os_dir = XNEWVEC (char, end - q);
       memcpy (new_multilib_os_dir, q + 1, end - q - 1);
       new_multilib_os_dir[end - q - 1] = '\0';
       multilib_os_dir = new_multilib_os_dir;
       break;
     }
 }

      ++p;
    }

  if (multilib_dir == ((void *)0) && multilib_os_dir != ((void *)0)
      && strcmp (multilib_os_dir, ".") == 0)
    {
      free (((char *) helper_const_non_const_cast ((const char *) (const char *) ((multilib_os_dir)))));
      multilib_os_dir = ((void *)0);
    }
  else if (multilib_dir != ((void *)0) && multilib_os_dir == ((void *)0))
    multilib_os_dir = multilib_dir;
}
# 7517 "gcc.c"
static void
print_multilib_info (void)
{
  const char *p = multilib_select;
  const char *last_path = 0, *this_path;
  int skip;
  unsigned int last_path_len = 0;

  while (*p != '\0')
    {
      skip = 0;

      if (*p == '\n')
 {
   ++p;
   continue;
 }


      this_path = p;
      while (*p != ' ')
 {
   if (*p == '\0')
     {
     invalid_select:
       fatal_error ("multilib select %qs is invalid", multilib_select);
     }

   ++p;
 }




      if (this_path[0] == '.' && this_path[1] == ':')
 skip = 1;




      {
 const char *e = multilib_exclusions;
 const char *this_arg;

 while (*e != '\0')
   {
     int m = 1;

     if (*e == '\n')
       {
  ++e;
  continue;
       }


     while (*e != ';')
       {
  const char *q;
  int mp = 0;

  if (*e == '\0')
    {
    invalid_exclusion:
      fatal_error ("multilib exclusion %qs is invalid",
     multilib_exclusions);
    }

  if (! m)
    {
      ++e;
      continue;
    }

  this_arg = e;

  while (*e != ' ' && *e != ';')
    {
      if (*e == '\0')
        goto invalid_exclusion;
      ++e;
    }

  q = p + 1;
  while (*q != ';')
    {
      const char *arg;
      int len = e - this_arg;

      if (*q == '\0')
        goto invalid_select;

      arg = q;

      while (*q != ' ' && *q != ';')
        {
   if (*q == '\0')
     goto invalid_select;
   ++q;
        }

      if (! strncmp (arg, this_arg,
       (len < q - arg) ? q - arg : len)
   || default_arg (this_arg, e - this_arg))
        {
   mp = 1;
   break;
        }

      if (*q == ' ')
        ++q;
    }

  if (! mp)
    m = 0;

  if (*e == ' ')
    ++e;
       }

     if (m)
       {
  skip = 1;
  break;
       }

     if (*e != '\0')
       ++e;
   }
      }

      if (! skip)
 {

   skip = (last_path != 0
    && (unsigned int) (p - this_path) == last_path_len
    && ! filename_ncmp (last_path, this_path, last_path_len));

   last_path = this_path;
   last_path_len = p - this_path;
 }




      if (! skip)
 {
   const char *q;

   q = p + 1;
   while (*q != ';')
     {
       const char *arg;

       if (*q == '\0')
  goto invalid_select;

       if (*q == '!')
  arg = ((void *)0);
       else
  arg = q;

       while (*q != ' ' && *q != ';')
  {
    if (*q == '\0')
      goto invalid_select;
    ++q;
  }

       if (arg != ((void *)0)
    && default_arg (arg, q - arg))
  {
    skip = 1;
    break;
  }

       if (*q == ' ')
  ++q;
     }
 }

      if (! skip)
 {
   const char *p1;

   for (p1 = last_path; p1 < p && *p1 != ':'; p1++)
     putchar_unlocked (*p1);
   putchar_unlocked (';');
 }

      ++p;
      while (*p != ';')
 {
   int use_arg;

   if (*p == '\0')
     goto invalid_select;

   if (skip)
     {
       ++p;
       continue;
     }

   use_arg = *p != '!';

   if (use_arg)
     putchar_unlocked ('@');

   while (*p != ' ' && *p != ';')
     {
       if (*p == '\0')
  goto invalid_select;
       if (use_arg)
  putchar_unlocked (*p);
       ++p;
     }

   if (*p == ' ')
     ++p;
 }

      if (! skip)
 {

   if (multilib_extra && *multilib_extra)
     {
       int print_at = 1;
       const char *q;

       for (q = multilib_extra; *q != '\0'; q++)
  {
    if (*q == ' ')
      print_at = 1;
    else
      {
        if (print_at)
   putchar_unlocked ('@');
        putchar_unlocked (*q);
        print_at = 0;
      }
  }
     }

   putchar_unlocked ('\n');
 }

      ++p;
    }
}







static const char *
getenv_spec_function (int argc, const char **argv)
{
  char *value;
  char *result;
  char *ptr;
  size_t len;

  if (argc != 2)
    return ((void *)0);

  value = getenv (argv[0]);
  if (!value)
    fatal_error ("environment variable %qs not defined", argv[0]);





  len = strlen (value) * 2 + strlen (argv[1]) + 1;
  result = XNEWVAR (char, len);
  for (ptr = result; *value; ptr += 2)
    {
      ptr[0] = '\\';
      ptr[1] = *value++;
    }

  strcpy (ptr, argv[1]);

  return result;
}
# 7813 "gcc.c"
static const char *
if_exists_spec_function (int argc, const char **argv)
{

  if (argc == 1 && IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], 4))
    return argv[0];

  return ((void *)0);
}






static const char *
if_exists_else_spec_function (int argc, const char **argv)
{

  if (argc != 2)
    return ((void *)0);

  if (IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], 4))
    return argv[0];

  return argv[1];
}






static const char *
replace_outfile_spec_function (int argc, const char **argv)
{
  int i;

  if (argc != 2)
    fancy_abort ("gcc.c", 7852, "?");

  for (i = 0; i < n_infiles; i++)
    {
      if (outfiles[i] && !filename_cmp (outfiles[i], argv[0]))
 outfiles[i] = xstrdup (argv[1]);
    }
  return ((void *)0);
}






static const char *
remove_outfile_spec_function (int argc, const char **argv)
{
  int i;

  if (argc != 1)
    fancy_abort ("gcc.c", 7873, "?");

  for (i = 0; i < n_infiles; i++)
    {
      if (outfiles[i] && !filename_cmp (outfiles[i], argv[0]))
        outfiles[i] = ((void *)0);
    }
  return ((void *)0);
}





static int
compare_version_strings (const char *v1, const char *v2)
{
  int rresult;
  regex_t r;

  if (regcomp (&r, "^([1-9][0-9]*|0)(\\.([1-9][0-9]*|0))*$",
        REG_EXTENDED | REG_NOSUB) != 0)
    fancy_abort ("gcc.c", 7895, "?");
  rresult = regexec (&r, v1, 0, ((void *)0), 0);
  if (rresult == REG_NOMATCH)
    fatal_error ("invalid version number %qs", v1);
  else if (rresult != 0)
    fancy_abort ("gcc.c", 7900, "?");
  rresult = regexec (&r, v2, 0, ((void *)0), 0);
  if (rresult == REG_NOMATCH)
    fatal_error ("invalid version number %qs", v2);
  else if (rresult != 0)
    fancy_abort ("gcc.c", 7905, "?");

  return strverscmp (v1, v2);
}
# 7936 "gcc.c"
static const char *
version_compare_spec_function (int argc, const char **argv)
{
  int comp1, comp2;
  size_t switch_len;
  const char *switch_value = ((void *)0);
  int nargs = 1, i;
  unsigned char result;

  if (argc < 3)
    fatal_error ("too few arguments to %%:version-compare");
  if (argv[0][0] == '\0')
    fancy_abort ("gcc.c", 7948, "?");
  if ((argv[0][1] == '<' || argv[0][1] == '>') && argv[0][0] != '!')
    nargs = 2;
  if (argc != nargs + 3)
    fatal_error ("too many arguments to %%:version-compare");

  switch_len = strlen (argv[nargs + 1]);
  for (i = 0; i < n_switches; i++)
    if (!strncmp (switches[i].part1, argv[nargs + 1], switch_len)
 && check_live_switch (i, switch_len))
      switch_value = switches[i].part1 + switch_len;

  if (switch_value == ((void *)0))
    comp1 = comp2 = -1;
  else
    {
      comp1 = compare_version_strings (switch_value, argv[1]);
      if (nargs == 2)
 comp2 = compare_version_strings (switch_value, argv[2]);
      else
 comp2 = -1;
    }

  switch (argv[0][0] << 8 | argv[0][1])
    {
    case '>' << 8 | '=':
      result = comp1 >= 0;
      break;
    case '!' << 8 | '<':
      result = comp1 >= 0 || switch_value == ((void *)0);
      break;
    case '<' << 8:
      result = comp1 < 0;
      break;
    case '!' << 8 | '>':
      result = comp1 < 0 || switch_value == ((void *)0);
      break;
    case '>' << 8 | '<':
      result = comp1 >= 0 && comp2 < 0;
      break;
    case '<' << 8 | '>':
      result = comp1 < 0 || comp2 >= 0;
      break;

    default:
      fatal_error ("unknown operator %qs in %%:version-compare", argv[0]);
    }
  if (! result)
    return ((void *)0);

  return argv[nargs + 2];
}






static const char *
include_spec_function (int argc, const char **argv)
{
  char *file;

  if (argc != 1)
    fancy_abort ("gcc.c", 8012, "?");

  file = find_a_file (&startfile_prefixes, argv[0], 4, 1);
  read_specs (file ? file : argv[0], 0);

  return ((void *)0);
}




static const char *
find_file_spec_function (int argc, const char **argv)
{
  const char *file;

  if (argc != 1)
    fancy_abort ("gcc.c", 8029, "?");

  file = find_file (argv[0]);
  return file;
}





static const char *
find_plugindir_spec_function (int argc, const char **argv ATTRIBUTE_UNUSED)
{
  const char *option;

  if (argc != 0)
    fancy_abort ("gcc.c", 8045, "?");

  option = concat ("-iplugindir=", find_file ("plugin"), ((void *)0));
  return option;
}





static const char *
print_asm_header_spec_function (int arg ATTRIBUTE_UNUSED,
    const char **argv ATTRIBUTE_UNUSED)
{
  printf (("Assembler options\n=================\n\n"));
  printf (("Use \"-Wa,OPTION\" to pass \"OPTION\" to the assembler.\n\n"));
  fflush_unlocked (stdout);
  return ((void *)0);
}



static unsigned
get_local_tick (void)
{
  unsigned ret = 0;



  {
    struct timeval tv;

    gettimeofday (&tv, ((void *)0));
    ret = tv.tv_sec * 1000 + tv.tv_usec / 1000;
  }
# 8089 "gcc.c"
  return ret;
}





static const char *
compare_debug_dump_opt_spec_function (int arg,
          const char **argv ATTRIBUTE_UNUSED)
{
  const char *ret;
  char *name;
  int which;
  static char random_seed[(8 * 8) / 4 + 3];

  if (arg != 0)
    fatal_error ("too many arguments to %%:compare-debug-dump-opt");

  do_spec_2 ("%{fdump-final-insns=*:%*}");
  do_spec_1 (" ", 0, ((void *)0));

  if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 0
      && strcmp (argv[(VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) - 1], "."))
    {
      if (!compare_debug)
 return ((void *)0);

      name = xstrdup (argv[(VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) - 1]);
      ret = ((void *)0);
    }
  else
    {
      const char *ext = ((void *)0);

      if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 0)
 {
   do_spec_2 ("%{o*:%*}%{!o:%{!S:%b%O}%{S:%b.s}}");
   ext = ".gkd";
 }
      else if (!compare_debug)
 return ((void *)0);
      else
 do_spec_2 ("%g.gkd");

      do_spec_1 (" ", 0, ((void *)0));

      ((void)(!((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 0) ? fancy_abort ("gcc.c", 8136, "?"), 0 : 0));

      name = concat ((VEC_const_char_p_base_last(((argbuf) ? &(argbuf)->base : 0) ,"gcc.c",8138,"?")), ext, ((void *)0));

      ret = concat ("-fdump-final-insns=", name, ((void *)0));
    }

  which = compare_debug < 0;
  debug_check_temp_file[which] = name;

  if (!which)
    {
      unsigned long long value = get_local_tick () ^ getpid ();

      sprintf (random_seed, "%#" "ll" "x", value);
    }

  if (*random_seed)
    ret = concat ("%{!frandom-seed=*:-frandom-seed=", random_seed, "} ",
    ret, ((void *)0));

  if (which)
    *random_seed = 0;

  return ret;
}

static const char *debug_auxbase_opt;





static const char *
compare_debug_self_opt_spec_function (int arg,
          const char **argv ATTRIBUTE_UNUSED)
{
  if (arg != 0)
    fatal_error ("too many arguments to %%:compare-debug-self-opt");

  if (compare_debug >= 0)
    return ((void *)0);

  do_spec_2 ("%{c|S:%{o*:%*}}");
  do_spec_1 (" ", 0, ((void *)0));

  if ((VEC_const_char_p_base_length(((argbuf) ? &(argbuf)->base : 0))) > 0)
    debug_auxbase_opt = concat ("-auxbase-strip ",
    (VEC_const_char_p_base_last(((argbuf) ? &(argbuf)->base : 0) ,"gcc.c",8184,"?")),
    ((void *)0));
  else
    debug_auxbase_opt = ((void *)0);

  return concat ("%<o %<MD %<MMD %<MF* %<MG %<MP %<MQ* %<MT* %<fdump-final-insns=* -w -S -o %j %{!fcompare-debug-second:-fcompare-debug-second} ", compare_debug_opt, ((void *)0));




}






static const char *
compare_debug_auxbase_opt_spec_function (int arg,
      const char **argv)
{
  char *name;
  int len;

  if (arg == 0)
    fatal_error ("too few arguments to %%:compare-debug-auxbase-opt");

  if (arg != 1)
    fatal_error ("too many arguments to %%:compare-debug-auxbase-opt");

  if (compare_debug >= 0)
    return ((void *)0);

  len = strlen (argv[0]);
  if (len < 3 || strcmp (argv[0] + len - 3, ".gk") != 0)
    fatal_error ("argument to %%:compare-debug-auxbase-opt "
   "does not end in .gk");

  if (debug_auxbase_opt)
    return debug_auxbase_opt;



  len -= 3;
  name = (char*) xmalloc (sizeof ("-auxbase ") + len);
  memcpy (name, "-auxbase ", sizeof ("-auxbase ") - 1);
  memcpy (name + sizeof ("-auxbase ") - 1, argv[0], len);
  name[sizeof ("-auxbase ") - 1 + len] = '\0';



  return name;
}






const char *
pass_through_libs_spec_func (int argc, const char **argv)
{
  char *prepended = xstrdup (" ");
  int n;



  for (n = 0; n < argc; n++)
    {
      char *old = prepended;



      if (argv[n][0] == '-' && argv[n][1] == 'l')
 {
   const char *lopt = argv[n] + 2;



   if (!*lopt && ++n >= argc)
     break;
   else if (!*lopt)
     lopt = argv[n];
   prepended = concat (prepended, "-plugin-opt=-pass-through=-l",
  lopt, " ", ((void *)0));
 }
      else if (!strcmp (".a", argv[n] + strlen (argv[n]) - 2))
 {
   prepended = concat (prepended, "-plugin-opt=-pass-through=",
  argv[n], " ", ((void *)0));
 }
      if (prepended != old)
 free (old);
    }
  return prepended;
}
